This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__tests__/
  .gitkeep
  GISManager.test.ts
.github/
  workflows/
    ci.yml
src/
  components/
    TokyoStationExplorer.tsx
    Web3DExplorerComponent.tsx
  core/
    Explorer.ts
  gis/
    GISManager.ts
  types/
    gis.ts
    index.ts
    testing.ts
  utils/
    EventEmitter.ts
  .gitkeep
  index.ts
three-test-suite/
  __tests__/
    PuppeteerManager.test.js
  docs/
    design-philosophy.md
    quick-start.md
  src/
    PuppeteerManager.js
  package.json
  README.md
.eslintrc.js
.gitignore
.prettierrc
CHANGELOG.md
jest.config.js
jest.setup.js
LICENSE
package.json
README.md
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x] # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã‚µãƒãƒ¼ãƒˆã™ã‚‹Node.jsã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install Puppeteer dependencies
      run: sudo apt-get update && sudo apt-get install -y libgbm-dev

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      run: npm test

    - name: Run test suite
      run: npm run test:suite

    - name: Run repomix
      if: success() # å‰ã®ã‚¹ãƒ†ãƒƒãƒ—ãŒã™ã¹ã¦æˆåŠŸã—ãŸå ´åˆã®ã¿å®Ÿè¡Œ
      run: npx repomix
</file>

<file path="__tests__/.gitkeep">
# ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
</file>

<file path="src/components/Web3DExplorerComponent.tsx">
import React from 'react';
import { Web3DExplorerConfig, PerformanceMetrics } from '../types'; // Import types directly
import Explorer from '../core/Explorer'; // Import Explorer directly (default import)

export interface Web3DExplorerComponentProps {
  config?: Web3DExplorerConfig;
  initialData?: any;
  onExplorerReady?: (explorer: Explorer) => void;
  onPerformanceUpdate?: (metrics: PerformanceMetrics) => void;
  style?: React.CSSProperties;
  className?: string;
}

export const Web3DExplorerComponent: React.FC<Web3DExplorerComponentProps> = ({ config, initialData, onExplorerReady, onPerformanceUpdate, style, className }) => {
  // TODO: Implement Web3DExplorerComponent
  return (
    <div>
      <h1>Web3D Explorer Component</h1>
      <p>Content goes here.</p>
      {initialData && <pre>{JSON.stringify(initialData, null, 2)}</pre>}
    </div>
  );
};

export default Web3DExplorerComponent;
</file>

<file path="src/gis/GISManager.ts">
import { BuildingData, RoadData, POIData, TerrainData, GISLayer, TOKYO_PROJECTION } from '../types/gis';
import { GeoCoordinates } from '../types'; // Assuming GeoCoordinates is in ../types/index.ts

export class GISManager {
  private projection: TOKYO_PROJECTION | string;
  private layers: Map<string, GISLayer> = new Map();

  constructor(projection?: TOKYO_PROJECTION | string) {
    this.projection = projection || 'EPSG:4326'; // Default projection
    // TODO: Implement GISManager initialization
  }

  public geoToWorld(geoCoords: GeoCoordinates): { x: number; y: number; z: number } {
    // TODO: Implement geographic to world coordinate conversion
    console.log('geoToWorld called with:', geoCoords, 'using projection:', this.projection);
    // Placeholder implementation
    return { x: geoCoords.longitude, y: geoCoords.latitude, z: geoCoords.altitude || 0 };
  }

  public worldToGeo(worldCoords: { x: number; y: number; z?: number }): GeoCoordinates {
    // TODO: Implement world to geographic coordinate conversion
    console.log('worldToGeo called with:', worldCoords, 'using projection:', this.projection);
    // Placeholder implementation
    return { longitude: worldCoords.x, latitude: worldCoords.y, altitude: worldCoords.z || 0 };
  }

  public createTerrain(terrainData: TerrainData): any { // THREE.Mesh | null
    // TODO: Implement terrain creation
    console.log('createTerrain called with:', terrainData);
    return null; // Placeholder
  }

  public createBuilding(buildingData: BuildingData): any { // THREE.Mesh | null
    // TODO: Implement building creation
    console.log('createBuilding called with:', buildingData);
    return null; // Placeholder
  }

  public createRoad(roadData: RoadData): any { // THREE.Line | null
    // TODO: Implement road creation
    console.log('createRoad called with:', roadData);
    return null; // Placeholder
  }

  public createPOI(poiData: POIData): any { // THREE.Sprite | THREE.Mesh | null
    // TODO: Implement POI creation
    console.log('createPOI called with:', poiData);
    return null; // Placeholder
  }

  public addLayer(layer: GISLayer): void {
    // TODO: Implement add layer
    this.layers.set(layer.id, layer);
    console.log('addLayer called with:', layer);
  }

  public getLayer(layerId: string): GISLayer | undefined {
    // TODO: Implement get layer
    console.log('getLayer called for:', layerId);
    return this.layers.get(layerId);
  }

  public removeLayer(layerId: string): boolean {
    // TODO: Implement remove layer
    console.log('removeLayer called for:', layerId);
    return this.layers.delete(layerId);
  }

  public toggleLayer(layerId: string): boolean {
    // TODO: Implement toggle layer visibility
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.visible = !layer.visible;
      console.log(`Layer ${layerId} visibility toggled to: ${layer.visible}`);
      return true;
    }
    console.log(`Layer ${layerId} not found for toggling.`);
    return false;
  }

  // Add other GIS related methods here
}
</file>

<file path="src/types/gis.ts">
import { GeoCoordinates } from './index'; // Assuming GeoCoordinates is in index.ts

export type TOKYO_PROJECTION = string; // Placeholder type, could be an enum or a more specific type

export interface TokyoStationArea {
    station: BuildingData;
    nearbyBuildings: BuildingData[];
    roads: RoadData[];
    exits: POIData[];
    terrain: TerrainData;
    platforms?: any[]; // Added platforms
    concourse?: any[]; // Added concourse
}

export interface BuildingData {
  id: string;
  name?: string;
  coordinates: GeoCoordinates | GeoCoordinates[] | GeoCoordinates[][] | number[][][] | { latitude: number; longitude: number; altitude?: number } | { latitude: number; longitude: number; altitude?: number }[];
  properties?: Record<string, any>;
  height?: number;
  footprint?: GeoCoordinates[]; // Added based on error TS2353
  // Add other BuildingData properties
}

export interface RoadData {
  id: string;
  name?: string;
  coordinates: GeoCoordinates[] | number[][] | { latitude: number; longitude: number }[];
  properties?: Record<string, any>;
  type?: string;
  width?: number; // Added based on error TS2353
  // Add other RoadData properties
}

export interface POIData {
  id: string;
  name?: string;
  type?: string;
  // coordinate field is correct as per definition, test code uses 'coordinates'
  coordinate: GeoCoordinates | [number, number] | { latitude: number; longitude: number };
  properties?: Record<string, any>;
  // Add other POIData properties
}

export interface TerrainData {
  id: string;
  sourceUrl?: string; // Made optional as some test data might not have it
  width?: number;
  height?: number;
  resolution?: number;
  data?: Float32Array | any;
  bounds?: { min: GeoCoordinates; max: GeoCoordinates; }; // Added based on error TS2353
  // Add other TerrainData properties
}

// Add other GIS related types here
// Example Layer type
export interface GISLayer {
    id: string;
    name: string;
    // type "buildings" will be corrected in test file to "building"
    type: 'building' | 'road' | 'poi' | 'terrain' | 'custom';
    data: BuildingData[] | RoadData[] | POIData[] | TerrainData[] | any[];
    visible: boolean;
    style?: any; // Style information for rendering
}
</file>

<file path="src/types/index.ts">
// Generic Event Handler Type
export type EventHandler<T = any> = (data: T) => void;

export interface GeoCoordinates {
  latitude: number;
  longitude: number;
  altitude?: number;
}

export interface Object3DConfig {
  position?: { x: number; y: number; z: number }; // Changed to object
  rotation?: { x: number; y: number; z: number }; // Changed to object
  scale?: { x: number; y: number; z: number };    // Changed to object
  visible?: boolean;
  name?: string; // Added name property
  [key: string]: any; // Allow other properties
}

import * as THREE from 'three'; // Import THREE for ColorRepresentation

// Configuration for the Web3DExplorer
export interface Web3DExplorerConfig {
  containerId?: string;
  backgroundColor?: THREE.ColorRepresentation;
  enableControls?: boolean;
  debug?: boolean;
  scene?: {
    background?: THREE.ColorRepresentation; // Added background to scene config
    fog?: { // Added fog to scene config
        type: 'linear' | 'exponential';
        color: THREE.ColorRepresentation;
        near?: number;
        far?: number;
        density?: number;
    };
    ambientLight?: { color?: THREE.ColorRepresentation; intensity?: number };
    [key: string]: any; // Allow other scene properties
  };
  camera?: {
    fov?: number;
    aspect?: number;
    near?: number;
    far?: number;
    position?: { x: number; y: number; z: number }; // Changed to object
    target?: { x: number; y: number; z: number };   // Changed to object
    [key: string]: any; // Allow other camera properties
  };
  renderer?: {
    canvas?: HTMLCanvasElement; // Added canvas for renderer
    antialias?: boolean;
    alpha?: boolean;
    preserveDrawingBuffer?: boolean; // Added preserveDrawingBuffer
    powerPreference?: 'default' | 'high-performance' | 'low-power';
    stencil?: boolean;
    depth?: boolean;
    logarithmicDepthBuffer?: boolean;
    // antialias and alpha were duplicated, removed from here
    pixelRatio?: number;
    [key: string]: any; // Allow other renderer properties
  };
  lights?: LightConfig[]; // Use a more specific type for light configurations
  performance?: { // Added based on error TS2353
    enableStats?: boolean;
    maxFPS?: number;
    adaptiveQuality?: boolean;
  };
  // Add other configuration options here
}

export type LightType = 'ambient' | 'directional' | 'point' | 'spot' | 'hemisphere';

export interface LightConfig {
    type: LightType;
    color?: THREE.ColorRepresentation;
    intensity?: number;
    position?: { x: number; y: number; z: number };
    target?: { x: number; y: number; z: number }; // For spot/directional lights
    angle?: number; // For spot lights
    penumbra?: number; // For spot lights
    decay?: number; // For point/spot lights
    distance?: number; // For point/spot lights
    castShadow?: boolean;
    groundColor?: THREE.ColorRepresentation; // For hemisphere lights
    [key: string]: any;
}


// Performance Metrics
export interface PerformanceMetrics {
  fps: number;
  memoryUsage: { // Fixed to object type
    geometries: number;
    textures: number;
    total: number; // in MB
  };
  drawCalls: number;
  triangles: number; // Made mandatory
  frameTime?: number;
  renderTime?: number;
  triangleCount?: number; // Kept as optional, can be an alias or specific
  // Add other relevant metrics
}

// Placeholder for Web3DExplorer class/interface
export interface Web3DExplorer {
  // TODO: Define methods and properties of the explorer instance
  scene: any; // THREE.Scene;
  camera: any; // THREE.PerspectiveCamera;
  renderer: any; // THREE.WebGLRenderer;
  dispose: () => void;
  // Add other methods like render, resize, addObject, etc.
}


// Re-export other types if necessary, for example:
// export * from './gis'; // If you want to re-export all types from gis.ts
</file>

<file path="src/types/testing.ts">
import * as THREE from 'three';
import { Web3DExplorer, PerformanceMetrics } from './index';

// ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å°‚ç”¨ã®å‹å®šç¾©

// ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç’°å¢ƒ
export interface TestEnvironment {
  browser: 'chrome' | 'firefox' | 'safari' | 'edge';
  viewport: {
    width: number;
    height: number;
  };
  webgl: {
    version: '1' | '2';
    extensions: string[];
  };
  capabilities: {
    maxTextureSize: number;
    maxRenderBufferSize: number;
    maxVertexAttributes: number;
  };
}

// ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«å›å¸°ãƒ†ã‚¹ãƒˆ
export interface VisualTest {
  name: string;
  description: string;
  referenceImage: string;
  threshold: number; // è¨±å®¹å·®ï¼ˆ0-1ï¼‰
  setup: (explorer: Web3DExplorer) => Promise<void>;
  capture: () => Promise<HTMLCanvasElement>;
}

// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
export interface PerformanceTest {
  name: string;
  description: string;
  duration: number; // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ™‚é–“ï¼ˆç§’ï¼‰
  expectations: {
    minFPS: number;
    maxFrameTime: number;
    maxMemoryUsage: number;
  };
  setup: (explorer: Web3DExplorer) => Promise<void>;
  execute: (explorer: Web3DExplorer) => Promise<PerformanceMetrics[]>;
}

// ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
export interface InteractionTest {
  name: string;
  description: string;
  interactions: {
    type: 'click' | 'hover' | 'drag' | 'wheel' | 'keyboard';
    target?: string; // ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã¾ãŸã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå
    coordinates?: { x: number; y: number };
    keys?: string[];
    duration?: number;
  }[];
  expectations: {
    expectedEvents: string[];
    expectedChanges: Record<string, any>;
  };
  setup: (explorer: Web3DExplorer) => Promise<void>;
  verify: (explorer: Web3DExplorer, results: any[]) => boolean;
}

// å˜ä½“ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯
export interface MockScene {
  scene: THREE.Scene;
  camera: THREE.PerspectiveCamera;
  renderer: THREE.WebGLRenderer;
  canvas: HTMLCanvasElement;
}

export interface MockObjects {
  cube: THREE.Mesh;
  sphere: THREE.Mesh;
  plane: THREE.Mesh;
  light: THREE.DirectionalLight;
  group: THREE.Group;
}

// ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã®è¨­å®š
export interface TestSuiteConfig {
  name: string;
  description: string;
  environment: TestEnvironment;
  timeout: number;
  retries: number;
  parallel: boolean;
  headless: boolean;
  outputDir: string;
  
  // ãƒ†ã‚¹ãƒˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
  only?: string[]; // å®Ÿè¡Œã™ã‚‹ãƒ†ã‚¹ãƒˆã®ã¿
  skip?: string[]; // ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ãƒ†ã‚¹ãƒˆ
  tags?: string[]; // ãƒ†ã‚¹ãƒˆã‚¿ã‚°ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
}

// ãƒ†ã‚¹ãƒˆçµæœ
export interface TestResult {
  name: string;
  status: 'passed' | 'failed' | 'skipped' | 'timeout';
  duration: number;
  error?: Error;
  metrics?: PerformanceMetrics;
  screenshot?: string;
  artifacts?: {
    logs: string[];
    traces: any[];
    recordings: string[];
  };
}

export interface TestSuiteResult {
  name: string;
  status: 'passed' | 'failed' | 'partial';
  startTime: Date;
  endTime: Date;
  duration: number;
  results: TestResult[];
  summary: {
    total: number;
    passed: number;
    failed: number;
    skipped: number;
  };
  coverage?: {
    lines: number;
    functions: number;
    branches: number;
    statements: number;
  };
}

// Three.jså°‚ç”¨ã®ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
export interface ThreeTestUtils {
  // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¤œè¨¼
  expectObject3D(object: THREE.Object3D): {
    toBeVisible(): void;
    toHavePosition(position: THREE.Vector3): void;
    toHaveRotation(rotation: THREE.Euler): void;
    toHaveScale(scale: THREE.Vector3): void;
    toBeInFrustum(camera: THREE.Camera): void;
  };
  
  // ãƒãƒ†ãƒªã‚¢ãƒ«æ¤œè¨¼
  expectMaterial(material: THREE.Material): {
    toBeTransparent(): void;
    toHaveColor(color: THREE.Color): void;
    toHaveTexture(texture: THREE.Texture): void;
  };
  
  // ã‚¸ã‚ªãƒ¡ãƒˆãƒªæ¤œè¨¼
  expectGeometry(geometry: THREE.BufferGeometry): {
    toHaveVertices(count: number): void;
    toHaveFaces(count: number): void;
    toHaveBoundingBox(box: THREE.Box3): void;
  };
  
  // ã‚·ãƒ¼ãƒ³æ¤œè¨¼
  expectScene(scene: THREE.Scene): {
    toContainObject(object: THREE.Object3D): void;
    toHaveObjectCount(count: number): void;
    toHaveLights(count: number): void;
  };
  
  // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ¤œè¨¼
  expectRenderer(renderer: THREE.WebGLRenderer): {
    toRenderWithoutErrors(): Promise<void>;
    toMatchImage(reference: string, threshold?: number): Promise<void>;
    toHavePerformance(metrics: Partial<PerformanceMetrics>): void;
  };
}

// Puppeteerçµ±åˆç”¨ã®å‹
export interface BrowserTestConfig {
  headless: boolean;
  viewport: { width: number; height: number };
  deviceScaleFactor?: number;
  userAgent?: string;
  timeout: number;
  slowMo?: number;
}

export interface BrowserTestContext {
  page: any; // Puppeteer.Page
  browser: any; // Puppeteer.Browser
  screenshot: (path: string) => Promise<void>;
  evaluate: <T>(fn: () => T) => Promise<T>;
  waitFor: (selector: string | number) => Promise<void>;
}

// ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼
export interface TestDataGenerator {
  generateMesh: (type: 'box' | 'sphere' | 'plane') => THREE.Mesh;
  generateScene: (complexity: 'simple' | 'medium' | 'complex') => THREE.Scene;
  generateTexture: (width: number, height: number) => THREE.Texture;
  generateMaterial: (type: 'basic' | 'standard' | 'physical') => THREE.Material;
}

// ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³æ‹¡å¼µ
declare global {
  namespace jest {
    interface Matchers<R> {
      toBeVisible(): R;
      toHavePosition(position: THREE.Vector3): R;
      toHaveRotation(rotation: THREE.Euler): R;
      toHaveScale(scale: THREE.Vector3): R;
      toBeInFrustum(camera: THREE.Camera): R;
      toRenderWithoutErrors(): Promise<R>;
      toMatchImage(reference: string, threshold?: number): Promise<R>;
      toHavePerformance(metrics: Partial<PerformanceMetrics>): R;
    }
  }
}
</file>

<file path="src/utils/EventEmitter.ts">
import { EventHandler } from '../types';

/**
 * ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¤ãƒ™ãƒ³ãƒˆã‚¨ãƒŸãƒƒã‚¿ãƒ¼å®Ÿè£…
 */
export class EventEmitter {
  private events: Map<string, EventHandler[]> = new Map();

  public on<T>(event: string, handler: EventHandler<T>): void {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(handler as EventHandler);
  }

  public off<T>(event: string, handler: EventHandler<T>): void {
    const handlers = this.events.get(event);
    if (handlers) {
      const index = handlers.indexOf(handler as EventHandler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  public emit<T>(event: string, data?: T): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Error in event handler for '${event}':`, error);
        }
      });
    }
  }

  public removeAllListeners(event?: string): void {
    if (event) {
      this.events.delete(event);
    } else {
      this.events.clear();
    }
  }

  public listenerCount(event: string): number {
    const handlers = this.events.get(event);
    return handlers ? handlers.length : 0;
  }

  public eventNames(): string[] {
    return Array.from(this.events.keys());
  }
}
</file>

<file path="src/.gitkeep">
# ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
</file>

<file path="three-test-suite/docs/design-philosophy.md">
# Three.js ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ è¨­è¨ˆæ€æƒ³ã¨ãƒ¡ãƒªãƒƒãƒˆ

## ğŸ“š ç›®æ¬¡
- [å•é¡Œã®èƒŒæ™¯](#å•é¡Œã®èƒŒæ™¯)
- [æŠ€è¡“çš„åˆ¶ç´„ã¨è§£æ±ºã®æµã‚Œ](#æŠ€è¡“çš„åˆ¶ç´„ã¨è§£æ±ºã®æµã‚Œ)
- [ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ä¾¡å€¤](#ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ä¾¡å€¤)
- [å…·ä½“çš„ãªãƒ¡ãƒªãƒƒãƒˆ](#å…·ä½“çš„ãªãƒ¡ãƒªãƒƒãƒˆ)
- [ä»–ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¨ã®æ¯”è¼ƒ](#ä»–ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¨ã®æ¯”è¼ƒ)
- [å®Ÿéš›ã®é–‹ç™ºä½“é¨“](#å®Ÿéš›ã®é–‹ç™ºä½“é¨“)

## å•é¡Œã®èƒŒæ™¯

Three.jsã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ãéš›ã«ç›´é¢ã™ã‚‹æ ¹æœ¬çš„ãªèª²é¡Œï¼š

### ğŸš« Node.jsç’°å¢ƒã§ã®åˆ¶ç´„
```javascript
// âŒ Node.jsç’°å¢ƒã§ã¯ä¸å¯èƒ½
import * as THREE from 'three';

test('ç«‹æ–¹ä½“ä½œæˆãƒ†ã‚¹ãƒˆ', () => {
  const scene = new THREE.Scene();  // ReferenceError: DOMç’°å¢ƒãŒãªã„
  const geometry = new THREE.BoxGeometry();  // WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒãªã„
});
```

**ãªãœå‹•ã‹ãªã„ã®ã‹ï¼š**
- Node.jsã«ã¯DOMãŒãªã„
- Canvasè¦ç´ ãŒå­˜åœ¨ã—ãªã„
- WebGLãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒãªã„
- `window`, `document` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãªã„

## æŠ€è¡“çš„åˆ¶ç´„ã¨è§£æ±ºã®æµã‚Œ

### æ®µéš1: æ ¹æœ¬å•é¡Œã®ç™ºè¦‹
```
Three.jsã®ãƒ†ã‚¹ãƒˆãŒå¿…è¦
    â†“
Node.jsç’°å¢ƒã§ã¯å‹•ä½œã—ãªã„
    â†“
ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒãŒå¿…è¦
```

### æ®µéš2: ç¬¬ä¸€ã®è§£æ±ºç­–ã¨ãã®é™ç•Œ
```
Puppeteerã§ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒã‚’æä¾›
    â†“
âœ… Three.jså‹•ä½œå¯èƒ½
    â†“
âŒ æ¯å›HTMLç’°å¢ƒæ§‹ç¯‰ãŒå¿…è¦
    â†“
æ–°ãŸãªèª²é¡Œï¼šHTMLä½œæˆã®ç…©é›‘ã•
```

### æ®µéš3: æœ€çµ‚è§£æ±ºç­–
```
HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆæ©Ÿèƒ½
    â†“
âœ… HTMLç’°å¢ƒè‡ªå‹•æ§‹ç¯‰
    â†“
âœ… ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ç°¡æ½”åŒ–
    â†“
âœ… é–‹ç™ºè€…ä½“é¨“å‘ä¸Š
```

## ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ä¾¡å€¤

### ğŸ¯ æ ¸å¿ƒçš„ä¾¡å€¤ï¼šæŠ½è±¡åŒ–ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æä¾›

å¾“æ¥ã®é–‹ç™ºãƒ•ãƒ­ãƒ¼ã§ã¯ã€é–‹ç™ºè€…ã¯ä»¥ä¸‹ã®ã™ã¹ã¦ã‚’ç®¡ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸï¼š

1. **ã‚¤ãƒ³ãƒ•ãƒ©å±¤**ï¼šPuppeteerãƒ–ãƒ©ã‚¦ã‚¶ç®¡ç†
2. **ç’°å¢ƒæ§‹ç¯‰å±¤**ï¼šHTML/CSS/JavaScriptç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
3. **ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå±¤**ï¼šThree.jsèª­ã¿è¾¼ã¿ã¨è¨­å®š
4. **ãƒ†ã‚¹ãƒˆå±¤**ï¼šå®Ÿéš›ã®ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯

**ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯1-3ã‚’è‡ªå‹•åŒ–ã—ã€é–‹ç™ºè€…ãŒ4ã«é›†ä¸­ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚**

### ğŸ”„ å•é¡Œè§£æ±ºã®é€£é–
```
æŠ€è¡“çš„åˆ¶ç´„ â†’ è§£æ±ºç­– â†’ æ–°ãŸãªèª²é¡Œ â†’ æœ€çµ‚è§£æ±º

Node.jsåˆ¶ç´„ â†’ Puppeteer â†’ HTMLç…©é›‘ â†’ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ
     â†“           â†“          â†“           â†“
  DOMä¸è¶³    ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒ   æ‰‹ä½œæ¥­å¤šã„    è‡ªå‹•åŒ–
```

## å…·ä½“çš„ãªãƒ¡ãƒªãƒƒãƒˆ

### 1. ğŸ§¹ ã‚³ãƒ¼ãƒ‰ã®ç°¡æ½”æ€§

#### Before: Puppeteerå˜ä½“
```javascript
test('ç«‹æ–¹ä½“ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ', async () => {
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--enable-webgl', '--disable-web-security']
  });
  
  const page = await browser.newPage();
  await page.setViewport({ width: 1024, height: 768 });
  
  await page.setContent(`
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Three.js Test</title>
      <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
      </style>
    </head>
    <body>
      <canvas id="three-canvas"></canvas>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
      <script>
        window.addEventListener('load', function() {
          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
          renderer.setSize(window.innerWidth, window.innerHeight);
          
          const geometry = new THREE.BoxGeometry();
          const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
          const cube = new THREE.Mesh(geometry, material);
          scene.add(cube);
          
          camera.position.z = 5;
          renderer.render(scene, camera);
          
          window.cubeRendered = true;
        });
      </script>
    </body>
    </html>
  `);
  
  await page.waitForFunction('window.cubeRendered', { timeout: 5000 });
  
  const isRendered = await page.evaluate(() => window.cubeRendered);
  expect(isRendered).toBe(true);
  
  await browser.close();
});
```
**è¡Œæ•°ï¼š45è¡Œã€è¤‡é›‘åº¦ï¼šé«˜**

#### After: ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
```javascript
test('ç«‹æ–¹ä½“ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    
    camera.position.z = 5;
    renderer.render(scene, camera);
    
    window.cubeRendered = true;
  });
  
  await manager.page.setContent(html);
  const isRendered = await manager.page.evaluate(() => window.cubeRendered);
  expect(isRendered).toBe(true);
  
  await manager.cleanup();
});
```
**è¡Œæ•°ï¼š23è¡Œã€è¤‡é›‘åº¦ï¼šä½**

### 2. ğŸ¨ é–‹ç™ºè€…ä½“é¨“ã®å‘ä¸Š

#### ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒ»è‡ªå‹•è£œå®Œ
```javascript
// âœ… IDEã®ãƒ•ãƒ«æ©Ÿèƒ½ãŒä½¿ãˆã‚‹
const html = manager.generateTestHTML(() => {
  const scene = new THREE.Scene();        // â† è‡ªå‹•è£œå®Œ
  const camera = new THREE.PerspectiveCamera(
    75,                                    // â† ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ’ãƒ³ãƒˆ
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  
  // å¤‰æ•°å‚ç…§ã€ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚‚æ­£å¸¸å‹•ä½œ
  scene.add(cube);  // â† IDEãŒå¤‰æ•°è¿½è·¡
});
```

#### ã‚¨ãƒ©ãƒ¼æ¤œå‡º
```javascript
// âœ… æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã‚’é–‹ç™ºæ™‚ã«æ¤œå‡º
const html = manager.generateTestHTML(() => {
  const scene = new THREE.Scene();
  scene.add(nonExistentVariable);  // â† IDEãŒè­¦å‘Šè¡¨ç¤º
});
```

### 3. ğŸ”§ è¨­å®šã®æŸ”è»Ÿæ€§

```javascript
// Three.jsãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®š
const html = manager.generateTestHTML(sceneCode, {
  threeJsVersion: 'r140'
});

// è‡ªå‹•å®Ÿè¡Œåˆ¶å¾¡
const html = manager.generateTestHTML(sceneCode, {
  autoExecute: false  // æ‰‹å‹•å®Ÿè¡Œå¯èƒ½
});

// ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«
const html = manager.generateTestHTML(sceneCode, {
  title: 'VR Environment Test'
});
```

### 4. ğŸ§ª ãƒ†ã‚¹ãƒˆã®å†åˆ©ç”¨æ€§

```javascript
// å…±é€šã‚·ãƒ¼ãƒ³ä½œæˆé–¢æ•°
function createBasicScene() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.position.z = 5;
  return { scene, camera, renderer };
}

// è¤‡æ•°ãƒ†ã‚¹ãƒˆã§å†åˆ©ç”¨
test('èµ¤ã„ç«‹æ–¹ä½“', async () => {
  const html = manager.generateTestHTML(() => {
    const { scene, camera, renderer } = createBasicScene();
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    scene.add(cube);
    renderer.render(scene, camera);
  });
});

test('é’ã„çƒä½“', async () => {
  const html = manager.generateTestHTML(() => {
    const { scene, camera, renderer } = createBasicScene();
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(),
      new THREE.MeshBasicMaterial({ color: 0x0000ff })
    );
    scene.add(sphere);
    renderer.render(scene, camera);
  });
});
```

### 5. ğŸ” ãƒ‡ãƒãƒƒã‚°ã®å®¹æ˜“ã•

```javascript
test('ãƒ‡ãƒãƒƒã‚°æƒ…å ±ä»˜ããƒ†ã‚¹ãƒˆ', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    // ... ã‚·ãƒ¼ãƒ³ä½œæˆ
    
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ç°¡å˜ã«å‡ºåŠ›
    window.debugInfo = {
      sceneChildren: scene.children.length,
      cameraPosition: camera.position,
      rendererInfo: renderer.info
    };
  });
  
  await manager.page.setContent(html);
  
  const debugInfo = await manager.page.evaluate(() => window.debugInfo);
  console.log('Debug info:', debugInfo);  // ãƒ†ã‚¹ãƒˆä¸­ã«ç¢ºèªå¯èƒ½
});
```

## ä»–ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¨ã®æ¯”è¼ƒ

### ğŸ“Š æ¯”è¼ƒè¡¨

| ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ | ã‚³ãƒ¼ãƒ‰é‡ | è¤‡é›‘åº¦ | IDEæ”¯æ´ | å†åˆ©ç”¨æ€§ | å­¦ç¿’ã‚³ã‚¹ãƒˆ |
|------------|----------|---------|---------|----------|------------|
| **ç´”ç²‹Puppeteer** | å¤šã„ | é«˜ã„ | âŒ | ä½ã„ | é«˜ã„ |
| **HTMLãƒ•ã‚¡ã‚¤ãƒ«åˆ†é›¢** | ä¸­ç¨‹åº¦ | ä¸­ç¨‹åº¦ | â–³ | ä¸­ç¨‹åº¦ | ä¸­ç¨‹åº¦ |
| **ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯** | å°‘ãªã„ | ä½ã„ | âœ… | é«˜ã„ | ä½ã„ |

### ğŸ›ï¸ HTMLãƒ•ã‚¡ã‚¤ãƒ«åˆ†é›¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¨ã®æ¯”è¼ƒ

#### HTMLãƒ•ã‚¡ã‚¤ãƒ«åˆ†é›¢æ–¹å¼
```html
<!-- test-scene.html -->
<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // å›ºå®šã•ã‚ŒãŸThree.jsã‚³ãƒ¼ãƒ‰
    const scene = new THREE.Scene();
    // ...
  </script>
</body>
</html>
```

```javascript
// ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«
test('ã‚·ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ', async () => {
  await page.goto('file:///path/to/test-scene.html');
  // ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯
});
```

**å•é¡Œç‚¹ï¼š**
- âŒ ãƒ†ã‚¹ãƒˆã”ã¨ã«ç•°ãªã‚‹HTMLãƒ•ã‚¡ã‚¤ãƒ«ãŒå¿…è¦
- âŒ JavaScriptã‚³ãƒ¼ãƒ‰ã¨ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ãŒåˆ†é›¢
- âŒ å‹•çš„ãªãƒ†ã‚¹ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ¸¡ã—ã«ãã„
- âŒ ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ãŒè¤‡é›‘

#### ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
```javascript
test('å‹•çš„ã‚·ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ', async () => {
  const testParams = { color: 0xff0000, size: 2 };
  
  const html = manager.generateTestHTML(() => {
    // ãƒ†ã‚¹ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‹•çš„ã«ä½¿ç”¨
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(testParams.size, testParams.size, testParams.size),
      new THREE.MeshBasicMaterial({ color: testParams.color })
    );
  });
});
```

**åˆ©ç‚¹ï¼š**
- âœ… 1ã¤ã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§å®Œçµ
- âœ… å‹•çš„ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ³¨å…¥å¯èƒ½
- âœ… ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯ã®å¯è¦–æ€§å‘ä¸Š

## å®Ÿéš›ã®é–‹ç™ºä½“é¨“

### ğŸš€ å­¦ç¿’æ›²ç·š

```
å¾“æ¥ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:
æ™‚é–“ â†’
   â†‘
ç¿’å¾—
ãƒ¬ãƒ™ãƒ«     ____
          /
         /
        /
_______/ 
HTMLä½œæˆ, Puppeteer, Three.js ã‚’å…¨ã¦åŒæ™‚ã«å­¦ç¿’

ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯:
æ™‚é–“ â†’
   â†‘        ______
ç¿’å¾—      /
ãƒ¬ãƒ™ãƒ«   /
        /
_______/
Three.jsã«é›†ä¸­ã—ã¦å­¦ç¿’å¯èƒ½
```

### ğŸ¯ é–‹ç™ºãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã®å¤‰åŒ–

#### Before: åˆ†æ•£ã—ãŸãƒ•ã‚©ãƒ¼ã‚«ã‚¹
```
é–‹ç™ºè€…ã®æ³¨æ„åŠ›é…åˆ†:
- 25% HTMLãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ
- 25% Puppeteerè¨­å®š
- 20% CSS/ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´
- 30% Three.jsãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯  â† æœ¬æ¥ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã™ã¹ãéƒ¨åˆ†
```

#### After: é›†ä¸­ã—ãŸãƒ•ã‚©ãƒ¼ã‚«ã‚¹
```
é–‹ç™ºè€…ã®æ³¨æ„åŠ›é…åˆ†:
- 5% ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯è¨­å®š
- 95% Three.jsãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯  â† æœ¬æ¥ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã™ã¹ãéƒ¨åˆ†
```

### âš¡ é–‹ç™ºé€Ÿåº¦ã®å‘ä¸Š

```javascript
// æ–°ã—ã„ãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ã™ã‚‹æ™‚é–“

// Before: 15-30åˆ†
// 1. HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ (5-10åˆ†)
// 2. CSSèª¿æ•´ (3-5åˆ†)
// 3. Three.jsç’°å¢ƒæ§‹ç¯‰ (5-10åˆ†)
// 4. ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯ä½œæˆ (2-5åˆ†)

// After: 2-5åˆ†  
// 1. ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯ä½œæˆã®ã¿ (2-5åˆ†)

// é–‹ç™ºé€Ÿåº¦: 3-6å€å‘ä¸Š
```

## å°†æ¥ã®æ‹¡å¼µæ€§

### ğŸ”® è¿½åŠ å¯èƒ½ãªæ©Ÿèƒ½

```javascript
// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ”¯æ´
const html = manager.generateTestHTML(() => {
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—è‡ªå‹•è¨­å®š
}, { 
  enableAnimation: true,
  animationDuration: 5000 
});

// è¿½åŠ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªè‡ªå‹•èª­ã¿è¾¼ã¿
const html = manager.generateTestHTML(() => {
  // OrbitControlsä½¿ç”¨å¯èƒ½
}, { 
  additionalLibraries: ['OrbitControls', 'GLTFLoader'] 
});

// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
const html = manager.generateTestHTML(() => {
  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±è‡ªå‹•åé›†
}, { 
  enablePerformanceMonitoring: true 
});
```

### ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®åˆ©ç‚¹

ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®è¨­è¨ˆã«ã‚ˆã‚Šã€å°†æ¥çš„ã«ä»¥ä¸‹ã®æ©Ÿèƒ½è¿½åŠ ãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ï¼š

1. **VR/ARç’°å¢ƒã®ã‚µãƒãƒ¼ãƒˆ**
2. **WebXR API ã®ãƒ†ã‚¹ãƒˆæ”¯æ´**
3. **GPUè¨ˆç®—ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½**
4. **3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆ**
5. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯**

## çµè«–

ã“ã®Three.jsãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯ã€å˜ãªã‚‹ã€Œä¾¿åˆ©ãƒ„ãƒ¼ãƒ«ã€ã§ã¯ãªãã€**Three.jsé–‹ç™ºã«ãŠã‘ã‚‹æœ¬è³ªçš„ãªèª²é¡Œã‚’è§£æ±ºã™ã‚‹è¨­è¨ˆæ€æƒ³**ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚

**æ ¸å¿ƒçš„ä¾¡å€¤ï¼š**
- æŠ€è¡“çš„åˆ¶ç´„ã®æŠ½è±¡åŒ–
- é–‹ç™ºè€…ä½“é¨“ã®å‘ä¸Š  
- ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯ã¸ã®é›†ä¸­
- ç”Ÿç”£æ€§ã®é£›èºçš„å‘ä¸Š

ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«ã‚ˆã‚Šã€é–‹ç™ºè€…ã¯Three.jsã®å­¦ç¿’ã¨ãƒ†ã‚¹ãƒˆä½œæˆã«é›†ä¸­ã§ãã€ã‚ˆã‚Šé«˜å“è³ªãª3Dã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åŠ¹ç‡çš„ã«é–‹ç™ºã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
</file>

<file path="three-test-suite/docs/quick-start.md">
# Three.js ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆã‚¬ã‚¤ãƒ‰

## ğŸš€ ã¯ã˜ã‚ã«

ã“ã®ã‚¬ã‚¤ãƒ‰ã§ã¯ã€Three.js ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®åŸºæœ¬çš„ãªä½¿ã„æ–¹ã‚’å­¦ã¹ã¾ã™ã€‚

## ğŸ“‹ å‰ææ¡ä»¶

- Node.js 18ä»¥ä¸Š
- npm ã¾ãŸã¯ yarn
- Three.js ã®åŸºæœ¬çŸ¥è­˜

## âš¡ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ

### 1. åŸºæœ¬çš„ãªãƒ†ã‚¹ãƒˆ

```javascript
import { PuppeteerManager } from '../src/PuppeteerManager.js';

test('æœ€åˆã®Three.jsãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    // ğŸ¯ ã“ã“ã« Three.js ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // ç«‹æ–¹ä½“ã‚’ä½œæˆ
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    
    camera.position.z = 5;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.render(scene, camera);
    
    // ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
    window.sceneReady = true;
  });
  
  await manager.page.setContent(html);
  
  // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
  const isReady = await manager.page.evaluate(() => window.sceneReady);
  expect(isReady).toBe(true);
  
  await manager.cleanup();
});
```

### 2. è¤‡æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ†ã‚¹ãƒˆ

```javascript
test('è¤‡æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¿½åŠ ãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // ç«‹æ–¹ä½“
    const cubeGeometry = new THREE.BoxGeometry();
    const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    cube.position.x = -2;
    scene.add(cube);
    
    // çƒä½“
    const sphereGeometry = new THREE.SphereGeometry();
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.x = 2;
    scene.add(sphere);
    
    camera.position.z = 5;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.render(scene, camera);
    
    // ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿
    window.testResults = {
      objectCount: scene.children.length,
      cubePosition: cube.position.x,
      spherePosition: sphere.position.x
    };
  });
  
  await manager.page.setContent(html);
  
  const results = await manager.page.evaluate(() => window.testResults);
  expect(results.objectCount).toBe(2);
  expect(results.cubePosition).toBe(-2);
  expect(results.spherePosition).toBe(2);
  
  await manager.cleanup();
});
```

### 3. ç•°ãªã‚‹Three.jsãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã®ãƒ†ã‚¹ãƒˆ

```javascript
test('Three.js r140 ã§ã®ãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    // r140ã®æ–°æ©Ÿèƒ½ã‚’ä½¿ç”¨
    const scene = new THREE.Scene();
    window.threeVersion = THREE.REVISION;
  }, {
    threeJsVersion: 'r140',
    title: 'Three.js r140 Test Environment'
  });
  
  await manager.page.setContent(html);
  
  const version = await manager.page.evaluate(() => window.threeVersion);
  expect(version).toBe(140);
  
  await manager.cleanup();
});
```

### 4. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆ

```javascript
test('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    
    camera.position.z = 5;
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    let frameCount = 0;
    function animate() {
      frameCount++;
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;
      
      renderer.render(scene, camera);
      
      if (frameCount < 10) {
        requestAnimationFrame(animate);
      } else {
        // 10ãƒ•ãƒ¬ãƒ¼ãƒ å¾Œã«ãƒ†ã‚¹ãƒˆå®Œäº†
        window.animationComplete = true;
        window.finalRotation = {
          x: cube.rotation.x,
          y: cube.rotation.y
        };
      }
    }
    
    animate();
  });
  
  await manager.page.setContent(html);
  
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã¾ã§å¾…æ©Ÿ
  await manager.page.waitForFunction('window.animationComplete', { timeout: 5000 });
  
  const rotation = await manager.page.evaluate(() => window.finalRotation);
  expect(rotation.x).toBeGreaterThan(0);
  expect(rotation.y).toBeGreaterThan(0);
  
  await manager.cleanup();
});
```

### 5. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãƒ†ã‚¹ãƒˆ

```javascript
test('WebGLéå¯¾å¿œç’°å¢ƒã§ã®å‹•ä½œ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    try {
      const canvas = document.getElementById('three-canvas');
      const context = canvas.getContext('webgl');
      
      if (!context) {
        throw new Error('WebGL not supported');
      }
      
      const scene = new THREE.Scene();
      window.webglSupported = true;
    } catch (error) {
      window.webglError = error.message;
      window.webglSupported = false;
    }
  });
  
  await manager.page.setContent(html);
  
  const isSupported = await manager.page.evaluate(() => window.webglSupported);
  expect(isSupported).toBe(true); // é€šå¸¸ã®ç’°å¢ƒã§ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹
  
  await manager.cleanup();
});
```

## ğŸ¨ é«˜åº¦ãªä½¿ç”¨ä¾‹

### ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ†ãƒªã‚¢ãƒ«ã®ãƒ†ã‚¹ãƒˆ

```javascript
test('ã‚«ã‚¹ã‚¿ãƒ ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // ã‚«ã‚¹ã‚¿ãƒ ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼
    const vertexShader = `
      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    
    const fragmentShader = `
      uniform float time;
      void main() {
        gl_FragColor = vec4(sin(time), cos(time), 0.5, 1.0);
      }
    `;
    
    const material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 1.0 }
      },
      vertexShader: vertexShader,
      fragmentShader: fragmentShader
    });
    
    const geometry = new THREE.PlaneGeometry(2, 2);
    const plane = new THREE.Mesh(geometry, material);
    scene.add(plane);
    
    camera.position.z = 3;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.render(scene, camera);
    
    window.shaderTest = {
      materialType: material.type,
      uniformsCount: Object.keys(material.uniforms).length
    };
  });
  
  await manager.page.setContent(html);
  
  const result = await manager.page.evaluate(() => window.shaderTest);
  expect(result.materialType).toBe('ShaderMaterial');
  expect(result.uniformsCount).toBe(1);
  
  await manager.cleanup();
});
```

### 3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã®ãƒ†ã‚¹ãƒˆï¼ˆãƒ¢ãƒƒã‚¯ï¼‰

```javascript
test('3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // GLTFãƒ­ãƒ¼ãƒ€ãƒ¼ã®ãƒ¢ãƒƒã‚¯ï¼ˆå®Ÿéš›ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ã®ä»£ã‚ã‚Šï¼‰
    function loadModel() {
      return new Promise((resolve) => {
        setTimeout(() => {
          // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
          const geometry = new THREE.BoxGeometry();
          const material = new THREE.MeshBasicMaterial({ color: 0x888888 });
          const model = new THREE.Mesh(geometry, material);
          resolve(model);
        }, 100);
      });
    }
    
    loadModel().then((model) => {
      scene.add(model);
      camera.position.z = 5;
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.render(scene, camera);
      
      window.modelLoaded = {
        success: true,
        objectCount: scene.children.length,
        modelType: model.type
      };
    });
  });
  
  await manager.page.setContent(html);
  
  // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ã¾ã§å¾…æ©Ÿ
  await manager.page.waitForFunction('window.modelLoaded', { timeout: 5000 });
  
  const result = await manager.page.evaluate(() => window.modelLoaded);
  expect(result.success).toBe(true);
  expect(result.objectCount).toBe(1);
  expect(result.modelType).toBe('Mesh');
  
  await manager.cleanup();
});
```

## ğŸ› ï¸ ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. ãƒ†ã‚¹ãƒˆã®æ§‹é€ åŒ–

```javascript
describe('Three.js åŸºæœ¬æ©Ÿèƒ½', () => {
  let manager;
  
  beforeEach(async () => {
    manager = new PuppeteerManager();
    await manager.initialize();
  });
  
  afterEach(async () => {
    await manager.cleanup();
  });
  
  test('ã‚·ãƒ¼ãƒ³ä½œæˆ', async () => {
    // ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯
  });
  
  test('ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½åŠ ', async () => {
    // ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯
  });
});
```

### 2. å…±é€šã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°

```javascript
// ãƒ†ã‚¹ãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼
function createBasicScene() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
  
  camera.position.z = 5;
  renderer.setSize(window.innerWidth, window.innerHeight);
  
  return { scene, camera, renderer };
}

function createTestCube(color = 0x00ff00) {
  const geometry = new THREE.BoxGeometry();
  const material = new THREE.MeshBasicMaterial({ color });
  return new THREE.Mesh(geometry, material);
}

// ä½¿ç”¨ä¾‹
test('ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã‚’ä½¿ã£ãŸãƒ†ã‚¹ãƒˆ', async () => {
  const html = manager.generateTestHTML(() => {
    const { scene, camera, renderer } = createBasicScene();
    const cube = createTestCube(0xff0000);
    
    scene.add(cube);
    renderer.render(scene, camera);
    
    window.testComplete = true;
  });
  
  await manager.page.setContent(html);
  // ãƒ†ã‚¹ãƒˆç¶šè¡Œ...
});
```

### 3. éåŒæœŸå‡¦ç†ã®ãƒ†ã‚¹ãƒˆ

```javascript
test('éåŒæœŸã‚·ãƒ¼ãƒ³æ§‹ç¯‰', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // éåŒæœŸã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
    Promise.resolve().then(() => {
      const cube = new THREE.Mesh(
        new THREE.BoxGeometry(),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
      );
      scene.add(cube);
      
      camera.position.z = 5;
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.render(scene, camera);
      
      window.asyncComplete = {
        objectCount: scene.children.length,
        timestamp: Date.now()
      };
    });
  });
  
  await manager.page.setContent(html);
  
  // éåŒæœŸå‡¦ç†å®Œäº†ã¾ã§å¾…æ©Ÿ
  await manager.page.waitForFunction('window.asyncComplete', { timeout: 5000 });
  
  const result = await manager.page.evaluate(() => window.asyncComplete);
  expect(result.objectCount).toBe(1);
  expect(result.timestamp).toBeGreaterThan(0);
});
```

### 4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

```javascript
test('ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // å¤šæ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
    const objectCount = 100;
    const startTime = performance.now();
    
    for (let i = 0; i < objectCount; i++) {
      const geometry = new THREE.BoxGeometry();
      const material = new THREE.MeshBasicMaterial({ 
        color: Math.random() * 0xffffff 
      });
      const cube = new THREE.Mesh(geometry, material);
      
      cube.position.x = (Math.random() - 0.5) * 10;
      cube.position.y = (Math.random() - 0.5) * 10;
      cube.position.z = (Math.random() - 0.5) * 10;
      
      scene.add(cube);
    }
    
    const creationTime = performance.now() - startTime;
    
    camera.position.z = 15;
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const renderStartTime = performance.now();
    renderer.render(scene, camera);
    const renderTime = performance.now() - renderStartTime;
    
    window.performanceResults = {
      objectCount,
      creationTime,
      renderTime,
      totalTime: creationTime + renderTime
    };
  });
  
  await manager.page.setContent(html);
  
  const results = await manager.page.evaluate(() => window.performanceResults);
  
  expect(results.objectCount).toBe(100);
  expect(results.creationTime).toBeLessThan(1000); // 1ç§’ä»¥å†…
  expect(results.renderTime).toBeLessThan(100);    // 100msä»¥å†…
  
  console.log('Performance Results:', results);
});
```

## ğŸš¨ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ³•

#### 1. Three.js ãŒèª­ã¿è¾¼ã¾ã‚Œãªã„

```javascript
test('Three.jsèª­ã¿è¾¼ã¿ç¢ºèª', async () => {
  const html = manager.generateTestHTML(() => {
    // Three.jsãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
    if (typeof THREE === 'undefined') {
      window.threeError = 'THREE is not defined';
      return;
    }
    
    window.threeLoaded = true;
    window.threeVersion = THREE.REVISION;
  });
  
  await manager.page.setContent(html);
  
  // Three.jsèª­ã¿è¾¼ã¿å®Œäº†ã¾ã§å¾…æ©Ÿ
  await manager.page.waitForFunction(
    'typeof THREE !== "undefined"', 
    { timeout: 10000 }
  );
  
  const isLoaded = await manager.page.evaluate(() => window.threeLoaded);
  expect(isLoaded).toBe(true);
});
```

#### 2. WebGL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼

```javascript
test('WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç¢ºèª', async () => {
  const html = manager.generateTestHTML(() => {
    const canvas = document.getElementById('three-canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    window.webglInfo = {
      supported: !!gl,
      vendor: gl ? gl.getParameter(gl.VENDOR) : null,
      renderer: gl ? gl.getParameter(gl.RENDERER) : null
    };
  });
  
  await manager.page.setContent(html);
  
  const webglInfo = await manager.page.evaluate(() => window.webglInfo);
  
  if (!webglInfo.supported) {
    console.warn('WebGL not supported in test environment');
  }
  
  expect(webglInfo.supported).toBe(true);
});
```

#### 3. ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼

```javascript
test('ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¯¾ç­–', async () => {
  const html = manager.generateTestHTML(() => {
    // é‡ã„å‡¦ç†ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    setTimeout(() => {
      const scene = new THREE.Scene();
      // ... ã‚·ãƒ¼ãƒ³æ§‹ç¯‰
      window.heavyProcessComplete = true;
    }, 2000); // 2ç§’å¾Œã«å®Œäº†
  });
  
  await manager.page.setContent(html);
  
  // ååˆ†ãªå¾…æ©Ÿæ™‚é–“ã‚’è¨­å®š
  await manager.page.waitForFunction(
    'window.heavyProcessComplete', 
    { timeout: 5000 }  // 5ç§’ã¾ã§å¾…æ©Ÿ
  );
  
  const isComplete = await manager.page.evaluate(() => window.heavyProcessComplete);
  expect(isComplete).toBe(true);
});
```

## ğŸ”— é–¢é€£ãƒªã‚½ãƒ¼ã‚¹

- [Three.js å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://threejs.org/docs/)
- [Puppeteer å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://pptr.dev/)
- [Jest ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯](https://jestjs.io/)
- [WebGL ä»•æ§˜](https://www.khronos.org/webgl/)

## ğŸ“ ã‚µãƒãƒ¼ãƒˆ

å•é¡ŒãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š

1. Node.js ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒ18ä»¥ä¸Šã‹
2. PuppeteerãŒæ­£å¸¸ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã‹
3. WebGLå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ãŒåˆ©ç”¨å¯èƒ½ã‹

ã•ã‚‰ãªã‚‹ã‚µãƒãƒ¼ãƒˆãŒå¿…è¦ãªå ´åˆã¯ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®Issueã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
</file>

<file path="three-test-suite/README.md">
# Three.js ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯

**Three.jsã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãŸã‚ã®åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³**

[![Tests](https://github.com/usaganikki/Web3DExplorer/actions/workflows/test.yml/badge.svg)](https://github.com/usaganikki/Web3DExplorer/actions/workflows/test.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## ğŸ¯ æ¦‚è¦

ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯ã€Three.jsã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆã‚’åŠ‡çš„ã«ç°¡å˜ã«ã—ã¾ã™ã€‚Node.jsç’°å¢ƒã§ã®DOMä¸è¶³ã‚„WebGLéå¯¾å¿œã¨ã„ã£ãŸæŠ€è¡“çš„åˆ¶ç´„ã‚’è§£æ±ºã—ã€é–‹ç™ºè€…ãŒThree.jsã®ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯ã«é›†ä¸­ã§ãã‚‹ç’°å¢ƒã‚’æä¾›ã—ã¾ã™ã€‚

### ğŸš¨ è§£æ±ºã™ã‚‹å•é¡Œ

```javascript
// âŒ Node.jsç’°å¢ƒã§ã¯ä¸å¯èƒ½
import * as THREE from 'three';
test('Three.js test', () => {
  const scene = new THREE.Scene();  // ReferenceError: DOMç’°å¢ƒãªã—
});

// âœ… ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§å¯èƒ½
test('Three.js test', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();  // æ­£å¸¸å‹•ä½œï¼
  });
});
```

## ğŸš€ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ

### ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
cd three-test-suite
npm install
```

### åŸºæœ¬çš„ãªä½¿ç”¨æ³•

```javascript
import { PuppeteerManager } from './src/PuppeteerManager.js';

test('æœ€åˆã®Three.jsãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    // ğŸ¯ Three.jsã‚³ãƒ¼ãƒ‰ã‚’ã“ã“ã«æ›¸ã
    const scene = new THREE.Scene();
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    scene.add(cube);
    
    // ãƒ†ã‚¹ãƒˆç”¨ã®å€¤ã‚’è¨­å®š
    window.cubeCreated = true;
  });
  
  await manager.page.setContent(html);
  
  const result = await manager.page.evaluate(() => window.cubeCreated);
  expect(result).toBe(true);
  
  await manager.cleanup();
});
```

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ã‚³ã‚¢æ©Ÿèƒ½

```
PuppeteerManager
â”œâ”€â”€ initialize()           # ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒã®åˆæœŸåŒ–
â”œâ”€â”€ generateTestHTML()     # HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ
â”œâ”€â”€ getWebGLInfo()        # WebGLç’°å¢ƒæƒ…å ±å–å¾—
â””â”€â”€ cleanup()             # ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
```

### ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆã®ä»•çµ„ã¿

```javascript
// å†…éƒ¨çš„ãªå‡¦ç†ãƒ•ãƒ­ãƒ¼
generateTestHTML(userScript, options) {
  // 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’æ–‡å­—åˆ—åŒ–
  const scriptString = userScript.toString();
  
  // 2. HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«åŸ‹ã‚è¾¼ã¿
  return `
    <!DOCTYPE html>
    <html>
      <head>
        <script src="Three.js CDN"></script>
      </head>
      <body>
        <canvas id="three-canvas"></canvas>
        <script>
          window.addEventListener('load', () => {
            (${scriptString})();  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
          });
        </script>
      </body>
    </html>
  `;
}
```

## ğŸ“Š å¾“æ¥æ‰‹æ³•ã¨ã®æ¯”è¼ƒ

| ç‰¹å¾´ | å¾“æ¥ã®Puppeteer | ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ | æ”¹å–„åº¦ |
|------|----------------|------------------|--------|
| **ã‚³ãƒ¼ãƒ‰é‡** | 45è¡Œ+ | 23è¡Œ | 48%å‰Šæ¸› |
| **è¤‡é›‘åº¦** | é«˜ã„ | ä½ã„ | å¤§å¹…æ”¹å–„ |
| **IDEæ”¯æ´** | âŒ æ–‡å­—åˆ—å†…JS | âœ… ãƒ•ãƒ«æ©Ÿèƒ½ | å®Œå…¨å¯¾å¿œ |
| **å†åˆ©ç”¨æ€§** | ä½ã„ | é«˜ã„ | å¤§å¹…å‘ä¸Š |
| **å­¦ç¿’ã‚³ã‚¹ãƒˆ** | é«˜ã„ | ä½ã„ | å¤§å¹…è»½æ¸› |

### Before: å¾“æ¥ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
```javascript
test('Three.js test', async () => {
  // ğŸ˜° æ¯å›45è¡Œã®HTMLãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆ
  await page.setContent(`
    <!DOCTYPE html>
    <html>
      <head>
        <script src="https://three.js..."></script>
        <style>/* CSS */</style>
      </head>
      <body>
        <canvas></canvas>
        <script>
          // ğŸ˜¢ æ–‡å­—åˆ—å†…ã®JavaScriptï¼ˆIDEæ”¯æ´ãªã—ï¼‰
          const scene = new THREE.Scene();
          // ... è¤‡é›‘ãªæ–‡å­—åˆ—ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        </script>
      </body>
    </html>
  `);
});
```

### After: ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
```javascript
test('Three.js test', async () => {
  // ğŸ˜ 23è¡Œã«çŸ­ç¸®ã€IDEæ”¯æ´ãƒ•ãƒ«æ´»ç”¨
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();  // è‡ªå‹•è£œå®Œã€ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    // ... æ™®é€šã®JavaScriptã¨ã—ã¦è¨˜è¿°
  });
  
  await manager.page.setContent(html);
});
```

## ğŸ¨ é«˜åº¦ãªæ©Ÿèƒ½

### è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³

```javascript
const html = manager.generateTestHTML(userScript, {
  title: 'ã‚«ã‚¹ã‚¿ãƒ ãƒ†ã‚¹ãƒˆãƒšãƒ¼ã‚¸',
  threeJsVersion: 'r140',      // Three.jsãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®š
  autoExecute: false           // æ‰‹å‹•å®Ÿè¡Œåˆ¶å¾¡
});
```

### WebGLç’°å¢ƒæƒ…å ±ã®å–å¾—

```javascript
const webglInfo = await manager.getWebGLInfo();
console.log(webglInfo);
// {
//   webglSupported: true,
//   webgl2Supported: true,
//   vendor: "Google Inc.",
//   renderer: "Chrome",
//   version: "WebGL 1.0"
// }
```

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```javascript
// ç„¡åŠ¹ãªå¼•æ•°ã®æ¤œå‡º
expect(() => {
  manager.generateTestHTML('not a function');
}).toThrow('userScript must be a function');

// åˆæœŸåŒ–ãƒã‚§ãƒƒã‚¯
await expect(
  manager.getWebGLInfo()  // åˆæœŸåŒ–å‰
).rejects.toThrow('PuppeteerManager is not initialized');
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆä¾‹

### åŸºæœ¬çš„ãªã‚·ãƒ¼ãƒ³ä½œæˆ

```javascript
test('åŸºæœ¬ã‚·ãƒ¼ãƒ³ä½œæˆ', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    window.sceneInfo = {
      childrenCount: scene.children.length,
      cameraFov: camera.fov,
      rendererType: renderer.type
    };
  });
  
  await manager.page.setContent(html);
  
  const info = await manager.page.evaluate(() => window.sceneInfo);
  expect(info.childrenCount).toBe(0);
  expect(info.cameraFov).toBe(75);
  expect(info.rendererType).toBe('WebGLRenderer');
});
```

### ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ

```javascript
test('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    scene.add(cube);
    
    let frameCount = 0;
    function animate() {
      frameCount++;
      cube.rotation.x += 0.01;
      
      if (frameCount >= 10) {
        window.animationResult = {
          frames: frameCount,
          rotation: cube.rotation.x
        };
        return;
      }
      
      requestAnimationFrame(animate);
    }
    
    animate();
  });
  
  await manager.page.setContent(html);
  await manager.page.waitForFunction('window.animationResult');
  
  const result = await manager.page.evaluate(() => window.animationResult);
  expect(result.frames).toBe(10);
  expect(result.rotation).toBeCloseTo(0.1, 2);
});
```

### ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ†ãƒªã‚¢ãƒ«

```javascript
test('ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«', async () => {
  const html = manager.generateTestHTML(() => {
    const material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 1.0 },
        color: { value: new THREE.Color(0xff0000) }
      },
      vertexShader: `
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 color;
        void main() {
          gl_FragColor = vec4(color * sin(time), 1.0);
        }
      `
    });
    
    window.shaderInfo = {
      type: material.type,
      uniformCount: Object.keys(material.uniforms).length,
      hasVertexShader: !!material.vertexShader,
      hasFragmentShader: !!material.fragmentShader
    };
  });
  
  await manager.page.setContent(html);
  
  const info = await manager.page.evaluate(() => window.shaderInfo);
  expect(info.type).toBe('ShaderMaterial');
  expect(info.uniformCount).toBe(2);
  expect(info.hasVertexShader).toBe(true);
  expect(info.hasFragmentShader).toBe(true);
});
```

## ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

```
three-test-suite/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ PuppeteerManager.js    # ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
â”œâ”€â”€ __tests__/
â”‚   â””â”€â”€ PuppeteerManager.test.js # ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ design-philosophy.md   # è¨­è¨ˆæ€æƒ³ãƒ»ãƒ¡ãƒªãƒƒãƒˆ
â”‚   â”œâ”€â”€ quick-start.md        # ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆã‚¬ã‚¤ãƒ‰
â”‚   â””â”€â”€ README.md             # ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«
â”œâ”€â”€ package.json
â””â”€â”€ package-lock.json
```

## ğŸ”§ é–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆ

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```bash
# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm test

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«
npm test -- PuppeteerManager.test.js

# ã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰
npm run test:watch

# ã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ã
npm run test:coverage
```

### é–‹ç™ºæ™‚ã®ãƒ’ãƒ³ãƒˆ

```javascript
// ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶è¡¨ç¤ºï¼‰
const manager = new PuppeteerManager({ headless: false });

// ã‚«ã‚¹ã‚¿ãƒ è¨­å®š
const manager = new PuppeteerManager({
  width: 1920,
  height: 1080,
  args: ['--enable-webgl2']  // WebGL2å¼·åˆ¶æœ‰åŠ¹åŒ–
});
```

## ğŸ¯ è¨­è¨ˆæ€æƒ³

### å•é¡Œè§£æ±ºã®æµã‚Œ

```
1. Node.jsç’°å¢ƒåˆ¶ç´„
   âŒ DOMãƒ»Canvasãƒ»WebGLä¸è¶³
   â†“
2. Puppeteerã§è§£æ±º
   âœ… ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒæä¾›
   âŒ HTMLä½œæˆã®ç…©é›‘ã•
   â†“
3. ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆã§è§£æ±º
   âœ… HTMLè‡ªå‹•ç”Ÿæˆ
   âœ… é–‹ç™ºè€…ä½“é¨“å‘ä¸Š
```

### æ ¸å¿ƒçš„ä¾¡å€¤

- **æŠ½è±¡åŒ–**: æŠ€è¡“çš„åˆ¶ç´„ã‚’éš è”½
- **é›†ä¸­**: Three.jsãƒ­ã‚¸ãƒƒã‚¯ã«ç‰¹åŒ–
- **ç”Ÿç”£æ€§**: é–‹ç™ºé€Ÿåº¦3-6å€å‘ä¸Š
- **å“è³ª**: IDEæ”¯æ´ã§ã‚¨ãƒ©ãƒ¼å‰Šæ¸›

è©³ç´°ã¯ [`docs/design-philosophy.md`](./docs/design-philosophy.md) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## ğŸš€ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹

### ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯çµæœ

```
ãƒ†ã‚¹ãƒˆä½œæˆæ™‚é–“ã®æ¯”è¼ƒ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ‰‹æ³•            â”‚ å¾“æ¥æ‰‹æ³• â”‚ ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯  â”‚ æ”¹å–„ç‡  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ åˆå›ãƒ†ã‚¹ãƒˆä½œæˆ  â”‚ 15-30åˆ†  â”‚ 2-5åˆ†          â”‚ 83%çŸ­ç¸® â”‚
â”‚ è¿½åŠ ãƒ†ã‚¹ãƒˆä½œæˆ  â”‚ 10-15åˆ†  â”‚ 1-3åˆ†          â”‚ 80%çŸ­ç¸® â”‚
â”‚ ãƒ†ã‚¹ãƒˆä¿®æ­£      â”‚ 5-10åˆ†   â”‚ 1-2åˆ†          â”‚ 75%çŸ­ç¸® â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ã‚³ãƒ¼ãƒ‰é‡ã®æ¯”è¼ƒ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ—    â”‚ å¾“æ¥æ‰‹æ³• â”‚ ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯  â”‚ å‰Šæ¸›ç‡  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ åŸºæœ¬ã‚·ãƒ¼ãƒ³      â”‚ 45è¡Œ     â”‚ 23è¡Œ           â”‚ 48%å‰Šæ¸› â”‚
â”‚ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³  â”‚ 60è¡Œ     â”‚ 30è¡Œ           â”‚ 50%å‰Šæ¸› â”‚
â”‚ ã‚«ã‚¹ã‚¿ãƒ æ©Ÿèƒ½    â”‚ 80è¡Œ     â”‚ 35è¡Œ           â”‚ 56%å‰Šæ¸› â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”® ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

### Phase 1: åŸºç›¤æ©Ÿèƒ½ âœ…
- [x] PuppeteerManageråŸºç›¤
- [x] WebGLæœ‰åŠ¹åŒ–
- [x] HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ

### Phase 2: æ‹¡å¼µæ©Ÿèƒ½ ğŸš§
- [ ] Three.jsã‚·ãƒ¼ãƒ³æ³¨å…¥
- [ ] ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ”¯æ´
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š

### Phase 3: é«˜åº¦æ©Ÿèƒ½ ğŸ“‹
- [ ] VR/ARç’°å¢ƒã‚µãƒãƒ¼ãƒˆ
- [ ] WebXR API ãƒ†ã‚¹ãƒˆ
- [ ] 3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æ”¯æ´
- [ ] GPUè¨ˆç®—ãƒ†ã‚¹ãƒˆ

### Phase 4: ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ  ğŸ’­
- [ ] ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ 
- [ ] TypeScriptå¯¾å¿œ
- [ ] CI/CDçµ±åˆ
- [ ] ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«å›å¸°ãƒ†ã‚¹ãƒˆ

## ğŸ¤ ã‚³ãƒ³ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³

### é–‹ç™ºã«å‚åŠ ã™ã‚‹

```bash
# ãƒªãƒã‚¸ãƒˆãƒªã‚¯ãƒ­ãƒ¼ãƒ³
git clone https://github.com/usaganikki/Web3DExplorer.git
cd Web3DExplorer/three-test-suite

# ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install

# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm test

# é–‹ç™ºãƒ–ãƒ©ãƒ³ãƒä½œæˆ
git checkout -b feature/your-feature
```

### Issueå ±å‘Š

ä»¥ä¸‹ã®æƒ…å ±ã‚’å«ã‚ã¦Issueã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼š

- ç’°å¢ƒæƒ…å ±ï¼ˆNode.jsã€OSã€ãƒ–ãƒ©ã‚¦ã‚¶ï¼‰
- å†ç¾æ‰‹é †
- æœŸå¾…ã™ã‚‹å‹•ä½œ
- å®Ÿéš›ã®å‹•ä½œ
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

## ğŸ“„ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹

MIT License - è©³ç´°ã¯ [LICENSE](../LICENSE) ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## ğŸ™ è¬è¾

- [Three.js](https://threejs.org/) - ç´ æ™´ã‚‰ã—ã„3Dãƒ©ã‚¤ãƒ–ãƒ©ãƒª
- [Puppeteer](https://pptr.dev/) - ãƒ–ãƒ©ã‚¦ã‚¶è‡ªå‹•åŒ–ãƒ„ãƒ¼ãƒ«
- [Jest](https://jestjs.io/) - ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯

## ğŸ“ ã‚µãƒãƒ¼ãƒˆ

- ğŸ“§ Email: [GitHubãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«](https://github.com/usaganikki)
- ğŸ› Issues: [GitHub Issues](https://github.com/usaganikki/Web3DExplorer/issues)
- ğŸ“– Documentation: [`docs/`](./docs/) ãƒ•ã‚©ãƒ«ãƒ€

---

**Three.jsãƒ†ã‚¹ãƒˆã®æ–°ã—ã„æ¨™æº–ã‚’ä¸€ç·’ã«ä½œã‚Šã¾ã—ã‚‡ã†ï¼** ğŸš€
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# nyc test coverage
.nyc_output

# Dependency directories
jspm_packages/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.local
.env.development.local
.env.test.local
.env.production.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Build outputs
dist/
build/
lib/
out/

# Logs
logs
*.log

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Test artifacts
__tests__/screenshots/
__tests__/videos/
test-results/

# Temporary files
*.tmp
*.temp

# Package manager lock files (keep package-lock.json but ignore others)
yarn.lock
pnpm-lock.yaml

# Local environment files
.env.local
.env.development.local
.env.test.local
.env.production.local

# Storybook build outputs
storybook-static

# Rush temporary files
common/deploy/
common/temp/
common/autoinstallers/*/.npmrc
**/.rush/temp/

# MacOS
.AppleDouble
.LSOverride

# Windows
Desktop.ini
$RECYCLE.BIN/
*.cab
*.msi
*.msm
*.msp
*.lnk
</file>

<file path=".prettierrc">
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2
}
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- TypeScript migration with comprehensive type definitions
- React Three Fiber integration
- GIS coordinate transformation system
- Tokyo Station area 3D visualization
- Performance monitoring and metrics
- Comprehensive testing framework with Three.js utilities
- Event-driven architecture
- Modern build system with Vite

## [0.1.0] - 2025-06-01

### Added
- âœ¨ **TypeScript First Implementation**
  - Complete type safety with comprehensive type definitions
  - Strict TypeScript configuration with modern ES modules
  - Full IntelliSense support for Three.js objects

- âœ¨ **Core 3D Engine**
  - `Explorer` class for managing 3D scenes, cameras, and renderers
  - Object lifecycle management with configuration support
  - Performance metrics tracking and optimization
  - Event system for interaction handling

- âœ¨ **React Integration**
  - `Web3DExplorerComponent` for seamless React integration
  - React Three Fiber compatibility
  - TypeScript-safe React hooks and components
  - Performance monitoring with React state integration

- âœ¨ **GIS Integration**
  - `GISManager` for geographic data handling
  - Tokyo projection system for accurate coordinate transformation
  - Support for terrain, buildings, roads, and POI data
  - Automatic 3D object generation from GIS data

- âœ¨ **Tokyo Station Explorer**
  - Specialized component for Tokyo Station area visualization
  - Real-world geographic data integration
  - Interactive 3D building and infrastructure models
  - Loading progress and error handling

- âœ¨ **Testing Framework**
  - `ThreeTestUtils` for testing Three.js applications
  - Custom Jest matchers for 3D objects, materials, and geometries
  - Mock scene and object generators
  - Visual regression testing support
  - Performance testing utilities

- âœ¨ **Modern Development Environment**
  - Vite build system with TypeScript support
  - ESLint configuration for TypeScript and React
  - Jest testing setup with TypeScript integration
  - Prettier code formatting
  - GitHub Actions ready configuration

- âœ¨ **Documentation and Examples**
  - Comprehensive README with usage examples
  - TypeScript API documentation
  - React integration examples
  - Vanilla JavaScript examples
  - GIS data loading examples

### Technical Details

#### Type System
- **Core Types**: `Web3DExplorer`, `PerformanceMetrics`, `Object3DConfig`
- **GIS Types**: `GeoCoordinates`, `BuildingData`, `TerrainData`, `ProjectionSystem`
- **Testing Types**: `TestScenario`, `VisualTest`, `PerformanceTest`, `ThreeTestUtils`
- **React Types**: Full component prop typing with event handlers

#### Architecture
- **Event-Driven**: Built-in event system for object interactions and performance monitoring
- **Modular Design**: Separate core engine, GIS functionality, and React components
- **Plugin System**: Extensible architecture for custom functionality
- **Performance-First**: Built-in optimization and monitoring tools

#### Browser Support
- **Modern Browsers**: Chrome 90+, Firefox 88+, Safari 14+, Edge 90+
- **WebGL**: Requires WebGL 1.0 support (WebGL 2.0 recommended)
- **ES Modules**: Native ES module support required
- **TypeScript**: Full TypeScript 5.0+ compatibility

#### Dependencies
- **Three.js**: 0.163.0+ (peer dependency)
- **React**: 18.2.0+ (optional, for React components)
- **React Three Fiber**: 8.16.0+ (optional, for advanced React integration)

### Migration Notes

This release represents a complete TypeScript migration from the previous JavaScript codebase:

1. **Type Safety**: All APIs now have comprehensive type definitions
2. **Better IntelliSense**: IDEs provide complete autocompletion for Three.js objects
3. **Runtime Error Prevention**: TypeScript catches many errors at compile time
4. **Improved Documentation**: Types serve as inline documentation
5. **Better Refactoring**: Safe refactoring with TypeScript's type checking

### Breaking Changes

- **Minimum Node.js Version**: Requires Node.js 16.0+
- **Build System**: Now uses Vite instead of Webpack
- **Module System**: Fully converted to ES modules
- **API Changes**: Some method signatures updated for better type safety
- **Testing**: New testing utilities replace previous testing approach

### Performance Improvements

- **Bundle Size**: Optimized build with tree-shaking support
- **Runtime Performance**: Better memory management and object disposal
- **Development Experience**: Faster development builds with Vite
- **Type Checking**: Incremental TypeScript compilation

### Known Issues

- **WebGL Context Loss**: Automatic recovery not yet implemented
- **Memory Leaks**: Some edge cases in object disposal need attention
- **Mobile Performance**: Touch controls need optimization for mobile devices
- **Safari Compatibility**: Some WebGL extensions may not be available

### Future Roadmap

- **WebXR Support**: VR/AR integration planned for v0.2.0
- **WebGL 2.0**: Enhanced renderer features for supported browsers
- **Advanced GIS**: Integration with popular GIS data sources
- **Performance**: Further optimization for large-scale scenes
- **Accessibility**: Improved accessibility features for 3D content

---

## Development

### Version 0.1.0 Development Timeline

- **2025-06-01**: Initial TypeScript migration planning
- **2025-06-01**: Core type definitions implemented
- **2025-06-01**: Explorer class TypeScript conversion
- **2025-06-01**: React components with TypeScript
- **2025-06-01**: GIS integration and Tokyo projection
- **2025-06-01**: Testing framework implementation
- **2025-06-01**: Documentation and examples
- **2025-06-01**: v0.1.0 release

### Contributors

- **usaganikki** - Initial TypeScript migration and core development

### Acknowledgments

- **Three.js Community** - For the excellent 3D library
- **React Three Fiber Team** - For React integration inspiration
- **TypeScript Team** - For the powerful type system
- **Vite Team** - For the fast build tool
</file>

<file path="jest.setup.js">
// Jest setup file
// Three.jsã®ãƒ¢ãƒƒã‚¯è¨­å®šãªã©ã‚’ã“ã“ã«è¿½åŠ 
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 usaganikki

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWE.
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';
import path from 'path';
import typescript from '@rollup/plugin-typescript'; // Rollupã®TypeScriptãƒ—ãƒ©ã‚°ã‚¤ãƒ³

export default defineConfig({
  build: {
    lib: {
      entry: path.resolve(__dirname, 'src/index.ts'),
      name: 'Web3DExplorer',
      fileName: (format) => `web3d-explorer.${format}.js`,
      formats: ['es', 'umd', 'cjs'], // CommonJSãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚‚è¿½åŠ 
    },
    rollupOptions: {
      external: ['three', 'react', 'react-dom', '@react-three/fiber'],
      output: {
        globals: {
          three: 'THREE',
          react: 'React',
          'react-dom': 'ReactDOM',
          '@react-three/fiber': 'ReactThreeFiber',
        },
        // ESãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ 'exports: "named"' ã‚’æŒ‡å®šã™ã‚‹ã¨è­¦å‘Šã‚’å›é¿ã§ãã‚‹å ´åˆãŒã‚ã‚‹
        exports: 'named',
      },
      plugins: [
        typescript({ // tsconfig.json ã‚’ä½¿ç”¨ã—ã¦ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«
          tsconfig: './tsconfig.json',
          declaration: true, // å‹å®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ (tscå´ã§ã‚‚ç”Ÿæˆã—ã¦ã„ã‚‹ãŒå¿µã®ãŸã‚)
          declarationDir: 'dist/types', // å‹å®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«ã®å‡ºåŠ›å…ˆ (tscã®outDirã¨åˆã‚ã›ã‚‹ã‹æ¤œè¨)
          rootDir: 'src', // ã‚½ãƒ¼ã‚¹ã®ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        }),
      ],
    },
    sourcemap: true,
    // emptyOutDir: false, // tsc ãŒ dist ã‚’ä½¿ã†ã®ã§ã€Vite ãŒã‚¯ãƒªã‚¢ã—ãªã„ã‚ˆã†ã«ã™ã‚‹ (å¿…è¦ã«å¿œã˜ã¦)
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
    },
  },
});
</file>

<file path="__tests__/GISManager.test.ts">
import { GISManager } from '../src/gis/GISManager';
import { TOKYO_PROJECTION, BuildingData, RoadData, POIData, TerrainData } from '../src/types/gis';
import * as THREE from 'three';

describe('GISManager', () => {
  let gisManager: GISManager;

  beforeEach(() => {
    gisManager = new GISManager();
  });

  describe('coordinate transformation', () => {
    it('should transform geographic coordinates to world coordinates', () => {
      const geoCoords = { latitude: 35.6812, longitude: 139.7671, altitude: 10 };
      const worldCoords = gisManager.geoToWorld(geoCoords);
      
      expect(typeof worldCoords.x).toBe('number');
      expect(typeof worldCoords.y).toBe('number');
      expect(typeof worldCoords.z).toBe('number');
      expect(worldCoords.y).toBe(10); // altitude should be preserved
    });

    it('should transform world coordinates back to geographic coordinates', () => {
      const originalGeo = { latitude: 35.6812, longitude: 139.7671, altitude: 10 };
      const worldCoords = gisManager.geoToWorld(originalGeo);
      const backToGeo = gisManager.worldToGeo(worldCoords);
      
      expect(backToGeo.latitude).toBeCloseTo(originalGeo.latitude, 5);
      expect(backToGeo.longitude).toBeCloseTo(originalGeo.longitude, 5);
      expect(backToGeo.altitude).toBeCloseTo(originalGeo.altitude!, 5);
    });

    it('should handle Tokyo Station coordinates correctly', () => {
      const tokyoStation = { latitude: 35.6812, longitude: 139.7671, altitude: 0 };
      const worldCoords = gisManager.geoToWorld(tokyoStation);
      
      // æ±äº¬é§…ãŒä¸­å¿ƒãªã®ã§ã€worldåº§æ¨™ã¯åŸç‚¹ä»˜è¿‘ã«ãªã‚‹ã¯ãš
      expect(Math.abs(worldCoords.x)).toBeLessThan(1);
      expect(Math.abs(worldCoords.z)).toBeLessThan(1);
      expect(worldCoords.y).toBe(0);
    });
  });

  describe('3D object creation', () => {
    it('should create terrain from terrain data', () => {
      const terrainData: TerrainData = {
        id: 'test-terrain', // Added id
        width: 10,
        height: 10,
        data: new Float32Array(100).fill(0),
        bounds: {
          min: { latitude: 35.680, longitude: 139.765 },
          max: { latitude: 35.682, longitude: 139.769 }
        },
        resolution: 1
      };
      
      const terrain = gisManager.createTerrain(terrainData);
      
      expect(terrain).toBeInstanceOf(THREE.Mesh);
      expect(terrain.geometry).toBeInstanceOf(THREE.PlaneGeometry);
      expect(terrain.material).toBeInstanceOf(THREE.MeshLambertMaterial);
    });

    it('should create building from building data', () => {
      const buildingData: BuildingData = {
        id: 'test-building',
        name: 'Test Building',
        coordinates: { latitude: 35.6812, longitude: 139.7671, altitude: 0 },
        height: 50,
        footprint: [
          { latitude: 35.6810, longitude: 139.7669 },
          { latitude: 35.6814, longitude: 139.7669 },
          { latitude: 35.6814, longitude: 139.7673 },
          { latitude: 35.6810, longitude: 139.7673 }
        ],
        properties: {
          type: 'office',
          floors: 10
        }
      };
      
      const building = gisManager.createBuilding(buildingData);
      
      expect(building).toBeInstanceOf(THREE.Group);
      expect(building.name).toBe('building-test-building');
      expect(building.children.length).toBeGreaterThan(0);
    });

    it('should create road from road data', () => {
      const roadData: RoadData = {
        id: 'test-road',
        name: 'Test Road',
        type: 'street',
        coordinates: [
          { latitude: 35.6810, longitude: 139.7669 },
          { latitude: 35.6814, longitude: 139.7673 }
        ],
        width: 8,
        properties: {
          surface: 'asphalt'
        }
      };
      
      const road = gisManager.createRoad(roadData);
      
      expect(road).toBeInstanceOf(THREE.Line);
      expect(road.name).toBe('road-test-road');
    });

    it('should create POI from POI data', () => {
      const poiData: POIData = {
        id: 'test-poi',
        name: 'Test POI',
        type: 'station',
        coordinate: { latitude: 35.6812, longitude: 139.7671 }, // Changed 'coordinates' to 'coordinate'
        properties: {}
      };
      
      const poi = gisManager.createPOI(poiData);
      
      expect(poi).toBeInstanceOf(THREE.Sprite);
      expect(poi.name).toBe('poi-test-poi');
    });
  });

  describe('layer management', () => {
    it('should add and retrieve layers', () => {
      const layer = {
        id: 'test-layer',
        name: 'Test Layer',
        type: 'building' as const, // Changed 'buildings' to 'building'
        visible: true,
        opacity: 1,
        data: []
      };
      
      gisManager.addLayer(layer);
      
      const retrievedLayer = gisManager.getLayer('test-layer');
      expect(retrievedLayer).toBe(layer);
    });

    it('should remove layers', () => {
      const layer = {
        id: 'test-layer',
        name: 'Test Layer',
        type: 'building' as const, // Changed 'buildings' to 'building'
        visible: true,
        opacity: 1,
        data: []
      };
      
      gisManager.addLayer(layer);
      gisManager.removeLayer('test-layer');
      
      const retrievedLayer = gisManager.getLayer('test-layer');
      expect(retrievedLayer).toBeUndefined();
    });

    it('should toggle layer visibility', () => {
      const layer = {
        id: 'test-layer',
        name: 'Test Layer',
        type: 'building' as const, // Changed 'buildings' to 'building'
        visible: true,
        opacity: 1,
        data: []
      };
      
      gisManager.addLayer(layer);
      gisManager.toggleLayer('test-layer');
      
      expect(layer.visible).toBe(false);
      
      gisManager.toggleLayer('test-layer');
      expect(layer.visible).toBe(true);
    });
  });
});
</file>

<file path="src/components/TokyoStationExplorer.tsx">
import React, { useEffect, useState, useCallback } from 'react';
import { Web3DExplorerComponent } from './Web3DExplorerComponent';
import { Explorer } from '../core/Explorer';
import { GISManager } from '../gis/GISManager';
import {
  Web3DExplorerConfig,
  PerformanceMetrics,
  GeoCoordinates
} from '../types';
import {
  TokyoStationArea,
  BuildingData,
  RoadData,
  POIData,
  TOKYO_PROJECTION
} from '../types/gis';
import * as THREE from 'three';

interface TokyoStationExplorerProps {
  className?: string;
  style?: React.CSSProperties;
  onLoadComplete?: () => void;
  showDebugInfo?: boolean;
}

/**
 * æ±äº¬é§…ã‚¨ãƒªã‚¢å°‚ç”¨ã®3Dæ¢ç´¢ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
export const TokyoStationExplorer: React.FC<TokyoStationExplorerProps> = ({
  className,
  style,
  onLoadComplete,
  showDebugInfo = false
}) => {
  const [explorer, setExplorer] = useState<Explorer | null>(null);
  const [gisManager, setGisManager] = useState<GISManager | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [metrics, setMetrics] = useState<PerformanceMetrics | null>(null);

  // æ±äº¬é§…ã‚¨ãƒªã‚¢ç”¨ã®è¨­å®š
  const config: Web3DExplorerConfig = {
    scene: {
      background: new THREE.Color(0x87ceeb), // ç©ºè‰²
      fog: {
        type: 'linear',
        color: new THREE.Color(0x87ceeb),
        near: 100,
        far: 1000
      },
      ambientLight: {
        color: new THREE.Color(0xffffff),
        intensity: 0.6
      }
    },
    camera: {
      fov: 60,
      aspect: window.innerWidth / window.innerHeight,
      near: 0.1,
      far: 2000,
      position: { x: 0, y: 50, z: 100 },
      target: { x: 0, y: 0, z: 0 }
    },
    renderer: {
      antialias: true,
      alpha: false,
      powerPreference: 'high-performance'
    },
    lights: [
      {
        type: 'directional',
        color: new THREE.Color(0xffffff),
        intensity: 1.0,
        position: { x: 50, y: 100, z: 50 },
        castShadow: true
      },
      {
        type: 'directional',
        color: new THREE.Color(0x4040ff),
        intensity: 0.3,
        position: { x: -50, y: 50, z: -50 },
        castShadow: false
      }
    ],
    debug: showDebugInfo,
    performance: {
      enableStats: showDebugInfo,
      maxFPS: 60,
      adaptiveQuality: true
    }
  };

  // æ±äº¬é§…ã‚¨ãƒªã‚¢ã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
  const loadTokyoStationData = useCallback(async (): Promise<TokyoStationArea> => {
    // ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯å¤–éƒ¨APIã‹ã‚‰å–å¾—ï¼‰
    const mockTokyoStation: BuildingData = {
      id: 'tokyo-station-main',
      name: 'æ±äº¬é§…',
      coordinates: { latitude: 35.6812, longitude: 139.7671, altitude: 0 },
      height: 30,
      footprint: [
        { latitude: 35.6810, longitude: 139.7669 },
        { latitude: 35.6814, longitude: 139.7669 },
        { latitude: 35.6814, longitude: 139.7673 },
        { latitude: 35.6810, longitude: 139.7673 }
      ],
      properties: {
        type: 'station',
        floors: 5,
        yearBuilt: 1914,
        material: 'brick'
      }
    };

    const mockBuildings: BuildingData[] = [
      {
        id: 'marunouchi-building',
        name: 'ä¸¸ã®å†…ãƒ“ãƒ«',
        coordinates: { latitude: 35.6815, longitude: 139.7665, altitude: 0 },
        height: 180,
        footprint: [
          { latitude: 35.6813, longitude: 139.7663 },
          { latitude: 35.6817, longitude: 139.7663 },
          { latitude: 35.6817, longitude: 139.7667 },
          { latitude: 35.6813, longitude: 139.7667 }
        ],
        properties: {
          type: 'office',
          floors: 37,
          yearBuilt: 2002
        }
      }
    ];

    const mockRoads: RoadData[] = [
      {
        id: 'marunouchi-nakadori',
        name: 'ä¸¸ã®å†…ä»²é€šã‚Š',
        type: 'street',
        coordinates: [
          { latitude: 35.6805, longitude: 139.7665 },
          { latitude: 35.6820, longitude: 139.7665 }
        ],
        width: 8,
        properties: {
          surface: 'asphalt',
          lanes: 2
        }
      }
    ];

    const mockPOIs: POIData[] = [
      {
        id: 'marunouchi-exit',
        name: 'ä¸¸ã®å†…å£',
        type: 'station',
        coordinate: { latitude: 35.6812, longitude: 139.7665 }, // Changed 'coordinates' to 'coordinate'
        properties: {
          exitNumber: 'A1'
        }
      }
    ];

    return {
      station: mockTokyoStation,
      platforms: [],
      concourse: [],
      exits: mockPOIs,
      nearbyBuildings: mockBuildings,
      roads: mockRoads,
      terrain: {
        id: 'tokyo-terrain', // Added id
        width: 200,
        height: 200,
        data: new Float32Array(200 * 200).fill(0), // å¹³å¦ãªåœ°å½¢
        bounds: {
          min: { latitude: 35.6800, longitude: 139.7650 },
          max: { latitude: 35.6825, longitude: 139.7690 }
        },
        resolution: 1
      }
    };
  }, []);

  // 3Dã‚·ãƒ¼ãƒ³ã«ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
  const setupTokyoStationScene = useCallback(async (explorer: Explorer) => {
    try {
      setLoadingProgress(10);
      
      const gisManager = new GISManager(); // Removed TOKYO_PROJECTION argument
      setGisManager(gisManager);
      
      setLoadingProgress(30);
      
      const tokyoStationData = await loadTokyoStationData();
      
      setLoadingProgress(50);
      
      // åœ°å½¢ã®è¿½åŠ 
      const terrain = gisManager.createTerrain(tokyoStationData.terrain);
      explorer.addObject(terrain, { name: 'terrain' });
      
      setLoadingProgress(60);
      
      // å»ºç‰©ã®è¿½åŠ 
      const stationBuilding = gisManager.createBuilding(tokyoStationData.station);
      explorer.addObject(stationBuilding, { name: 'tokyo-station' });
      
      tokyoStationData.nearbyBuildings.forEach((building: BuildingData, index: number) => {
        const buildingObject = gisManager.createBuilding(building);
        explorer.addObject(buildingObject, { name: `building-${index}` });
      });
      
      setLoadingProgress(80);
      
      // é“è·¯ã®è¿½åŠ 
      tokyoStationData.roads.forEach((road: RoadData, index: number) => {
        const roadObject = gisManager.createRoad(road);
        explorer.addObject(roadObject, { name: `road-${index}` });
      });
      
      // POIã®è¿½åŠ 
      tokyoStationData.exits.forEach((poi: POIData, index: number) => {
        const poiObject = gisManager.createPOI(poi);
        explorer.addObject(poiObject, { name: `poi-${index}` });
      });
      
      setLoadingProgress(100);
      setIsLoading(false);
      
      if (onLoadComplete) {
        onLoadComplete();
      }
      
    } catch (error) {
      console.error('Error setting up Tokyo Station scene:', error);
      setError(error instanceof Error ? error.message : 'Unknown error');
      setIsLoading(false);
    }
  }, [loadTokyoStationData, onLoadComplete]);

  const handleExplorerReady = useCallback((explorer: Explorer) => {
    setExplorer(explorer);
    setupTokyoStationScene(explorer);
  }, [setupTokyoStationScene]);

  const handlePerformanceUpdate = useCallback((newMetrics: PerformanceMetrics) => {
    setMetrics(newMetrics);
  }, []);

  if (error) {
    return (
      <div className="tokyo-station-error" style={{ padding: '20px', color: 'red' }}>
        <h3>Error loading Tokyo Station Explorer</h3>
        <p>{error}</p>
        <button onClick={() => window.location.reload()}>Reload</button>
      </div>
    );
  }

  return (
    <div 
      className={`tokyo-station-explorer ${className || ''}`}
      style={{
        width: '100%',
        height: '100%',
        position: 'relative',
        ...style
      }}
    >
      <Web3DExplorerComponent
        config={config}
        onExplorerReady={handleExplorerReady}
        onPerformanceUpdate={handlePerformanceUpdate}
      />
      
      {isLoading && (
        <div 
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(255, 255, 255, 0.9)',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000
          }}
        >
          <div style={{ fontSize: '18px', marginBottom: '20px' }}>
            Loading Tokyo Station Explorer...
          </div>
          <div 
            style={{
              width: '300px',
              height: '10px',
              background: '#e0e0e0',
              borderRadius: '5px',
              overflow: 'hidden'
            }}
          >
            <div 
              style={{
                width: `${loadingProgress}%`,
                height: '100%',
                background: 'linear-gradient(90deg, #4CAF50, #8BC34A)',
                transition: 'width 0.3s ease'
              }}
            />
          </div>
          <div style={{ marginTop: '10px', fontSize: '14px', color: '#666' }}>
            {loadingProgress}%
          </div>
        </div>
      )}
      
      {showDebugInfo && metrics && (
        <div 
          style={{
            position: 'absolute',
            top: '10px',
            right: '10px',
            background: 'rgba(0, 0, 0, 0.8)',
            color: 'white',
            padding: '15px',
            borderRadius: '8px',
            fontFamily: 'monospace',
            fontSize: '12px',
            minWidth: '200px',
            zIndex: 1000
          }}
        >
          <div style={{ fontWeight: 'bold', marginBottom: '10px' }}>
            Performance Metrics
          </div>
          <div>FPS: {metrics.fps}</div>
          <div>Frame Time: {metrics.frameTime?.toFixed(2)}ms</div>
          <div>Render Time: {metrics.renderTime?.toFixed(2)}ms</div>
          <div>Triangles: {metrics.triangleCount?.toLocaleString()}</div>
          <div>Draw Calls: {metrics.drawCalls}</div>
          <div>Memory: {metrics.memoryUsage.total}MB</div>
        </div>
      )}
      
      {!isLoading && (
        <div 
          style={{
            position: 'absolute',
            bottom: '20px',
            left: '20px',
            background: 'rgba(0, 0, 0, 0.7)',
            color: 'white',
            padding: '15px',
            borderRadius: '8px',
            maxWidth: '300px',
            zIndex: 1000
          }}
        >
          <h3 style={{ margin: '0 0 10px 0', fontSize: '16px' }}>
            Tokyo Station Explorer
          </h3>
          <p style={{ margin: '0', fontSize: '14px', lineHeight: '1.4' }}>
            æ±äº¬é§…å‘¨è¾ºã®3Då¯è¦–åŒ–ã§ã™ã€‚ãƒã‚¦ã‚¹ã§è¦–ç‚¹ã‚’æ“ä½œã—ã€å»ºç‰©ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è©³ç´°ã‚’ç¢ºèªã§ãã¾ã™ã€‚
          </p>
        </div>
      )}
    </div>
  );
};

export default TokyoStationExplorer;
</file>

<file path="src/core/Explorer.ts">
import * as THREE from 'three';
import { EventEmitter } from '../utils/EventEmitter';
import {
  Web3DExplorer as IWeb3DExplorer, // Aliased import
  Web3DExplorerConfig,
  Object3DConfig,
  PerformanceMetrics,
  EventHandler
} from '../types';

/**
 * Web3DExplorer ã®ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹
 * Three.js ã‚’ãƒ™ãƒ¼ã‚¹ã¨ã—ãŸ 3D å¯è¦–åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚³ã‚¢ã‚¨ãƒ³ã‚¸ãƒ³
 */
export class Explorer extends EventEmitter implements IWeb3DExplorer { // Use aliased interface
  public scene!: THREE.Scene; // Definite assignment assertion
  public camera!: THREE.PerspectiveCamera; // Definite assignment assertion
  public renderer!: THREE.WebGLRenderer; // Definite assignment assertion
  public config: Web3DExplorerConfig;
  
  private animationId: number | null = null;
  private stats: PerformanceMetrics;
  private clock: THREE.Clock;
  private raycaster: THREE.Raycaster;
  private mouse: THREE.Vector2;
  private isDisposed = false;

  constructor(config: Web3DExplorerConfig, container?: HTMLElement) {
    super();
    this.config = config;
    this.clock = new THREE.Clock();
    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2();
    
    this.initializeScene();
    this.initializeCamera();
    this.initializeRenderer(container);
    this.initializeLights();
    this.setupEventListeners();
    
    this.stats = this.createInitialStats();
    
    if (this.config.debug) {
      console.log('Web3DExplorer initialized', this.config);
    }
  }

  private initializeScene(): void {
    this.scene = new THREE.Scene();
    
    const sceneConfig = this.config.scene;
    if (sceneConfig?.background) { // Optional chaining
      this.scene.background = new THREE.Color(sceneConfig.background); // Ensure THREE.Color instance
    }
    
    if (sceneConfig?.fog) { // Optional chaining
      const { type, color, near, far, density } = sceneConfig.fog;
      if (type === 'linear' && near !== undefined && far !== undefined) {
        this.scene.fog = new THREE.Fog(new THREE.Color(color), near, far);
      } else if (type === 'exponential' && density !== undefined) {
        this.scene.fog = new THREE.FogExp2(new THREE.Color(color), density);
      }
    }
  }

  private initializeCamera(): void {
    const camConfig = this.config.camera; // Store in a variable for safer access
    if (!camConfig) {
        // Handle missing camera config, e.g., by creating a default camera
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 5, 10);
        return;
    }
    const { fov = 75, aspect = window.innerWidth / window.innerHeight, near = 0.1, far = 1000, position, target } = camConfig;
    this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    
    if (position) {
      this.camera.position.set(position.x, position.y, position.z);
    }
    
    if (target) {
      this.camera.lookAt(target.x, target.y, target.z);
    }
  }

  private initializeRenderer(container?: HTMLElement): void {
    const rendererConfig = this.config.renderer;
    this.renderer = new THREE.WebGLRenderer({
      canvas: rendererConfig?.canvas, // Optional chaining
      antialias: rendererConfig?.antialias ?? true,
      alpha: rendererConfig?.alpha ?? false,
      preserveDrawingBuffer: rendererConfig?.preserveDrawingBuffer ?? false,
      powerPreference: rendererConfig?.powerPreference ?? 'default',
      stencil: rendererConfig?.stencil ?? true,
      depth: rendererConfig?.depth ?? true,
      logarithmicDepthBuffer: rendererConfig?.logarithmicDepthBuffer ?? false
    });
    
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    if (container) {
      container.appendChild(this.renderer.domElement);
    } else if (document.body) {
      document.body.appendChild(this.renderer.domElement);
    }
  }

  private initializeLights(): void {
    this.config.lights?.forEach((lightConfig: any) => { // Added optional chaining and type annotation
      const light = this.createLight(lightConfig);
      if (light) {
        this.scene.add(light);
      }
    });
    
    // ã‚¢ãƒ³ãƒ“ã‚¨ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®è¿½åŠ 
    if (this.config.scene?.ambientLight) { // Optional chaining
      const { color, intensity } = this.config.scene.ambientLight;
      const ambientLight = new THREE.AmbientLight(new THREE.Color(color), intensity);
      this.scene.add(ambientLight);
    }
  }

  private createLight(config: any): THREE.Light | null {
    const { type, color, intensity, position, castShadow } = config;
    let light: THREE.Light;
    
    switch (type) {
      case 'directional':
        light = new THREE.DirectionalLight(color, intensity);
        if (castShadow) {
          light.castShadow = true;
          const shadowCam = (light as THREE.DirectionalLight).shadow.camera as THREE.OrthographicCamera;
          shadowCam.left = -50;
          shadowCam.right = 50;
          shadowCam.top = 50;
          shadowCam.bottom = -50;
          shadowCam.near = 0.1;
          shadowCam.far = 100;
        }
        break;
        
      case 'point':
        light = new THREE.PointLight(color, intensity);
        if (castShadow) {
          light.castShadow = true;
        }
        break;
        
      case 'spot':
        light = new THREE.SpotLight(color, intensity);
        if (castShadow) {
          light.castShadow = true;
        }
        break;
        
      case 'hemisphere':
        light = new THREE.HemisphereLight(color, color, intensity);
        break;
        
      default:
        console.warn(`Unsupported light type: ${type}`);
        return null;
    }
    
    if (position) {
      light.position.set(position.x, position.y, position.z);
    }
    
    return light;
  }

  private setupEventListeners(): void {
    window.addEventListener('resize', this.handleResize.bind(this));
    this.renderer.domElement.addEventListener('mousemove', this.handleMouseMove.bind(this));
    this.renderer.domElement.addEventListener('click', this.handleClick.bind(this));
  }

  private handleResize(): void {
    const width = window.innerWidth;
    const height = window.innerHeight;
    this.resize(width, height);
  }

  private handleMouseMove(event: MouseEvent): void {
    const rect = this.renderer.domElement.getBoundingClientRect();
    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  }

  private handleClick(event: MouseEvent): void {
    this.raycaster.setFromCamera(this.mouse, this.camera);
    const intersects = this.raycaster.intersectObjects(this.scene.children, true);
    
    if (intersects.length > 0) {
      const intersection = intersects[0];
      this.emit('object-click', {
        object: intersection.object,
        point: intersection.point,
        face: intersection.face,
        uv: intersection.uv,
        originalEvent: event
      });
    }
  }

  private createInitialStats(): PerformanceMetrics {
    return {
      fps: 0,
      frameTime: 0,
      renderTime: 0,
      triangles: 0, // Added missing 'triangles'
      triangleCount: 0,
      drawCalls: 0,
      memoryUsage: {
        geometries: 0,
        textures: 0,
        total: 0
      }
    };
  }

  private updateStats(): void {
    const info = this.renderer.info;
    
    this.stats = {
      fps: Math.round(1 / this.clock.getDelta()),
      frameTime: this.clock.getDelta() * 1000,
      renderTime: 0, // WebGLRenderer doesn't provide this directly
      triangles: info.render.triangles, // Added missing 'triangles'
      triangleCount: info.render.triangles,
      drawCalls: info.render.calls,
      memoryUsage: {
        geometries: info.memory.geometries,
        textures: info.memory.textures,
        total: info.memory.geometries + info.memory.textures
      }
    };
  }

  // Public API methods
  
  public addObject(object: THREE.Object3D, config?: Object3DConfig): void {
    if (config) {
      if (config.position) {
        object.position.set(config.position.x, config.position.y, config.position.z);
      }
      if (config.rotation) {
        object.rotation.set(config.rotation.x, config.rotation.y, config.rotation.z);
      }
      if (config.scale) {
        object.scale.set(config.scale.x, config.scale.y, config.scale.z);
      }
      if (config.visible !== undefined) {
        object.visible = config.visible;
      }
      if (config.name) {
        object.name = config.name;
      }
    }
    
    this.scene.add(object);
    this.emit('object-added', { object, config });
  }

  public removeObject(object: THREE.Object3D): void {
    this.scene.remove(object);
    this.emit('object-removed', { object });
  }

  public animate(callback?: () => void): void {
    if (this.isDisposed) return;
    
    this.animationId = requestAnimationFrame(() => this.animate(callback));
    
    this.updateStats();
    
    if (callback) {
      callback();
    }
    
    this.render();
    this.emit('frame', { stats: this.stats });
  }

  public render(): void {
    if (this.isDisposed) return;
    
    const startTime = performance.now();
    this.renderer.render(this.scene, this.camera);
    const endTime = performance.now();
    
    this.stats.renderTime = endTime - startTime;
  }

  public resize(width: number, height: number): void {
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(width, height);
    this.emit('resize', { width, height });
  }

  public getMetrics(): PerformanceMetrics {
    return { ...this.stats };
  }

  public dispose(): void {
    if (this.isDisposed) return;
    
    this.isDisposed = true;
    
    if (this.animationId !== null) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    
    // ãƒªã‚¹ãƒŠãƒ¼ã®å‰Šé™¤
    window.removeEventListener('resize', this.handleResize.bind(this));
    
    // Three.js ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ”¾
    this.scene.traverse((object) => {
      if (object instanceof THREE.Mesh) {
        object.geometry.dispose();
        if (Array.isArray(object.material)) {
          object.material.forEach(material => material.dispose());
        } else {
          object.material.dispose();
        }
      }
    });
    
    this.renderer.dispose();
    
    // DOMè¦ç´ ã®å‰Šé™¤
    if (this.renderer.domElement.parentElement) {
      this.renderer.domElement.parentElement.removeChild(this.renderer.domElement);
    }
    
    this.removeAllListeners();
    this.emit('disposed');
  }

  // EventEmitter methods are inherited
  public on<T>(event: string, handler: EventHandler<T>): void {
    super.on(event, handler);
  }

  public off<T>(event: string, handler: EventHandler<T>): void {
    super.off(event, handler);
  }

  public emit<T>(event: string, data?: T): void {
    super.emit(event, data);
  }
}

export default Explorer;
</file>

<file path="src/index.ts">
// ãƒ¡ã‚¤ãƒ³ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
import Explorer from './core/Explorer'; // Import Explorer as default
export { Explorer }; // Re-export Explorer
export { GISManager } from './gis/GISManager';
export { EventEmitter } from './utils/EventEmitter';

// React ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export { Web3DExplorerComponent } from './components/Web3DExplorerComponent';
export { TokyoStationExplorer } from './components/TokyoStationExplorer';

// å‹å®šç¾©
export * from './types';
export * from './types/gis';
export * from './types/testing';

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
import * as THREE from 'three';
import { Web3DExplorerConfig } from './types';
import type { TOKYO_PROJECTION } from './types/gis'; // Import as type

/**
 * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® Web3DExplorer è¨­å®š
 */
export const DEFAULT_CONFIG: Web3DExplorerConfig = {
  scene: {
    background: new THREE.Color(0x222222),
    fog: {
      type: 'linear',
      color: new THREE.Color(0x222222),
      near: 50,
      far: 500
    },
    ambientLight: {
      color: new THREE.Color(0x404040),
      intensity: 0.4
    }
  },
  camera: {
    fov: 75,
    aspect: window.innerWidth / window.innerHeight,
    near: 0.1,
    far: 1000,
    position: { x: 0, y: 5, z: 10 }
  },
  renderer: {
    antialias: true,
    alpha: false,
    powerPreference: 'default'
  },
  lights: [
    {
      type: 'directional',
      color: new THREE.Color(0xffffff),
      intensity: 1.0,
      position: { x: 5, y: 10, z: 5 },
      castShadow: true
    }
  ],
  debug: false
};

/**
 * æ±äº¬é§…ã‚¨ãƒªã‚¢å°‚ç”¨ã®è¨­å®š
 */
export const TOKYO_STATION_CONFIG: Web3DExplorerConfig = {
  scene: {
    background: new THREE.Color(0x87ceeb),
    fog: {
      type: 'linear',
      color: new THREE.Color(0x87ceeb),
      near: 100,
      far: 1000
    },
    ambientLight: {
      color: new THREE.Color(0xffffff),
      intensity: 0.6
    }
  },
  camera: {
    fov: 60,
    aspect: window.innerWidth / window.innerHeight,
    near: 0.1,
    far: 2000,
    position: { x: 0, y: 50, z: 100 },
    target: { x: 0, y: 0, z: 0 }
  },
  renderer: {
    antialias: true,
    alpha: false,
    powerPreference: 'high-performance'
  },
  lights: [
    {
      type: 'directional',
      color: new THREE.Color(0xffffff),
      intensity: 1.0,
      position: { x: 50, y: 100, z: 50 },
      castShadow: true
    },
    {
      type: 'directional',
      color: new THREE.Color(0x4040ff),
      intensity: 0.3,
      position: { x: -50, y: 50, z: -50 },
      castShadow: false
    }
  ],
  debug: false
};

// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
/**
 * Web3DExplorer ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
 */
export function createExplorer(config?: Partial<Web3DExplorerConfig>, container?: HTMLElement): Explorer {
  const finalConfig = { ...DEFAULT_CONFIG, ...config };
  return new Explorer(finalConfig, container);
}

/**
 * æ±äº¬é§…ã‚¨ãƒªã‚¢å°‚ç”¨ã® Explorer ã‚’ä½œæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
 */
export function createTokyoStationExplorer(container?: HTMLElement): Explorer {
  return new Explorer(TOKYO_STATION_CONFIG, container);
}

// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³
export type { TOKYO_PROJECTION }; // Export as type

// ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±
export const VERSION = '0.1.0';
export const LIBRARY_NAME = 'Web3DExplorer';
</file>

<file path=".eslintrc.js">
export default {
  env: {
    browser: true,
    es2021: true,
    node: true,
    jest: true
  },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended'
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true
    },
    project: './tsconfig.json'
  },
  plugins: [
    '@typescript-eslint'
  ],
  settings: {
    react: {
      version: 'detect'
    }
  },
  rules: {
    'no-unused-vars': 'off',
    '@typescript-eslint/no-unused-vars': 'warn',
    'no-console': 'warn',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/prefer-const': 'error',
    '@typescript-eslint/no-non-null-assertion': 'warn'
  },
  overrides: [
    {
      files: ['**/*.test.ts', '**/*.test.tsx', '**/__tests__/**/*'],
      rules: {
        '@typescript-eslint/explicit-function-return-type': 'off',
        '@typescript-eslint/no-explicit-any': 'off'
      }
    }
  ]
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["DOM", "DOM.Iterable", "ES6", "ES2022"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@/types/*": ["./src/types/*"],
      "@/components/*": ["./src/components/*"],
      "@/utils/*": ["./src/utils/*"],
      "@/three/*": ["./src/three/*"]
    }
  },
  "include": [
    "src/**/*",
    "three-test-suite/src/**/*",
    "__tests__/**/*",
    "*.ts",
    "*.tsx"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "build"
  ]
}
</file>

<file path="jest.config.js">
export default {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'jsdom',
  moduleFileExtensions: ['js', 'jsx', 'ts', 'tsx', 'json'],
  transform: {
    '^.+\\.(ts|tsx)$': ['ts-jest', {
      useESM: true,
      tsconfig: {
        jsx: 'react-jsx'
      }
    }],
    '^.+\\.(js|jsx)$': 'babel-jest'
  },
  testMatch: [
    '**/__tests__/**/*.(js|jsx|ts|tsx)',
    '**/*.(test|spec).(js|jsx|ts|tsx)'
  ],
  collectCoverageFrom: [
    'src/**/*.(js|jsx|ts|tsx)',
    'three-test-suite/src/**/*.(js|jsx|ts|tsx)',
    '!src/index.(js|ts)',
    '!**/*.d.ts',
    '!**/node_modules/**'
  ],
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testTimeout: 30000,
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@/types/(.*)$': '<rootDir>/src/types/$1',
    '^@/components/(.*)$': '<rootDir>/src/components/$1',
    '^@/utils/(.*)$': '<rootDir>/src/utils/$1',
    '^@/three/(.*)$': '<rootDir>/src/three/$1'
  },
  extensionsToTreatAsEsm: ['.ts', '.tsx', '.js'],
  transformIgnorePatterns: [
    'node_modules/(?!(puppeteer)/)'
  ]
};
</file>

<file path="package.json">
{
  "name": "web3d-explorer",
  "version": "0.1.0",
  "description": "3D web visualization library with TDD-driven testing framework for Three.js applications",
  "type": "module",
  "main": "src/index.ts",
  "types": "dist/index.d.ts",
  "files": [
    "dist",
    "src"
  ],
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:suite": "cd three-test-suite && npm test",
    "dev": "vite",
    "build": "tsc && vite build",
    "type-check": "tsc --noEmit",
    "lint": "eslint src three-test-suite --ext .js,.jsx,.ts,.tsx",
    "lint:fix": "eslint src three-test-suite --ext .js,.jsx,.ts,.tsx --fix",
    "prepare": "npm run build"
  },
  "keywords": [
    "three.js",
    "3d",
    "visualization",
    "testing",
    "tdd",
    "puppeteer",
    "gis",
    "cesium",
    "typescript",
    "react"
  ],
  "author": "usaganikki",
  "license": "MIT",
  "devDependencies": {
    "@babel/preset-env": "^7.22.0",
    "@babel/preset-typescript": "^7.22.0",
    "@eslint/js": "^9.0.0",
    "@rollup/plugin-typescript": "^12.1.2",
    "@types/jest": "^29.5.0",
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/three": "^0.163.0",
    "@typescript-eslint/eslint-plugin": "^8.33.0",
    "@typescript-eslint/parser": "^8.33.0",
    "eslint": "^9.28.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "^3.0.0",
    "ts-jest": "^29.1.0",
    "typescript": "^5.0.0",
    "vite": "^5.0.0"
  },
  "dependencies": {
    "@react-three/fiber": "^8.16.0",
    "puppeteer": "^22.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "three": "^0.163.0"
  }
}
</file>

<file path="three-test-suite/package.json">
{
  "name": "three-test-suite",
  "version": "0.1.0",
  "description": "TDD testing framework for Three.js applications",
  "type": "module",
  "main": "src/index.js",
  "testTimeout": 30000,
  "scripts": {
    "test": "node --experimental-vm-modules node_modules/.bin/jest",
    "test:watch": "node --experimental-vm-modules node_modules/.bin/jest --watch",
    "test:puppeteer": "node --experimental-vm-modules node_modules/.bin/jest --selectProjects=puppeteer-tests",
    "test:dom": "node --experimental-vm-modules node_modules/.bin/jest --selectProjects=dom-tests"
  },
  "dependencies": {
    "puppeteer": "^22.0.0",
    "three": "^0.163.0"
  },
  "devDependencies": {
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0"
  },
  "jest": {
    "projects": [
      {
        "displayName": "puppeteer-tests",
        "testMatch": [
          "**/*PuppeteerManager*.test.js",
          "**/*ScreenshotCapture*.test.js", 
          "**/*ThreeTestRenderer*.test.js"
        ],
        "testEnvironment": "node"
      },
      {
        "displayName": "dom-tests",
        "testMatch": [
          "**/*WebGLEnabler*.test.js",
          "**/*HtmlTemplateGenerator*.test.js",
          "**/*SceneInjector*.test.js",
          "**/*ObjectValidator*.test.js",
          "**/*TransformValidator*.test.js"
        ],
        "testEnvironment": "jsdom"
      }
    ]
  }
}
</file>

<file path="README.md">
# Web3DExplorer

[![TypeScript](https://img.shields.io/badge/TypeScript-5.0+-blue.svg)](https://www.typescriptlang.org/)
[![Three.js](https://img.shields.io/badge/Three.js-0.163+-green.svg)](https://threejs.org/)
[![React](https://img.shields.io/badge/React-18.2+-blue.svg)](https://reactjs.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

**3D web visualization library with TDD-driven testing framework for Three.js applications. Features Tokyo Station exploration with GIS integration.**

## âš¡ é‡è¦ãªã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ

ğŸ‰ **TypeScriptåŒ–å®Œäº†ï¼** (v0.1.0)  
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯å®Œå…¨ã«TypeScriptåŒ–ã•ã‚Œã€å‹å®‰å…¨ã§ä¿å®ˆæ€§ã®é«˜ã„ç¾ä»£çš„ãª3D Webãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«é€²åŒ–ã—ã¾ã—ãŸã€‚

## âœ¨ ä¸»è¦æ©Ÿèƒ½

- **ğŸ¯ TypeScript First**: å®Œå…¨ãªå‹å®‰å…¨æ€§ã¨åŒ…æ‹¬çš„ãªå‹å®šç¾©
- **âš›ï¸ Reactçµ±åˆ**: React Three Fiberã¨ã®å®Œå…¨çµ±åˆ
- **ğŸ—ºï¸ GISçµ±åˆ**: åœ°ç†æƒ…å ±ã‚·ã‚¹ãƒ†ãƒ ã‚µãƒãƒ¼ãƒˆã¨åº§æ¨™å¤‰æ›
- **ğŸš… Tokyo Station Explorer**: æ±äº¬é§…ã‚¨ãƒªã‚¢ã®å°‚ç”¨3Då¯è¦–åŒ–
- **ğŸ§ª TDDãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: Three.jsç”¨åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
- **ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–**: å†…è”µãƒ¡ãƒˆãƒªã‚¯ã‚¹ã¨æœ€é©åŒ–ãƒ„ãƒ¼ãƒ«
- **ğŸ¨ ã‚¤ãƒ™ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ **: å¼·åŠ›ãªã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
- **âš¡ ç¾ä»£çš„ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«**: Viteã€ESLintã€Jestã€TypeScriptè¨­å®š

## ğŸ¯ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç›®æ¨™ã¨é€²æ—

### âœ… **å®Œäº†æ¸ˆã¿ (Phase 1-4 çµ±åˆå®Ÿè£…)**

**ğŸ¯ Primary Goal**: æ±äº¬é§…å‘¨è¾ºã®3Då¯è¦–åŒ–ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é–‹ç™º â†’ **âœ… å®Œäº†**  
**ğŸ¯ Secondary Goal**: Three.jsç”¨ã®å†åˆ©ç”¨å¯èƒ½ãªTDDãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®æ§‹ç¯‰ â†’ **âœ… å®Œäº†**

**ã™ã¹ã¦ã®ãƒ•ã‚§ãƒ¼ã‚ºãŒTypeScriptå®Ÿè£…ã§çµ±åˆçš„ã«å®Œäº†:**
- âœ… **Testing Framework**: ThreeTestUtilsã€ã‚«ã‚¹ã‚¿ãƒ Jestãƒãƒƒãƒãƒ£ãƒ¼
- âœ… **Main Application**: React + Three.js + TypeScriptåŸºç›¤
- âœ… **Tokyo Station**: æ±äº¬é§…3Då¯è¦–åŒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- âœ… **GIS Integration**: åº§æ¨™å¤‰æ›ã€åœ°ç†ãƒ‡ãƒ¼ã‚¿çµ±åˆ

## ğŸš€ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ

### ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
npm install web3d-explorer
# ã¾ãŸã¯
yarn add web3d-explorer
```

### åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•

```typescript
import { createExplorer } from 'web3d-explorer';
import * as THREE from 'three';

// åŸºæœ¬çš„ãª3Dã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’ä½œæˆ
const explorer = createExplorer({
  scene: {
    background: new THREE.Color(0x87ceeb)
  },
  camera: {
    fov: 60,
    aspect: window.innerWidth / window.innerHeight,
    near: 0.1,
    far: 1000,
    position: { x: 0, y: 5, z: 10 }
  },
  renderer: {
    antialias: true
  },
  lights: [
    {
      type: 'directional',
      color: new THREE.Color(0xffffff),
      intensity: 1.0,
      position: { x: 5, y: 10, z: 5 }
    }
  ]
});

// ã‚·ãƒ³ãƒ—ãƒ«ãªã‚­ãƒ¥ãƒ¼ãƒ–ã‚’è¿½åŠ 
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);

explorer.addObject(cube, {
  position: { x: 0, y: 0, z: 0 },
  name: 'my-cube'
});

// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
explorer.animate();
```

### Reactä½¿ç”¨ä¾‹

```tsx
import React from 'react';
import { Web3DExplorerComponent } from 'web3d-explorer';
import * as THREE from 'three';

const MyApp: React.FC = () => {
  const config = {
    scene: {
      background: new THREE.Color(0x87ceeb)
    },
    camera: {
      fov: 60,
      aspect: window.innerWidth / window.innerHeight,
      near: 0.1,
      far: 1000
    },
    renderer: {
      antialias: true
    },
    lights: [
      {
        type: 'directional' as const,
        color: new THREE.Color(0xffffff),
        intensity: 1.0,
        position: { x: 5, y: 10, z: 5 }
      }
    ]
  };

  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <Web3DExplorerComponent
        config={config}
        onExplorerReady={(explorer) => {
          console.log('Explorer ready!', explorer);
        }}
      />
    </div>
  );
};

export default MyApp;
```

### æ±äº¬é§…ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼

```tsx
import React from 'react';
import { TokyoStationExplorer } from 'web3d-explorer';

const TokyoStationApp: React.FC = () => {
  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <TokyoStationExplorer
        showDebugInfo={true}
        onLoadComplete={() => {
          console.log('Tokyo Station loaded!');
        }}
      />
    </div>
  );
};

export default TokyoStationApp;
```

## ğŸ“ ç¾åœ¨ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

```
Web3DExplorer/
â”œâ”€â”€ src/                       # TypeScriptå®Ÿè£…
â”‚   â”œâ”€â”€ core/                  # ã‚³ã‚¢Explorerã‚¯ãƒ©ã‚¹
â”‚   â”‚   â””â”€â”€ Explorer.ts        âœ… å®Œäº†
â”‚   â”œâ”€â”€ components/            # Reactã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”‚   â”œâ”€â”€ Web3DExplorerComponent.tsx âœ… å®Œäº†
â”‚   â”‚   â””â”€â”€ TokyoStationExplorer.tsx   âœ… å®Œäº†
â”‚   â”œâ”€â”€ gis/                   # GISæ©Ÿèƒ½
â”‚   â”‚   â””â”€â”€ GISManager.ts      âœ… å®Œäº†
â”‚   â”œâ”€â”€ test/                  # ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚   â”‚   â””â”€â”€ ThreeTestUtils.ts  âœ… å®Œäº†
â”‚   â”œâ”€â”€ types/                 # TypeScriptå‹å®šç¾©
â”‚   â”‚   â”œâ”€â”€ index.ts           âœ… å®Œäº†
â”‚   â”‚   â”œâ”€â”€ gis.ts            âœ… å®Œäº†
â”‚   â”‚   â””â”€â”€ testing.ts        âœ… å®Œäº†
â”‚   â”œâ”€â”€ utils/                 # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚   â”‚   â””â”€â”€ EventEmitter.ts    âœ… å®Œäº†
â”‚   â””â”€â”€ index.ts              âœ… å®Œäº†
â”œâ”€â”€ __tests__/                 # ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«
â”‚   â”œâ”€â”€ Explorer.test.ts       âœ… å®Œäº†
â”‚   â””â”€â”€ GISManager.test.ts     âœ… å®Œäº†
â”œâ”€â”€ examples/                  # ä½¿ç”¨ä¾‹
â”‚   â”œâ”€â”€ basic-example.html     âœ… å®Œäº†
â”‚   â””â”€â”€ react-example.tsx      âœ… å®Œäº†
â”œâ”€â”€ three-test-suite/          # å¾“æ¥ã®ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆï¼ˆçµ±åˆæ¸ˆã¿ï¼‰
â””â”€â”€ docs/                      # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
```

## ğŸ§ª TDDé–‹ç™ºã¨ãƒ†ã‚¹ãƒˆ

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```bash
# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm test

# ã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰ã§ãƒ†ã‚¹ãƒˆ
npm run test:watch

# ã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ããƒ†ã‚¹ãƒˆ
npm run test:coverage

# Three.jsãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ
npm run test:suite
```

### ThreeTestUtilsã‚’ä½¿ç”¨ã—ãŸãƒ†ã‚¹ãƒˆä½œæˆ

```typescript
import { threeTestUtils, createMockScene } from 'web3d-explorer/test';
import * as THREE from 'three';

describe('My 3D Component', () => {
  let scene: THREE.Scene;
  let cube: THREE.Mesh;

  beforeEach(() => {
    const mockScene = createMockScene();
    scene = mockScene.scene;
    
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    cube = new THREE.Mesh(geometry, material);
  });

  it('should position cube correctly', () => {
    cube.position.set(5, 10, 15);
    
    threeTestUtils.expectObject3D(cube).toHavePosition(
      new THREE.Vector3(5, 10, 15)
    );
  });

  it('should be visible', () => {
    threeTestUtils.expectObject3D(cube).toBeVisible();
  });

  it('should be in camera frustum', () => {
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    camera.position.z = 5;
    
    threeTestUtils.expectObject3D(cube).toBeInFrustum(camera);
  });
});
```

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### **TypeScriptå‹ã‚·ã‚¹ãƒ†ãƒ **
```
å‹å®šç¾©ã‚·ã‚¹ãƒ†ãƒ 
â”œâ”€â”€ Core Types (Explorer, PerformanceMetrics, Object3DConfig)
â”œâ”€â”€ GIS Types (GeoCoordinates, BuildingData, TerrainData)
â”œâ”€â”€ Testing Types (TestScenario, VisualTest, ThreeTestUtils)
â””â”€â”€ React Types (Component Props, Event Handlers)
```

### **ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³**
```
Explorer (TypeScript Core)
â”œâ”€â”€ Scene3D (Three.jsç®¡ç†)
â”‚   â”œâ”€â”€ TokyoStationModel (3D Asset) âœ…
â”‚   â”œâ”€â”€ CameraController (åˆ¶å¾¡) âœ…
â”‚   â””â”€â”€ LightingSystem (ç…§æ˜) âœ…
â”œâ”€â”€ GISManager (Cesiumçµ±åˆ) âœ…
â”œâ”€â”€ React Components (UI) âœ…
â””â”€â”€ ThreeTestUtils (ãƒ†ã‚¹ãƒˆã‚µãƒãƒ¼ãƒˆ) âœ…
```

## ğŸ”§ æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

### **ã‚³ã‚¢å®Ÿè£…**
- **TypeScript 5.0+**: å‹å®‰å…¨æ€§ã¨ãƒ¢ãƒ€ãƒ³JSæ©Ÿèƒ½
- **Three.js 0.163.0+**: 3Dãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ»ã‚·ãƒ¼ãƒ³ç®¡ç†
- **React 18.2+**: UIãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
- **@react-three/fiber 8.16.0+**: React Three.jsçµ±åˆ

### **é–‹ç™ºãƒ»ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«**
- **Vite**: é«˜é€Ÿãƒ“ãƒ«ãƒ‰ã‚·ã‚¹ãƒ†ãƒ 
- **Jest + ts-jest**: TypeScriptå¯¾å¿œãƒ†ã‚¹ãƒˆç’°å¢ƒ
- **ESLint + @typescript-eslint**: TypeScriptå¯¾å¿œãƒªãƒ³ã‚¿ãƒ¼
- **Prettier**: ã‚³ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼

### **ãƒ†ã‚¹ãƒ†ã‚£ãƒ³ã‚°ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**
- **Jest Custom Matchers**: 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”¨ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒãƒ£ãƒ¼ âœ…
- **Puppeteer**: ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹ãƒ–ãƒ©ã‚¦ã‚¶ãƒ†ã‚¹ãƒˆ âœ…
- **Performance Testing**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ âœ…

## ğŸš¦ é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

```bash
# ãƒªãƒã‚¸ãƒˆãƒªã‚¯ãƒ­ãƒ¼ãƒ³
git clone https://github.com/usaganikki/Web3DExplorer.git
cd Web3DExplorer

# ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install

# é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•
npm run dev

# å‹ãƒã‚§ãƒƒã‚¯
npm run type-check

# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm test

# ãƒ“ãƒ«ãƒ‰
npm run build
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

```typescript
// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®å–å¾—
explorer.on('frame', ({ stats }) => {
  console.log('FPS:', stats.fps);
  console.log('Frame Time:', stats.frameTime, 'ms');
  console.log('Triangles:', stats.triangleCount);
  console.log('Draw Calls:', stats.drawCalls);
});

// ç¾åœ¨ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹å–å¾—
const metrics = explorer.getMetrics();
```

## ğŸ—ºï¸ GISçµ±åˆ

```typescript
import { GISManager, TOKYO_PROJECTION } from 'web3d-explorer';

const gisManager = new GISManager(TOKYO_PROJECTION);

// ç·¯åº¦çµŒåº¦ã‚’3Dåº§æ¨™ã«å¤‰æ›
const worldPos = gisManager.geoToWorld({
  latitude: 35.6812,  // æ±äº¬é§…
  longitude: 139.7671,
  altitude: 0
});

// åœ°ç†åº§æ¨™ã«æˆ»ã™
const geoPos = gisManager.worldToGeo(worldPos);
```

## ğŸ“š API ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

### Explorer ã‚¯ãƒ©ã‚¹

```typescript
class Explorer {
  constructor(config: Web3DExplorerConfig, container?: HTMLElement)
  
  // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
  addObject(object: THREE.Object3D, config?: Object3DConfig): void
  removeObject(object: THREE.Object3D): void
  
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  animate(callback?: () => void): void
  render(): void
  
  // ã‚¤ãƒ™ãƒ³ãƒˆ
  on<T>(event: string, handler: EventHandler<T>): void
  off<T>(event: string, handler: EventHandler<T>): void
  emit<T>(event: string, data?: T): void
  
  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
  getMetrics(): PerformanceMetrics
  
  // ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«
  resize(width: number, height: number): void
  dispose(): void
}
```

### GISManager ã‚¯ãƒ©ã‚¹

```typescript
class GISManager {
  constructor(projection?: ProjectionSystem, center?: GeoCoordinates)
  
  // åº§æ¨™å¤‰æ›
  geoToWorld(coords: GeoCoordinates): Position3D
  worldToGeo(position: Position3D): GeoCoordinates
  
  // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
  loadTerrain(url: string): Promise<TerrainData>
  loadBuildings(url: string): Promise<BuildingData[]>
  loadRoads(url: string): Promise<RoadData[]>
  loadPOIs(url: string): Promise<POIData[]>
  
  // 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
  createTerrain(data: TerrainData): THREE.Mesh
  createBuilding(data: BuildingData): THREE.Group
  createRoad(data: RoadData): THREE.Line
  createPOI(data: POIData): THREE.Sprite
}
```

## ğŸ¯ ç¾åœ¨ã®ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³

âœ… **v0.1.0 - TypeScript Migration Complete**
- å®Œå…¨ãªTypeScriptåŒ–
- React Three Fiberçµ±åˆ
- GISæ©Ÿèƒ½å®Ÿè£…
- æ±äº¬é§…ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼
- åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯

ğŸ”„ **v0.2.0 - Enhanced Features (è¨ˆç”»ä¸­)**
- WebXRå¯¾å¿œï¼ˆVR/ARï¼‰
- WebGL 2.0æ´»ç”¨
- é«˜åº¦ãªGISçµ±åˆ
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

## ğŸ¤ ã‚³ãƒ³ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³

1. ãƒªãƒã‚¸ãƒˆãƒªã‚’ãƒ•ã‚©ãƒ¼ã‚¯
2. æ©Ÿèƒ½ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆ: `git checkout -b feature/amazing-feature`
3. å¤‰æ›´ã«å¯¾ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚’ä½œæˆ
4. å…¨ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèª: `npm test`
5. å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ: `git commit -m 'Add amazing feature'`
6. ãƒ–ãƒ©ãƒ³ãƒã«ãƒ—ãƒƒã‚·ãƒ¥: `git push origin feature/amazing-feature`
7. ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆ

### **TDDé–‹ç™ºæ–¹é‡**

ğŸ”´ **RED**: ãƒ†ã‚¹ãƒˆã‚’æ›¸ãï¼ˆå¤±æ•—ï¼‰  
ğŸŸ¢ **GREEN**: æœ€å°é™ã®å®Ÿè£…ï¼ˆãƒ†ã‚¹ãƒˆé€šéï¼‰  
ğŸ”§ **REFACTOR**: ã‚³ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—

### **ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼åŸºæº–**
- ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸90%ä»¥ä¸Š
- ESLint/Prettieræº–æ‹ 
- TypeDocå½¢å¼ã®ã‚³ãƒ¡ãƒ³ãƒˆ
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶ï¼ˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ™‚é–“10ç§’ä»¥å†…ï¼‰

## ğŸ“‹ èª²é¡Œã¨ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

### Known Issues
- WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ­ã‚¹: è‡ªå‹•å¾©æ—§æœªå®Ÿè£…
- ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè§£æ”¾ã®ä¸€éƒ¨ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹
- ãƒ¢ãƒã‚¤ãƒ«æ€§èƒ½: ã‚¿ãƒƒãƒåˆ¶å¾¡ã®æœ€é©åŒ–ãŒå¿…è¦
- Safariäº’æ›æ€§: ä¸€éƒ¨WebGLæ‹¡å¼µãŒåˆ©ç”¨ã§ããªã„å ´åˆã‚ã‚Š

### Future Roadmap
- **WebXRçµ±åˆ**: VR/ARå¯¾å¿œ
- **é«˜åº¦ãªGIS**: äººæ°—GISãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹çµ±åˆ
- **ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£**: 3Dã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: å¤§è¦æ¨¡ã‚·ãƒ¼ãƒ³ã®æœ€é©åŒ–

## ğŸ“š å‚è€ƒè³‡æ–™

### **TypeScript & Three.jsé–¢é€£**
- [TypeScriptå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://www.typescriptlang.org/)
- [Three.js Documentation](https://threejs.org/docs/)
- [React Three Fiber](https://docs.pmnd.rs/react-three-fiber)

### **TDD Methodology**
- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Test-Driven Development: By Example](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530)

### **GIS Integration**
- [Cesium.js Documentation](https://cesium.com/learn/)
- [åœ°ç†åº§æ¨™ç³»ã«ã¤ã„ã¦](https://www.gsi.go.jp/sokuchikijun/datum-main.html)

## ğŸ“„ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯MITãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ä¸‹ã§å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ - è©³ç´°ã¯[LICENSE](LICENSE)ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## ğŸ“ å¤‰æ›´å±¥æ­´

### v0.1.0 (2025-06-01)

- âœ¨ **å®Œå…¨ãªTypeScriptå®Ÿè£…**
  - å‹å®‰å…¨æ€§ã®å¤§å¹…å‘ä¸Š
  - IntelliSenseã‚µãƒãƒ¼ãƒˆ
  - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã‚¨ãƒ©ãƒ¼æ¤œå‡º

- âœ¨ **React Three Fiberçµ±åˆ**
  - Reactã¨Three.jsã®å®Œå…¨çµ±åˆ
  - TypeScriptå¯¾å¿œã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
  - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–æ©Ÿèƒ½

- âœ¨ **GISçµ±åˆã¨æ±äº¬æŠ•å½±ã‚·ã‚¹ãƒ†ãƒ **
  - åœ°ç†åº§æ¨™ç³»å¯¾å¿œ
  - æ±äº¬é§…ä¸­å¿ƒã®æŠ•å½±ã‚·ã‚¹ãƒ†ãƒ 
  - 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªå‹•ç”Ÿæˆ

- âœ¨ **åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**
  - ThreeTestUtilsã‚¯ãƒ©ã‚¹
  - ã‚«ã‚¹ã‚¿ãƒ Jestãƒãƒƒãƒãƒ£ãƒ¼
  - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½
  - ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«å›å¸°ãƒ†ã‚¹ãƒˆ

- âœ¨ **æ±äº¬é§…ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
  - å°‚ç”¨3Då¯è¦–åŒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
  - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åœ°ç†ãƒ‡ãƒ¼ã‚¿çµ±åˆ
  - ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–3Dãƒ¢ãƒ‡ãƒ«

- âœ¨ **ãƒ¢ãƒ€ãƒ³é–‹ç™ºç’°å¢ƒ**
  - Viteãƒ“ãƒ«ãƒ‰ã‚·ã‚¹ãƒ†ãƒ 
  - ESLint + TypeScriptè¨­å®š
  - Prettierçµ±åˆ
  - GitHub Actionså¯¾å¿œ

---

**3D Webãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®ãŸã‚ã« â¤ï¸ ã§ä½œæˆ**

**Last Updated**: 2025-06-01  
**Version**: 0.1.0  
**Status**: âœ… TypeScript Migration Complete
</file>

<file path="three-test-suite/__tests__/PuppeteerManager.test.js">
import { PuppeteerManager } from '../src/PuppeteerManager.js';

describe('PuppeteerManager - åŸºæœ¬æ©Ÿèƒ½', () => {
  test('æ­£å¸¸ã«åˆæœŸåŒ–ã§ãã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    expect(manager.browser).toBeDefined();
    expect(manager.page).toBeDefined();
    
    await manager.cleanup();
  });

  test('cleanupå¾Œã¯ãƒ–ãƒ©ã‚¦ã‚¶ãŒçµ‚äº†ã—ã¦ã„ã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    // cleanupå‰ã«ãƒ–ãƒ©ã‚¦ã‚¶ã®å­˜åœ¨ç¢ºèª
    expect(manager.browser).toBeDefined();
    expect(manager.isInitialized()).toBe(true);
    
    await manager.cleanup();
    
    // cleanupå¾Œã®çŠ¶æ…‹ç¢ºèª
    expect(manager.browser).toBeNull();
    expect(manager.page).toBeNull();
    expect(manager.isInitialized()).toBe(false);
  });

  test('ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®šã§ãã‚‹', async () => {
    const manager = new PuppeteerManager({ headless: false });
    await manager.initialize();
    
    expect(manager.options.headless).toBe(false);
    
    await manager.cleanup();
  });

  test('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒæ­£ã—ãè¨­å®šã•ã‚Œã‚‹', () => {
    const manager = new PuppeteerManager();
    
    expect(manager.options.headless).toBe(true);
    expect(manager.options.width).toBe(1024);
    expect(manager.options.height).toBe(768);
    expect(manager.options.args).toContain('--enable-webgl');
    expect(manager.options.args).toContain('--disable-web-security');
  });

  test('äºŒé‡åˆæœŸåŒ–ã‚’é˜²ã', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    // äºŒå›ç›®ã®åˆæœŸåŒ–ã¯ä½•ã‚‚ã—ãªã„
    await manager.initialize();
    
    expect(manager.browser).toBeDefined();
    
    await manager.cleanup();
  });

  test('åˆæœŸåŒ–å‰ã®cleanupã¯ä½•ã‚‚ã—ãªã„', async () => {
    const manager = new PuppeteerManager();
    
    // ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ãªã„
    await expect(manager.cleanup()).resolves.not.toThrow();
  });
});

describe('PuppeteerManager - WebGLæ©Ÿèƒ½', () => {
  test('WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒå–å¾—ã§ãã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const webglSupported = await manager.page.evaluate(() => {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl');
      return gl !== null;
    });
    
    expect(webglSupported).toBe(true);
    await manager.cleanup();
  });

  test('WebGL2ã‚‚åˆ©ç”¨å¯èƒ½', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const webgl2Supported = await manager.page.evaluate(() => {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl2');
      return gl !== null;
    });
    
    expect(webgl2Supported).toBe(true);
    await manager.cleanup();
  });

  test('WebGLã®åŸºæœ¬æƒ…å ±ãŒå–å¾—ã§ãã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const webglInfo = await manager.page.evaluate(() => {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl');
      if (!gl) return null;
      
      return {
        vendor: gl.getParameter(gl.VENDOR),
        renderer: gl.getParameter(gl.RENDERER),
        version: gl.getParameter(gl.VERSION)
      };
    });
    
    expect(webglInfo).not.toBeNull();
    expect(webglInfo.vendor).toBeDefined();
    expect(webglInfo.renderer).toBeDefined();
    expect(webglInfo.version).toBeDefined();
    
    await manager.cleanup();
  });

  test('getWebGLInfo()ãƒ¡ã‚½ãƒƒãƒ‰ã§WebGLæƒ…å ±ã‚’å–å¾—ã§ãã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const webglInfo = await manager.getWebGLInfo();
    
    expect(webglInfo).toBeDefined();
    expect(webglInfo.webglSupported).toBe(true);
    expect(webglInfo.webgl2Supported).toBeDefined();
    expect(webglInfo.vendor).toBeDefined();
    expect(webglInfo.renderer).toBeDefined();
    expect(webglInfo.version).toBeDefined();
    
    await manager.cleanup();
  });

  test('getWebGLInfo()ã¯åˆæœŸåŒ–å‰ã«å‘¼ã¶ã¨ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
    const manager = new PuppeteerManager();
    
    await expect(manager.getWebGLInfo()).rejects.toThrow('PuppeteerManager is not initialized');
  });
});

describe('PuppeteerManager - WebAssemblyæ©Ÿèƒ½', () => {
  test('WebAssemblyã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåˆ©ç”¨å¯èƒ½', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const wasmSupported = await manager.page.evaluate(() => {
      return typeof WebAssembly !== 'undefined' && 
             typeof WebAssembly.instantiate === 'function';
    });
    
    expect(wasmSupported).toBe(true);
    await manager.cleanup();
  });

  test('WebAssembly.compileStreamingãŒåˆ©ç”¨å¯èƒ½', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const streamingSupported = await manager.page.evaluate(() => {
      return typeof WebAssembly.compileStreaming === 'function';
    });
    
    expect(streamingSupported).toBe(true);
    await manager.cleanup();
  });

  test('ç°¡å˜ãªWASMãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå®Ÿè¡Œã§ãã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const wasmResult = await manager.page.evaluate(() => {
      // ç°¡å˜ãªWASMãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆaddTwoé–¢æ•°: 2ã¤ã®æ•°å€¤ã‚’åŠ ç®—ï¼‰
      const wasmBytes = new Uint8Array([
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01,
        0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x0a, 0x01, 0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6f, 0x00,
        0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b
      ]);
      
      return WebAssembly.instantiate(wasmBytes)
        .then(result => {
          const addTwo = result.instance.exports.addTwo;
          return addTwo(5, 3); // 5 + 3 = 8
        });
    });
    
    expect(wasmResult).toBe(8);
    await manager.cleanup();
  });

  test('getWebAssemblyInfo()ãƒ¡ã‚½ãƒƒãƒ‰ã§WASMæƒ…å ±ã‚’å–å¾—ã§ãã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const wasmInfo = await manager.getWebAssemblyInfo();
    
    expect(wasmInfo).toBeDefined();
    expect(wasmInfo.wasmSupported).toBe(true);
    expect(wasmInfo.streamingSupported).toBeDefined();
    expect(wasmInfo.memorySupported).toBeDefined();
    expect(wasmInfo.tableSupported).toBeDefined();
    expect(wasmInfo.sharedMemorySupported).toBeDefined();
    
    await manager.cleanup();
  });

  test('getWebAssemblyInfo()ã¯åˆæœŸåŒ–å‰ã«å‘¼ã¶ã¨ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
    const manager = new PuppeteerManager();
    
    await expect(manager.getWebAssemblyInfo()).rejects.toThrow('PuppeteerManager is not initialized');
  });

  test('WASMãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆãŒå®Ÿè¡Œã§ãã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const performance = await manager.benchmarkWebAssembly();
    
    expect(performance).toBeDefined();
    expect(performance.executionTime).toBeGreaterThan(0);
    expect(performance.operationsPerSecond).toBeGreaterThan(0);
    
    await manager.cleanup();
  });
});

describe('PuppeteerManager - WASM + WebGLé€£æºæ©Ÿèƒ½', () => {
  test('WebAssemblyã¨WebGLãŒåŒæ™‚ã«åˆ©ç”¨å¯èƒ½', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const capabilities = await manager.getHybridCapabilities();
    
    expect(capabilities.wasmSupported).toBe(true);
    expect(capabilities.webglSupported).toBe(true);
    expect(capabilities.hybridReady).toBe(true);
    
    await manager.cleanup();
  });

  test('WASMè¨ˆç®—çµæœã‚’WebGLã§æç”»ã§ãã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const testScript = () => {
      // WASMã§é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’è¨ˆç®—ã—ã¦WebGLã§æç”»
      window.hybridTestResult = 'pending';
      
      // ç°¡å˜ãªWASMãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆé ‚ç‚¹åº§æ¨™è¨ˆç®—ç”¨ï¼‰
      const wasmBytes = new Uint8Array([
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01,
        0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x0a, 0x01, 0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6f, 0x00,
        0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b
      ]);
      
      WebAssembly.instantiate(wasmBytes).then(result => {
        const addTwo = result.instance.exports.addTwo;
        
        // WASMã§è¨ˆç®—
        const vertices = [
          addTwo(0, 0), addTwo(1, 0), addTwo(0, 0),  // é ‚ç‚¹1
          addTwo(1, 0), addTwo(1, 0), addTwo(0, 0),  // é ‚ç‚¹2
          addTwo(0, 1), addTwo(1, 0), addTwo(0, 0)   // é ‚ç‚¹3
        ];
        
        // WebGLã§æç”»
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl');
        
        if (gl && vertices.length === 9) {
          const buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
          
          window.hybridTestResult = 'success';
        } else {
          window.hybridTestResult = 'failed';
        }
      }).catch(() => {
        window.hybridTestResult = 'error';
      });
    };
    
    const html = manager.generateTestHTML(testScript);
    await manager.page.setContent(html);
    
    // çµæœã‚’å¾…æ©Ÿ
    await manager.page.waitForFunction('window.hybridTestResult !== "pending"', { timeout: 5000 });
    
    const result = await manager.page.evaluate(() => window.hybridTestResult);
    expect(result).toBe('success');
    
    await manager.cleanup();
  });

  test('getHybridCapabilities()ãƒ¡ã‚½ãƒƒãƒ‰ã§é€£æºæƒ…å ±ã‚’å–å¾—ã§ãã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const capabilities = await manager.getHybridCapabilities();
    
    expect(capabilities).toBeDefined();
    expect(capabilities.wasmSupported).toBeDefined();
    expect(capabilities.webglSupported).toBeDefined();
    expect(capabilities.hybridReady).toBeDefined();
    expect(capabilities.performanceProfile).toBeDefined();
    expect(capabilities.recommendedStrategy).toBeDefined();
    
    await manager.cleanup();
  });

  test('benchmarkHybridPerformance()ã§WASM+WebGLæ€§èƒ½ã‚’æ¸¬å®šã§ãã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const performance = await manager.benchmarkHybridPerformance();
    
    expect(performance).toBeDefined();
    expect(performance.wasmComputeTime).toBeGreaterThan(0);
    expect(performance.webglRenderTime).toBeGreaterThan(0);
    expect(performance.dataTransferTime).toBeGreaterThan(0);
    expect(performance.totalTime).toBeGreaterThan(0);
    expect(performance.efficiency).toBeGreaterThan(0);
    
    await manager.cleanup();
  });

  test('å¤§é‡ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã§ã®WASM+WebGLé€£æºãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const performance = await manager.benchmarkHybridPerformance({ 
      dataSize: 10000,
      iterations: 100 
    });
    
    expect(performance.totalTime).toBeLessThan(5000); // 5ç§’ä»¥å†…
    expect(performance.efficiency).toBeGreaterThan(0.3); // åŠ¹ç‡30%ä»¥ä¸Šï¼ˆèª¿æ•´ï¼‰
    
    await manager.cleanup();
  });

  test('getHybridCapabilities()ã¯åˆæœŸåŒ–å‰ã«å‘¼ã¶ã¨ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
    const manager = new PuppeteerManager();
    
    await expect(manager.getHybridCapabilities()).rejects.toThrow('PuppeteerManager is not initialized');
  });

  test('benchmarkHybridPerformance()ã¯åˆæœŸåŒ–å‰ã«å‘¼ã¶ã¨ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
    const manager = new PuppeteerManager();
    
    await expect(manager.benchmarkHybridPerformance()).rejects.toThrow('PuppeteerManager is not initialized');
  });
});

describe('PuppeteerManager - HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ', () => {
  test('åŸºæœ¬HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒç”Ÿæˆã•ã‚Œã‚‹', () => {
    const manager = new PuppeteerManager();
    const html = manager.generateTestHTML(() => {});
    
    expect(html).toContain('<!DOCTYPE html>');
    expect(html).toContain('three.min.js');
    expect(html).toContain('<canvas');
    expect(html).toContain('id="three-canvas"');
  });

  test('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒæ³¨å…¥ã•ã‚Œã‚‹', () => {
    const manager = new PuppeteerManager();
    const userScript = () => { console.log('test'); };
    const html = manager.generateTestHTML(userScript);
    
    expect(html).toContain(userScript.toString());
  });

  test('ç”ŸæˆHTMLãŒãƒšãƒ¼ã‚¸ã«èª­ã¿è¾¼ã‚ã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const html = manager.generateTestHTML(() => {
      window.testValue = 'loaded';
    });
    
    await manager.page.setContent(html);
    
    const testValue = await manager.page.evaluate(() => window.testValue);
    expect(testValue).toBe('loaded');
    
    await manager.cleanup();
  });

  test('Three.js CDNãŒæ­£ã—ãèª­ã¿è¾¼ã¾ã‚Œã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const html = manager.generateTestHTML(() => {});
    await manager.page.setContent(html);
    
    // Three.jsãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…ã¤
    await manager.page.waitForFunction('typeof THREE !== "undefined"', { timeout: 5000 });
    
    const threeLoaded = await manager.page.evaluate(() => typeof THREE !== 'undefined');
    expect(threeLoaded).toBe(true);
    
    await manager.cleanup();
  });

  test('ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«ãŒè¨­å®šã•ã‚Œã‚‹', () => {
    const manager = new PuppeteerManager();
    const customTitle = 'Custom Three.js Test';
    const html = manager.generateTestHTML(() => {}, { title: customTitle });
    
    expect(html).toContain(`<title>${customTitle}</title>`);
  });

  test('ç•°ãªã‚‹Three.jsãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒæŒ‡å®šã§ãã‚‹', () => {
    const manager = new PuppeteerManager();
    const customVersion = 'r140';
    const html = manager.generateTestHTML(() => {}, { threeJsVersion: customVersion });
    
    expect(html).toContain(`/three.js/${customVersion}/three.min.js`);
  });

  test('è‡ªå‹•å®Ÿè¡Œã‚’ç„¡åŠ¹ã«ã§ãã‚‹', () => {
    const manager = new PuppeteerManager();
    const userScript = () => { console.log('test'); };
    const html = manager.generateTestHTML(userScript, { autoExecute: false });
    
    expect(html).toContain('window.userScript');
    expect(html).not.toContain('window.addEventListener(\'load\'');
  });

  test('ç„¡åŠ¹ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', () => {
    const manager = new PuppeteerManager();
    
    expect(() => {
      manager.generateTestHTML('not a function');
    }).toThrow('userScript must be a function');
    
    expect(() => {
      manager.generateTestHTML(null);
    }).toThrow('userScript must be a function');
    
    expect(() => {
      manager.generateTestHTML(undefined);
    }).toThrow('userScript must be a function');
  });

  test('ãƒ‡ãƒãƒƒã‚°æƒ…å ±è¦ç´ ãŒå«ã¾ã‚Œã‚‹', () => {
    const manager = new PuppeteerManager();
    const html = manager.generateTestHTML(() => {});
    
    expect(html).toContain('class="debug-info"');
    expect(html).toContain('id="debug-info"');
  });

  test('è¤‡é›‘ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒæ­£ã—ãæ³¨å…¥ã•ã‚Œã‚‹', async () => {
    const manager = new PuppeteerManager();
    await manager.initialize();
    
    const complexScript = () => {
      window.testObject = {
        value: 42,
        array: [1, 2, 3],
        method: function() { return 'method called'; }
      };
    };
    
    const html = manager.generateTestHTML(complexScript);
    await manager.page.setContent(html);
    
    const testObject = await manager.page.evaluate(() => window.testObject);
    expect(testObject.value).toBe(42);
    expect(testObject.array).toEqual([1, 2, 3]);
    
    const methodResult = await manager.page.evaluate(() => window.testObject.method());
    expect(methodResult).toBe('method called');
    
    await manager.cleanup();
  });
});
</file>

<file path="three-test-suite/src/PuppeteerManager.js">
import puppeteer from 'puppeteer';

/**
 * PuppeteerManager
 * Three.js ãƒ†ã‚¹ãƒˆç”¨ã®Puppeteerãƒ–ãƒ©ã‚¦ã‚¶ã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
 * WebGL ã¨ WebAssembly ä¸¡æ–¹ã®æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆ
 */
export class PuppeteerManager {
  /**
   * @param {Object} options - è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @param {boolean} options.headless - ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: true)
   * @param {number} options.width - ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¹… (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 1024)
   * @param {number} options.height - ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆé«˜ã• (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 768)
   * @param {string[]} options.args - Chromiumèµ·å‹•å¼•æ•°
   */
  constructor(options = {}) {
    this.options = {
      headless: true,
      width: 1024,
      height: 768,
      args: [
        '--enable-webgl',
        '--disable-web-security',
        '--allow-running-insecure-content',
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage'
      ],
      ...options
    };
    
    this.browser = null;
    this.page = null;
  }

  /**
   * Puppeteerãƒ–ãƒ©ã‚¦ã‚¶ã‚’åˆæœŸåŒ–ã™ã‚‹
   * @throws {Error} åˆæœŸåŒ–ã«å¤±æ•—ã—ãŸå ´åˆ
   */
  async initialize() {
    // æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (this.browser) {
      return;
    }

    try {
      this.browser = await puppeteer.launch({
        headless: this.options.headless,
        args: this.options.args
      });

      this.page = await this.browser.newPage();
      
      await this.page.setViewport({
        width: this.options.width,
        height: this.options.height
      });

    } catch (error) {
      throw new Error(`PuppeteerManager initialization failed: ${error.message}`);
    }
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶ã‚’çµ‚äº†ã—ã€ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹
   */
  async cleanup() {
    if (!this.browser) {
      return;
    }

    try {
      await this.browser.close();
      this.browser = null;
      this.page = null;
    } catch (error) {
      // ãƒ­ã‚°å‡ºåŠ›ã¯ã›ãšã€é™ã‹ã«å¤±æ•—ã•ã›ã‚‹
      console.warn(`Cleanup warning: ${error.message}`);
    }
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
   * @returns {boolean} åˆæœŸåŒ–çŠ¶æ…‹
   */
  isInitialized() {
    return this.browser !== null && this.page !== null;
  }

  /**
   * WebGLã®æƒ…å ±ã¨å¯¾å¿œçŠ¶æ³ã‚’å–å¾—ã™ã‚‹
   * @returns {Promise<WebGLInfo>} WebGLæƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @throws {Error} PuppeteerManagerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   * 
   * @typedef {Object} WebGLInfo
   * @property {boolean} webglSupported - WebGLã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} webgl2Supported - WebGL2ã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {string|null} vendor - WebGLãƒ™ãƒ³ãƒ€ãƒ¼æƒ…å ±
   * @property {string|null} renderer - ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼æƒ…å ±
   * @property {string|null} version - WebGLãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±
   */
  async getWebGLInfo() {
    this._validateInitialized();

    try {
      const webglInfo = await this.page.evaluate(this._getWebGLInfoInBrowser);
      return webglInfo;
    } catch (error) {
      throw new Error(`Failed to get WebGL info: ${error.message}`);
    }
  }

  /**
   * WebAssemblyã®æƒ…å ±ã¨å¯¾å¿œçŠ¶æ³ã‚’å–å¾—ã™ã‚‹
   * @returns {Promise<WebAssemblyInfo>} WebAssemblyæƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @throws {Error} PuppeteerManagerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   * 
   * @typedef {Object} WebAssemblyInfo
   * @property {boolean} wasmSupported - WebAssemblyåŸºæœ¬ã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} streamingSupported - ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} memorySupported - WebAssembly.Memoryã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} tableSupported - WebAssembly.Tableã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} globalSupported - WebAssembly.Globalã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} sharedMemorySupported - SharedArrayBuffer + WebAssemblyã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} simdSupported - WASM SIMDã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   */
  async getWebAssemblyInfo() {
    this._validateInitialized();

    try {
      const wasmInfo = await this.page.evaluate(this._getWebAssemblyInfoInBrowser);
      return wasmInfo;
    } catch (error) {
      throw new Error(`Failed to get WebAssembly info: ${error.message}`);
    }
  }

  /**
   * WebAssemblyã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹
   * CPUé›†ç´„çš„ãªå‡¦ç†æ€§èƒ½ã¨ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹æ€§èƒ½ã‚’æ¸¬å®š
   * @returns {Promise<WebAssemblyPerformance>} ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @throws {Error} PuppeteerManagerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   * 
   * @typedef {Object} WebAssemblyPerformance
   * @property {number} executionTime - å®Ÿè¡Œæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   * @property {number} operationsPerSecond - ç§’é–“æ¼”ç®—å›æ•°
   * @property {number} memoryPerformance - ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹æ€§èƒ½ï¼ˆæ“ä½œ/ç§’ï¼‰
   */
  async benchmarkWebAssembly() {
    this._validateInitialized();

    try {
      const performance = await this.page.evaluate(this._benchmarkWebAssemblyInBrowser);
      return performance;
    } catch (error) {
      throw new Error(`Failed to benchmark WebAssembly: ${error.message}`);
    }
  }

  /**
   * WebAssemblyã¨WebGLã®é€£æºæ©Ÿèƒ½æƒ…å ±ã‚’å–å¾—ã™ã‚‹
   * @returns {Promise<HybridCapabilities>} é€£æºæ©Ÿèƒ½æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @throws {Error} PuppeteerManagerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   * 
   * @typedef {Object} HybridCapabilities
   * @property {boolean} wasmSupported - WebAssemblyå¯¾å¿œçŠ¶æ³
   * @property {boolean} webglSupported - WebGLå¯¾å¿œçŠ¶æ³
   * @property {boolean} hybridReady - é€£æºæ©Ÿèƒ½æº–å‚™å®Œäº†
   * @property {Object} performanceProfile - æ€§èƒ½ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«
   * @property {number} performanceProfile.cpuScore - CPUæ€§èƒ½ã‚¹ã‚³ã‚¢
   * @property {number} performanceProfile.gpuScore - GPUæ€§èƒ½ã‚¹ã‚³ã‚¢
   * @property {number} performanceProfile.memoryBandwidth - ãƒ¡ãƒ¢ãƒªå¸¯åŸŸå¹…
   * @property {string} recommendedStrategy - æ¨å¥¨å‡¦ç†æˆ¦ç•¥
   */
  async getHybridCapabilities() {
    this._validateInitialized();

    try {
      const capabilities = await this.page.evaluate(this._getHybridCapabilitiesInBrowser);
      return capabilities;
    } catch (error) {
      throw new Error(`Failed to get hybrid capabilities: ${error.message}`);
    }
  }

  /**
   * WebAssemblyã¨WebGLã®é€£æºãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹
   * @param {Object} options - ãƒ†ã‚¹ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @param {number} options.dataSize - ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 5000)
   * @param {number} options.iterations - åå¾©å›æ•° (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 20)
   * @returns {Promise<HybridPerformance>} ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @throws {Error} PuppeteerManagerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   * 
   * @typedef {Object} HybridPerformance
   * @property {number} wasmComputeTime - WASMè¨ˆç®—æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   * @property {number} webglRenderTime - WebGLæç”»æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   * @property {number} dataTransferTime - ãƒ‡ãƒ¼ã‚¿è»¢é€æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   * @property {number} totalTime - ç·å®Ÿè¡Œæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   * @property {number} efficiency - å‡¦ç†åŠ¹ç‡ï¼ˆ0-1ï¼‰
   * @property {number} throughput - ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆï¼ˆãƒ‡ãƒ¼ã‚¿/ç§’ï¼‰
   */
  async benchmarkHybridPerformance(options = {}) {
    this._validateInitialized();

    try {
      const performance = await this.page.evaluate(this._benchmarkHybridPerformanceInBrowser, options);
      return performance;
    } catch (error) {
      throw new Error(`Failed to benchmark hybrid performance: ${error.message}`);
    }
  }

  /**
   * Three.jsç”¨ã®HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç”Ÿæˆã™ã‚‹
   * @param {Function} userScript - ãƒšãƒ¼ã‚¸ã«æ³¨å…¥ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
   * @param {Object} options - ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @param {string} options.title - ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ« (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 'Three.js Test Environment')
   * @param {string} options.threeJsVersion - Three.jsã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 'r128')
   * @param {boolean} options.autoExecute - ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®è‡ªå‹•å®Ÿè¡Œ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: true)
   * @returns {string} ç”Ÿæˆã•ã‚ŒãŸHTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
   * @throws {Error} ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒç„¡åŠ¹ãªå ´åˆ
   */
  generateTestHTML(userScript, options = {}) {
    // å¼•æ•°ã®æ¤œè¨¼
    if (typeof userScript !== 'function') {
      throw new Error('userScript must be a function');
    }

    const config = {
      title: 'Three.js Test Environment',
      threeJsVersion: 'r128',
      autoExecute: true,
      ...options
    };

    const userScriptString = userScript.toString();
    const threeJsUrl = `https://cdnjs.cloudflare.com/ajax/libs/three.js/${config.threeJsVersion}/three.min.js`;

    // ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œéƒ¨åˆ†ã‚’ç”Ÿæˆ
    const scriptExecution = config.autoExecute
      ? `
        // Wait for Three.js to load
        window.addEventListener('load', function() {
            // Execute user script
            (${userScriptString})();
        });`
      : `
        // User script is available but not auto-executed
        window.userScript = ${userScriptString};`;

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${config.title}</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #three-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="three-canvas"></canvas>
    <div class="debug-info" id="debug-info">
        Debug info will appear here
    </div>
    
    <!-- Three.js CDN -->
    <script src="${threeJsUrl}"></script>
    
    <!-- User Script -->
    <script>${scriptExecution}
    </script>
</body>
</html>`;
  }

  /**
   * åˆæœŸåŒ–çŠ¶æ…‹ã‚’æ¤œè¨¼ã™ã‚‹
   * @private
   * @throws {Error} åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   */
  _validateInitialized() {
    if (!this.isInitialized()) {
      throw new Error('PuppeteerManager is not initialized');
    }
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§WebGLæƒ…å ±ã‚’å–å¾—ã™ã‚‹é–¢æ•°
   * @private
   * @returns {WebGLInfo} WebGLæƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  _getWebGLInfoInBrowser() {
    // WebGLã‚µãƒãƒ¼ãƒˆç¢ºèª
    const canvas = document.createElement('canvas');
    const webglContext = canvas.getContext('webgl');
    const webgl2Context = canvas.getContext('webgl2');

    const result = {
      webglSupported: webglContext !== null,
      webgl2Supported: webgl2Context !== null,
      vendor: null,
      renderer: null,
      version: null
    };

    // WebGLåŸºæœ¬æƒ…å ±ã‚’å–å¾—
    if (webglContext) {
      result.vendor = webglContext.getParameter(webglContext.VENDOR);
      result.renderer = webglContext.getParameter(webglContext.RENDERER);
      result.version = webglContext.getParameter(webglContext.VERSION);
    }

    return result;
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§WebAssemblyæƒ…å ±ã‚’å–å¾—ã™ã‚‹é–¢æ•°
   * å„ç¨®WebAssemblyæ©Ÿèƒ½ã®å¯¾å¿œçŠ¶æ³ã‚’è©³ç´°ã«ç¢ºèª
   * @private
   * @returns {WebAssemblyInfo} WebAssemblyæƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  _getWebAssemblyInfoInBrowser() {
    const result = {
      wasmSupported: false,
      streamingSupported: false,
      memorySupported: false,
      tableSupported: false,
      globalSupported: false,
      sharedMemorySupported: false,
      simdSupported: false
    };

    // WebAssemblyåŸºæœ¬ã‚µãƒãƒ¼ãƒˆç¢ºèª
    if (typeof WebAssembly !== 'undefined') {
      result.wasmSupported = true;
      
      // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚µãƒãƒ¼ãƒˆç¢ºèª
      result.streamingSupported = typeof WebAssembly.compileStreaming === 'function' &&
                                  typeof WebAssembly.instantiateStreaming === 'function';
      
      // Memory, Table, Globalã‚µãƒãƒ¼ãƒˆç¢ºèª
      result.memorySupported = typeof WebAssembly.Memory === 'function';
      result.tableSupported = typeof WebAssembly.Table === 'function';
      result.globalSupported = typeof WebAssembly.Global === 'function';
      
      // SharedMemoryã‚µãƒãƒ¼ãƒˆç¢ºèª
      // SecurityErrorå¯¾ç­–ã®ãŸã‚try-catchã§å›²ã‚€
      try {
        result.sharedMemorySupported = typeof SharedArrayBuffer !== 'undefined' && 
                                      result.memorySupported;
        
        // ã•ã‚‰ã«è©³ç´°ãªç¢ºèª: å®Ÿéš›ã«SharedMemoryãŒä½œæˆå¯èƒ½ã‹
        if (result.sharedMemorySupported) {
          try {
            const testMemory = new WebAssembly.Memory({ 
              initial: 1, 
              maximum: 1, 
              shared: true 
            });
            // æ­£å¸¸ã«ä½œæˆã§ãã‚Œã°trueã€ãã†ã§ãªã‘ã‚Œã°false
            result.sharedMemorySupported = testMemory.buffer instanceof SharedArrayBuffer;
          } catch (e) {
            result.sharedMemorySupported = false;
          }
        }
      } catch (e) {
        result.sharedMemorySupported = false;
      }
      
      // SIMDå¯¾å¿œç¢ºèªï¼ˆå°†æ¥æ‹¡å¼µç”¨ï¼‰
      // ç¾åœ¨ã¯åŸºæœ¬çš„ãªæ¤œæŸ»ã®ã¿ã€‚å®Ÿéš›ã®SIMDå‘½ä»¤ã‚»ãƒƒãƒˆå¯¾å¿œç¢ºèªã¯è¤‡é›‘
      result.simdSupported = false; // ç¾åœ¨ã¯å¸¸ã«falseï¼ˆå°†æ¥ã®æ‹¡å¼µã«å‚™ãˆã¦ï¼‰
    }

    return result;
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§WebAssemblyãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°
   * æ•°å€¤è¨ˆç®—ã¨ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹ã®ä¸¡æ–¹ã®æ€§èƒ½ã‚’æ¸¬å®š
   * @private
   * @returns {Promise<WebAssemblyPerformance>} ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  _benchmarkWebAssemblyInBrowser() {
    if (typeof WebAssembly === 'undefined') {
      throw new Error('WebAssembly is not supported');
    }

    // ç°¡å˜ãªWASMãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆaddTwoé–¢æ•°: 2ã¤ã®æ•°å€¤ã‚’åŠ ç®—ï¼‰
    // WAT (WebAssembly Text format): 
    // (module
    //   (func $addTwo (param $p1 i32) (param $p2 i32) (result i32)
    //     local.get $p1
    //     local.get $p2
    //     i32.add)
    //   (export "addTwo" (func $addTwo)))
    const wasmBytes = new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01,
      0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x0a, 0x01, 0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6f, 0x00,
      0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b
    ]);

    return WebAssembly.instantiate(wasmBytes)
      .then(result => {
        const addTwo = result.instance.exports.addTwo;
        
        // CPUé›†ç´„çš„å‡¦ç†ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
        const startTime = performance.now();
        const iterations = 100000;
        
        for (let i = 0; i < iterations; i++) {
          addTwo(i, i + 1);
        }
        
        const endTime = performance.now();
        const executionTime = endTime - startTime;
        const operationsPerSecond = Math.round((iterations / executionTime) * 1000);
        
        // ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹æ€§èƒ½ãƒ†ã‚¹ãƒˆ
        const memoryStartTime = performance.now();
        let memoryPerformance = 0;
        
        try {
          const memory = new WebAssembly.Memory({ initial: 1 });
          const buffer = new Uint32Array(memory.buffer);
          const memoryOperations = 1000;
          
          for (let i = 0; i < memoryOperations; i++) {
            buffer[i] = i;
          }
          
          const memoryEndTime = performance.now();
          const memoryTime = memoryEndTime - memoryStartTime;
          memoryPerformance = Math.round((memoryOperations / memoryTime) * 1000);
        } catch (e) {
          // ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ãŸå ´åˆã¯0ã‚’è¿”ã™
          memoryPerformance = 0;
        }
        
        return {
          executionTime: Math.round(executionTime * 100) / 100, // å°æ•°ç‚¹ä»¥ä¸‹2æ¡ã«ä¸¸ã‚ã‚‹
          operationsPerSecond: operationsPerSecond,
          memoryPerformance: memoryPerformance
        };
      })
      .catch(error => {
        throw new Error(`WebAssembly benchmark failed: ${error.message}`);
      });
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§WebAssemblyã¨WebGLã®é€£æºæ©Ÿèƒ½æƒ…å ±ã‚’å–å¾—ã™ã‚‹é–¢æ•°
   * @private
   * @returns {HybridCapabilities} é€£æºæ©Ÿèƒ½æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  _getHybridCapabilitiesInBrowser() {
    // WebAssemblyå¯¾å¿œç¢ºèª
    const wasmSupported = typeof WebAssembly !== 'undefined';
    
    // WebGLå¯¾å¿œç¢ºèª
    const canvas = document.createElement('canvas');
    const webglContext = canvas.getContext('webgl');
    const webglSupported = webglContext !== null;
    
    // é€£æºæ©Ÿèƒ½æº–å‚™å®Œäº†åˆ¤å®š
    const hybridReady = wasmSupported && webglSupported;
    
    // æ€§èƒ½ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨ˆç®—
    let cpuScore = 0;
    let gpuScore = 0;
    let memoryBandwidth = 0;
    
    if (wasmSupported) {
      // ç°¡æ˜“CPUæ€§èƒ½ã‚¹ã‚³ã‚¢ç®—å‡º
      const startTime = performance.now();
      let sum = 0;
      for (let i = 0; i < 100000; i++) {
        sum += i * 2;
      }
      const endTime = performance.now();
      cpuScore = Math.round(100000 / (endTime - startTime));
    }
    
    if (webglSupported) {
      // ç°¡æ˜“GPUæ€§èƒ½ã‚¹ã‚³ã‚¢ç®—å‡ºï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºãƒ™ãƒ¼ã‚¹ï¼‰
      const maxTextureSize = webglContext.getParameter(webglContext.MAX_TEXTURE_SIZE);
      gpuScore = Math.min(maxTextureSize / 1024, 100); // æœ€å¤§100ç‚¹
      
      // ãƒ¡ãƒ¢ãƒªå¸¯åŸŸå¹…æ¨å®šï¼ˆç°¡æ˜“è¨ˆç®—ï¼‰
      const maxViewportDims = webglContext.getParameter(webglContext.MAX_VIEWPORT_DIMS);
      memoryBandwidth = Math.round((maxViewportDims[0] * maxViewportDims[1]) / 1000000); // MB/sæ¨å®š
    }
    
    // æ¨å¥¨å‡¦ç†æˆ¦ç•¥ã®æ±ºå®š
    let recommendedStrategy = 'cpu-only';
    if (hybridReady) {
      if (cpuScore > 50000 && gpuScore > 50) {
        recommendedStrategy = 'balanced-hybrid';
      } else if (cpuScore > 50000) {
        recommendedStrategy = 'cpu-heavy';
      } else if (gpuScore > 50) {
        recommendedStrategy = 'gpu-heavy';
      } else {
        recommendedStrategy = 'simple-hybrid';
      }
    } else if (webglSupported) {
      recommendedStrategy = 'gpu-only';
    }
    
    return {
      wasmSupported,
      webglSupported,
      hybridReady,
      performanceProfile: {
        cpuScore,
        gpuScore,
        memoryBandwidth
      },
      recommendedStrategy
    };
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§WebAssemblyã¨WebGLã®é€£æºãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°
   * @private
   * @param {Object} options - ãƒ†ã‚¹ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @returns {Promise<HybridPerformance>} ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  _benchmarkHybridPerformanceInBrowser(options) {
    const config = {
      dataSize: 5000,    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’1000ã‹ã‚‰5000ã«å¢—åŠ 
      iterations: 20,    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’10ã‹ã‚‰20ã«å¢—åŠ 
      ...options
    };

    if (typeof WebAssembly === 'undefined') {
      throw new Error('WebAssembly is not supported');
    }

    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl');
    if (!gl) {
      throw new Error('WebGL is not supported');
    }

    // WASMãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆãƒ‡ãƒ¼ã‚¿å‡¦ç†ç”¨ï¼‰
    const wasmBytes = new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01,
      0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x0a, 0x01, 0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6f, 0x00,
      0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b
    ]);

    return WebAssembly.instantiate(wasmBytes)
      .then(result => {
        const addTwo = result.instance.exports.addTwo;
        
        const totalStartTime = performance.now();
        
        let totalWasmTime = 0;
        let totalWebglTime = 0;
        let totalDataTransferTime = 0;
        
        for (let iter = 0; iter < config.iterations; iter++) {
          // WASMè¨ˆç®—ãƒ•ã‚§ãƒ¼ã‚º
          const wasmStartTime = performance.now();
          const vertices = [];
          for (let i = 0; i < config.dataSize; i++) {
            vertices.push(addTwo(i % 100, (i + 1) % 100));
          }
          const wasmEndTime = performance.now();
          totalWasmTime += (wasmEndTime - wasmStartTime);
          
          // ãƒ‡ãƒ¼ã‚¿è»¢é€ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆã‚ˆã‚Šå¤§ããªãƒ‡ãƒ¼ã‚¿ã§æ¸¬å®šç²¾åº¦å‘ä¸Šï¼‰
          const transferStartTime = performance.now();
          
          // ã‚ˆã‚Šè¤‡é›‘ãªãƒ‡ãƒ¼ã‚¿è»¢é€å‡¦ç†ã‚’è¿½åŠ 
          const largeVertexData = new Float32Array(vertices.length * 3); // x, y, z coordinates
          for (let i = 0; i < vertices.length; i++) {
            largeVertexData[i * 3] = vertices[i];
            largeVertexData[i * 3 + 1] = vertices[i] + 1;
            largeVertexData[i * 3 + 2] = vertices[i] + 2;
          }
          
          // è¿½åŠ ã®é…åˆ—å¤‰æ›å‡¦ç†ã§ãƒ‡ãƒ¼ã‚¿è»¢é€æ™‚é–“ã‚’ç¢ºå®Ÿã«æ¸¬å®š
          const normalData = new Float32Array(largeVertexData.length);
          for (let i = 0; i < largeVertexData.length; i++) {
            normalData[i] = largeVertexData[i] / Math.max(1, Math.abs(largeVertexData[i]));
          }
          
          const transferEndTime = performance.now();
          const transferTime = transferEndTime - transferStartTime;
          totalDataTransferTime += Math.max(transferTime, 0.01); // æœ€å°0.01msä¿è¨¼
          
          // WebGLæç”»ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆå‡¦ç†ã‚’é‡ãã—ã¦æ¸¬å®šå¯èƒ½ã«ã™ã‚‹ï¼‰
          const webglStartTime = performance.now();
          
          // è¤‡æ•°ã®ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã—ã¦å‡¦ç†ã‚’é‡ãã™ã‚‹
          const buffers = [];
          for (let bufIdx = 0; bufIdx < 5; bufIdx++) {
            const buffer = gl.createBuffer();
            buffers.push(buffer);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, largeVertexData, gl.STATIC_DRAW);
            
            // è¿½åŠ ã® WebGL æ“ä½œ
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.viewport(0, 0, 100, 100);
          }
          
          const webglEndTime = performance.now();
          const webglTime = webglEndTime - webglStartTime;
          totalWebglTime += Math.max(webglTime, 0.01); // æœ€å°0.01msä¿è¨¼
          
          // ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          buffers.forEach(buffer => gl.deleteBuffer(buffer));
        }
        
        const totalEndTime = performance.now();
        const totalTime = totalEndTime - totalStartTime;
        
        // å¹³å‡æ™‚é–“è¨ˆç®—
        const wasmComputeTime = Math.round((totalWasmTime / config.iterations) * 100) / 100;
        const webglRenderTime = Math.round((totalWebglTime / config.iterations) * 100) / 100;
        const dataTransferTime = Math.round((totalDataTransferTime / config.iterations) * 100) / 100;
        
        // åŠ¹ç‡è¨ˆç®—ï¼ˆç†æƒ³çš„ãªä¸¦åˆ—å‡¦ç†ã«å¯¾ã™ã‚‹å®Ÿéš›ã®æ€§èƒ½æ¯”ï¼‰
        const idealTime = Math.max(wasmComputeTime, webglRenderTime);
        const actualTime = wasmComputeTime + dataTransferTime + webglRenderTime;
        const efficiency = Math.min(idealTime / actualTime, 1.0);
        
        // ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆè¨ˆç®—ï¼ˆãƒ‡ãƒ¼ã‚¿/ç§’ï¼‰
        const throughput = Math.round((config.dataSize * config.iterations * 1000) / totalTime);
        
        return {
          wasmComputeTime,
          webglRenderTime,
          dataTransferTime,
          totalTime: Math.round(totalTime * 100) / 100,
          efficiency: Math.round(efficiency * 1000) / 1000,
          throughput
        };
      })
      .catch(error => {
        throw new Error(`Hybrid performance benchmark failed: ${error.message}`);
      });
  }
}
</file>

</files>
