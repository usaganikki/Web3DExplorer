This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__tests__/
  .gitkeep
  GISManager.test.ts
.github/
  workflows/
    ci.yml
src/
  components/
    TokyoStationExplorer.tsx
    Web3DExplorerComponent.tsx
  core/
    Explorer.ts
  gis/
    GISManager.ts
  types/
    gis.ts
    index.ts
    testing.ts
  utils/
    EventEmitter.ts
  .gitkeep
  index.ts
three-test-suite/
  __tests__/
    integration/
      TestPatterns.test.js
    performance/
      PerformanceTester.test.js
    unit/
      BrowserManager.test.js
      EnvironmentInspector.test.js
      HTMLGenerator.test.js
      PuppeteerManager.test.js
      SceneInspector.test.js
      TestUtils.test.js
      ThreeTestSuite.test.js
  docs/
    design-philosophy.md
    quick-start.md
  src/
    mocks/
      MockBrowserManager.js
      MockWebGL.js
    threejs/
      SceneInspector.js
      ThreeTestSuite.js
    utils/
      TestDataGenerator.js
      TestIsolationHelper.js
      TestUtils.js
    BrowserManager.js
    EnvironmentInspector.js
    HTMLGenerator.js
    PerformanceTester.js
    PuppeteerManager.js
  jest.config.js
  jest.setup.js
  package.json
  README.md
.eslintrc.js
.gitignore
.prettierrc
CHANGELOG.md
jest.config.js
jest.setup.js
LICENSE
package.json
README.md
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__tests__/.gitkeep">
# ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
</file>

<file path="src/types/testing.ts">
import * as THREE from 'three';
import { Web3DExplorer, PerformanceMetrics } from './index';

// ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å°‚ç”¨ã®å‹å®šç¾©

// ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç’°å¢ƒ
export interface TestEnvironment {
  browser: 'chrome' | 'firefox' | 'safari' | 'edge';
  viewport: {
    width: number;
    height: number;
  };
  webgl: {
    version: '1' | '2';
    extensions: string[];
  };
  capabilities: {
    maxTextureSize: number;
    maxRenderBufferSize: number;
    maxVertexAttributes: number;
  };
}

// ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«å›å¸°ãƒ†ã‚¹ãƒˆ
export interface VisualTest {
  name: string;
  description: string;
  referenceImage: string;
  threshold: number; // è¨±å®¹å·®ï¼ˆ0-1ï¼‰
  setup: (explorer: Web3DExplorer) => Promise<void>;
  capture: () => Promise<HTMLCanvasElement>;
}

// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
export interface PerformanceTest {
  name: string;
  description: string;
  duration: number; // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ™‚é–“ï¼ˆç§’ï¼‰
  expectations: {
    minFPS: number;
    maxFrameTime: number;
    maxMemoryUsage: number;
  };
  setup: (explorer: Web3DExplorer) => Promise<void>;
  execute: (explorer: Web3DExplorer) => Promise<PerformanceMetrics[]>;
}

// ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
export interface InteractionTest {
  name: string;
  description: string;
  interactions: {
    type: 'click' | 'hover' | 'drag' | 'wheel' | 'keyboard';
    target?: string; // ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã¾ãŸã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå
    coordinates?: { x: number; y: number };
    keys?: string[];
    duration?: number;
  }[];
  expectations: {
    expectedEvents: string[];
    expectedChanges: Record<string, any>;
  };
  setup: (explorer: Web3DExplorer) => Promise<void>;
  verify: (explorer: Web3DExplorer, results: any[]) => boolean;
}

// å˜ä½“ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯
export interface MockScene {
  scene: THREE.Scene;
  camera: THREE.PerspectiveCamera;
  renderer: THREE.WebGLRenderer;
  canvas: HTMLCanvasElement;
}

export interface MockObjects {
  cube: THREE.Mesh;
  sphere: THREE.Mesh;
  plane: THREE.Mesh;
  light: THREE.DirectionalLight;
  group: THREE.Group;
}

// ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã®è¨­å®š
export interface TestSuiteConfig {
  name: string;
  description: string;
  environment: TestEnvironment;
  timeout: number;
  retries: number;
  parallel: boolean;
  headless: boolean;
  outputDir: string;
  
  // ãƒ†ã‚¹ãƒˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
  only?: string[]; // å®Ÿè¡Œã™ã‚‹ãƒ†ã‚¹ãƒˆã®ã¿
  skip?: string[]; // ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ãƒ†ã‚¹ãƒˆ
  tags?: string[]; // ãƒ†ã‚¹ãƒˆã‚¿ã‚°ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
}

// ãƒ†ã‚¹ãƒˆçµæœ
export interface TestResult {
  name: string;
  status: 'passed' | 'failed' | 'skipped' | 'timeout';
  duration: number;
  error?: Error;
  metrics?: PerformanceMetrics;
  screenshot?: string;
  artifacts?: {
    logs: string[];
    traces: any[];
    recordings: string[];
  };
}

export interface TestSuiteResult {
  name: string;
  status: 'passed' | 'failed' | 'partial';
  startTime: Date;
  endTime: Date;
  duration: number;
  results: TestResult[];
  summary: {
    total: number;
    passed: number;
    failed: number;
    skipped: number;
  };
  coverage?: {
    lines: number;
    functions: number;
    branches: number;
    statements: number;
  };
}

// Three.jså°‚ç”¨ã®ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
export interface ThreeTestUtils {
  // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¤œè¨¼
  expectObject3D(object: THREE.Object3D): {
    toBeVisible(): void;
    toHavePosition(position: THREE.Vector3): void;
    toHaveRotation(rotation: THREE.Euler): void;
    toHaveScale(scale: THREE.Vector3): void;
    toBeInFrustum(camera: THREE.Camera): void;
  };
  
  // ãƒãƒ†ãƒªã‚¢ãƒ«æ¤œè¨¼
  expectMaterial(material: THREE.Material): {
    toBeTransparent(): void;
    toHaveColor(color: THREE.Color): void;
    toHaveTexture(texture: THREE.Texture): void;
  };
  
  // ã‚¸ã‚ªãƒ¡ãƒˆãƒªæ¤œè¨¼
  expectGeometry(geometry: THREE.BufferGeometry): {
    toHaveVertices(count: number): void;
    toHaveFaces(count: number): void;
    toHaveBoundingBox(box: THREE.Box3): void;
  };
  
  // ã‚·ãƒ¼ãƒ³æ¤œè¨¼
  expectScene(scene: THREE.Scene): {
    toContainObject(object: THREE.Object3D): void;
    toHaveObjectCount(count: number): void;
    toHaveLights(count: number): void;
  };
  
  // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ¤œè¨¼
  expectRenderer(renderer: THREE.WebGLRenderer): {
    toRenderWithoutErrors(): Promise<void>;
    toMatchImage(reference: string, threshold?: number): Promise<void>;
    toHavePerformance(metrics: Partial<PerformanceMetrics>): void;
  };
}

// Puppeteerçµ±åˆç”¨ã®å‹
export interface BrowserTestConfig {
  headless: boolean;
  viewport: { width: number; height: number };
  deviceScaleFactor?: number;
  userAgent?: string;
  timeout: number;
  slowMo?: number;
}

export interface BrowserTestContext {
  page: any; // Puppeteer.Page
  browser: any; // Puppeteer.Browser
  screenshot: (path: string) => Promise<void>;
  evaluate: <T>(fn: () => T) => Promise<T>;
  waitFor: (selector: string | number) => Promise<void>;
}

// ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼
export interface TestDataGenerator {
  generateMesh: (type: 'box' | 'sphere' | 'plane') => THREE.Mesh;
  generateScene: (complexity: 'simple' | 'medium' | 'complex') => THREE.Scene;
  generateTexture: (width: number, height: number) => THREE.Texture;
  generateMaterial: (type: 'basic' | 'standard' | 'physical') => THREE.Material;
}

// ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³æ‹¡å¼µ
declare global {
  namespace jest {
    interface Matchers<R> {
      toBeVisible(): R;
      toHavePosition(position: THREE.Vector3): R;
      toHaveRotation(rotation: THREE.Euler): R;
      toHaveScale(scale: THREE.Vector3): R;
      toBeInFrustum(camera: THREE.Camera): R;
      toRenderWithoutErrors(): Promise<R>;
      toMatchImage(reference: string, threshold?: number): Promise<R>;
      toHavePerformance(metrics: Partial<PerformanceMetrics>): R;
    }
  }
}
</file>

<file path="src/.gitkeep">
# ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
</file>

<file path=".eslintrc.js">
export default {
  env: {
    browser: true,
    es2021: true,
    node: true,
    jest: true
  },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended'
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true
    },
    project: './tsconfig.json'
  },
  plugins: [
    '@typescript-eslint'
  ],
  settings: {
    react: {
      version: 'detect'
    }
  },
  rules: {
    'no-unused-vars': 'off',
    '@typescript-eslint/no-unused-vars': 'warn',
    'no-console': 'warn',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/prefer-const': 'error',
    '@typescript-eslint/no-non-null-assertion': 'warn'
  },
  overrides: [
    {
      files: ['**/*.test.ts', '**/*.test.tsx', '**/__tests__/**/*'],
      rules: {
        '@typescript-eslint/explicit-function-return-type': 'off',
        '@typescript-eslint/no-explicit-any': 'off'
      }
    }
  ]
};
</file>

<file path=".prettierrc">
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2
}
</file>

<file path="jest.setup.js">
// Jest setup file
// Three.jsã®ãƒ¢ãƒƒã‚¯è¨­å®šãªã©ã‚’ã“ã“ã«è¿½åŠ 
</file>

<file path="src/components/Web3DExplorerComponent.tsx">
import React from 'react';
import { Web3DExplorerConfig, PerformanceMetrics } from '../types'; // Import types directly
import Explorer from '../core/Explorer'; // Import Explorer directly (default import)

export interface Web3DExplorerComponentProps {
  config?: Web3DExplorerConfig;
  initialData?: any;
  onExplorerReady?: (explorer: Explorer) => void;
  onPerformanceUpdate?: (metrics: PerformanceMetrics) => void;
  style?: React.CSSProperties;
  className?: string;
}

export const Web3DExplorerComponent: React.FC<Web3DExplorerComponentProps> = ({ config, initialData, onExplorerReady, onPerformanceUpdate, style, className }) => {
  // TODO: Implement Web3DExplorerComponent
  return (
    <div>
      <h1>Web3D Explorer Component</h1>
      <p>Content goes here.</p>
      {initialData && <pre>{JSON.stringify(initialData, null, 2)}</pre>}
    </div>
  );
};

export default Web3DExplorerComponent;
</file>

<file path="src/gis/GISManager.ts">
import { BuildingData, RoadData, POIData, TerrainData, GISLayer, TOKYO_PROJECTION } from '../types/gis';
import { GeoCoordinates } from '../types'; // Assuming GeoCoordinates is in ../types/index.ts

export class GISManager {
  private projection: TOKYO_PROJECTION | string;
  private layers: Map<string, GISLayer> = new Map();

  constructor(projection?: TOKYO_PROJECTION | string) {
    this.projection = projection || 'EPSG:4326'; // Default projection
    // TODO: Implement GISManager initialization
  }

  public geoToWorld(geoCoords: GeoCoordinates): { x: number; y: number; z: number } {
    // TODO: Implement geographic to world coordinate conversion
    console.log('geoToWorld called with:', geoCoords, 'using projection:', this.projection);
    // Placeholder implementation
    return { x: geoCoords.longitude, y: geoCoords.latitude, z: geoCoords.altitude || 0 };
  }

  public worldToGeo(worldCoords: { x: number; y: number; z?: number }): GeoCoordinates {
    // TODO: Implement world to geographic coordinate conversion
    console.log('worldToGeo called with:', worldCoords, 'using projection:', this.projection);
    // Placeholder implementation
    return { longitude: worldCoords.x, latitude: worldCoords.y, altitude: worldCoords.z || 0 };
  }

  public createTerrain(terrainData: TerrainData): any { // THREE.Mesh | null
    // TODO: Implement terrain creation
    console.log('createTerrain called with:', terrainData);
    return null; // Placeholder
  }

  public createBuilding(buildingData: BuildingData): any { // THREE.Mesh | null
    // TODO: Implement building creation
    console.log('createBuilding called with:', buildingData);
    return null; // Placeholder
  }

  public createRoad(roadData: RoadData): any { // THREE.Line | null
    // TODO: Implement road creation
    console.log('createRoad called with:', roadData);
    return null; // Placeholder
  }

  public createPOI(poiData: POIData): any { // THREE.Sprite | THREE.Mesh | null
    // TODO: Implement POI creation
    console.log('createPOI called with:', poiData);
    return null; // Placeholder
  }

  public addLayer(layer: GISLayer): void {
    // TODO: Implement add layer
    this.layers.set(layer.id, layer);
    console.log('addLayer called with:', layer);
  }

  public getLayer(layerId: string): GISLayer | undefined {
    // TODO: Implement get layer
    console.log('getLayer called for:', layerId);
    return this.layers.get(layerId);
  }

  public removeLayer(layerId: string): boolean {
    // TODO: Implement remove layer
    console.log('removeLayer called for:', layerId);
    return this.layers.delete(layerId);
  }

  public toggleLayer(layerId: string): boolean {
    // TODO: Implement toggle layer visibility
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.visible = !layer.visible;
      console.log(`Layer ${layerId} visibility toggled to: ${layer.visible}`);
      return true;
    }
    console.log(`Layer ${layerId} not found for toggling.`);
    return false;
  }

  // Add other GIS related methods here
}
</file>

<file path="src/types/gis.ts">
import { GeoCoordinates } from './index'; // Assuming GeoCoordinates is in index.ts

export type TOKYO_PROJECTION = string; // Placeholder type, could be an enum or a more specific type

export interface TokyoStationArea {
    station: BuildingData;
    nearbyBuildings: BuildingData[];
    roads: RoadData[];
    exits: POIData[];
    terrain: TerrainData;
    platforms?: any[]; // Added platforms
    concourse?: any[]; // Added concourse
}

export interface BuildingData {
  id: string;
  name?: string;
  coordinates: GeoCoordinates | GeoCoordinates[] | GeoCoordinates[][] | number[][][] | { latitude: number; longitude: number; altitude?: number } | { latitude: number; longitude: number; altitude?: number }[];
  properties?: Record<string, any>;
  height?: number;
  footprint?: GeoCoordinates[]; // Added based on error TS2353
  // Add other BuildingData properties
}

export interface RoadData {
  id: string;
  name?: string;
  coordinates: GeoCoordinates[] | number[][] | { latitude: number; longitude: number }[];
  properties?: Record<string, any>;
  type?: string;
  width?: number; // Added based on error TS2353
  // Add other RoadData properties
}

export interface POIData {
  id: string;
  name?: string;
  type?: string;
  // coordinate field is correct as per definition, test code uses 'coordinates'
  coordinate: GeoCoordinates | [number, number] | { latitude: number; longitude: number };
  properties?: Record<string, any>;
  // Add other POIData properties
}

export interface TerrainData {
  id: string;
  sourceUrl?: string; // Made optional as some test data might not have it
  width?: number;
  height?: number;
  resolution?: number;
  data?: Float32Array | any;
  bounds?: { min: GeoCoordinates; max: GeoCoordinates; }; // Added based on error TS2353
  // Add other TerrainData properties
}

// Add other GIS related types here
// Example Layer type
export interface GISLayer {
    id: string;
    name: string;
    // type "buildings" will be corrected in test file to "building"
    type: 'building' | 'road' | 'poi' | 'terrain' | 'custom';
    data: BuildingData[] | RoadData[] | POIData[] | TerrainData[] | any[];
    visible: boolean;
    style?: any; // Style information for rendering
}
</file>

<file path="src/types/index.ts">
// Generic Event Handler Type
export type EventHandler<T = any> = (data: T) => void;

export interface GeoCoordinates {
  latitude: number;
  longitude: number;
  altitude?: number;
}

export interface Object3DConfig {
  position?: { x: number; y: number; z: number }; // Changed to object
  rotation?: { x: number; y: number; z: number }; // Changed to object
  scale?: { x: number; y: number; z: number };    // Changed to object
  visible?: boolean;
  name?: string; // Added name property
  [key: string]: any; // Allow other properties
}

import * as THREE from 'three'; // Import THREE for ColorRepresentation

// Configuration for the Web3DExplorer
export interface Web3DExplorerConfig {
  containerId?: string;
  backgroundColor?: THREE.ColorRepresentation;
  enableControls?: boolean;
  debug?: boolean;
  scene?: {
    background?: THREE.ColorRepresentation; // Added background to scene config
    fog?: { // Added fog to scene config
        type: 'linear' | 'exponential';
        color: THREE.ColorRepresentation;
        near?: number;
        far?: number;
        density?: number;
    };
    ambientLight?: { color?: THREE.ColorRepresentation; intensity?: number };
    [key: string]: any; // Allow other scene properties
  };
  camera?: {
    fov?: number;
    aspect?: number;
    near?: number;
    far?: number;
    position?: { x: number; y: number; z: number }; // Changed to object
    target?: { x: number; y: number; z: number };   // Changed to object
    [key: string]: any; // Allow other camera properties
  };
  renderer?: {
    canvas?: HTMLCanvasElement; // Added canvas for renderer
    antialias?: boolean;
    alpha?: boolean;
    preserveDrawingBuffer?: boolean; // Added preserveDrawingBuffer
    powerPreference?: 'default' | 'high-performance' | 'low-power';
    stencil?: boolean;
    depth?: boolean;
    logarithmicDepthBuffer?: boolean;
    // antialias and alpha were duplicated, removed from here
    pixelRatio?: number;
    [key: string]: any; // Allow other renderer properties
  };
  lights?: LightConfig[]; // Use a more specific type for light configurations
  performance?: { // Added based on error TS2353
    enableStats?: boolean;
    maxFPS?: number;
    adaptiveQuality?: boolean;
  };
  // Add other configuration options here
}

export type LightType = 'ambient' | 'directional' | 'point' | 'spot' | 'hemisphere';

export interface LightConfig {
    type: LightType;
    color?: THREE.ColorRepresentation;
    intensity?: number;
    position?: { x: number; y: number; z: number };
    target?: { x: number; y: number; z: number }; // For spot/directional lights
    angle?: number; // For spot lights
    penumbra?: number; // For spot lights
    decay?: number; // For point/spot lights
    distance?: number; // For point/spot lights
    castShadow?: boolean;
    groundColor?: THREE.ColorRepresentation; // For hemisphere lights
    [key: string]: any;
}


// Performance Metrics
export interface PerformanceMetrics {
  fps: number;
  memoryUsage: { // Fixed to object type
    geometries: number;
    textures: number;
    total: number; // in MB
  };
  drawCalls: number;
  triangles: number; // Made mandatory
  frameTime?: number;
  renderTime?: number;
  triangleCount?: number; // Kept as optional, can be an alias or specific
  // Add other relevant metrics
}

// Placeholder for Web3DExplorer class/interface
export interface Web3DExplorer {
  // TODO: Define methods and properties of the explorer instance
  scene: any; // THREE.Scene;
  camera: any; // THREE.PerspectiveCamera;
  renderer: any; // THREE.WebGLRenderer;
  dispose: () => void;
  // Add other methods like render, resize, addObject, etc.
}


// Re-export other types if necessary, for example:
// export * from './gis'; // If you want to re-export all types from gis.ts
</file>

<file path="src/utils/EventEmitter.ts">
import { EventHandler } from '../types';

/**
 * ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¤ãƒ™ãƒ³ãƒˆã‚¨ãƒŸãƒƒã‚¿ãƒ¼å®Ÿè£…
 */
export class EventEmitter {
  private events: Map<string, EventHandler[]> = new Map();

  public on<T>(event: string, handler: EventHandler<T>): void {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(handler as EventHandler);
  }

  public off<T>(event: string, handler: EventHandler<T>): void {
    const handlers = this.events.get(event);
    if (handlers) {
      const index = handlers.indexOf(handler as EventHandler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  public emit<T>(event: string, data?: T): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Error in event handler for '${event}':`, error);
        }
      });
    }
  }

  public removeAllListeners(event?: string): void {
    if (event) {
      this.events.delete(event);
    } else {
      this.events.clear();
    }
  }

  public listenerCount(event: string): number {
    const handlers = this.events.get(event);
    return handlers ? handlers.length : 0;
  }

  public eventNames(): string[] {
    return Array.from(this.events.keys());
  }
}
</file>

<file path="three-test-suite/__tests__/integration/TestPatterns.test.js">
import { TestUtils, TestPatterns } from '../../src/utils/TestUtils.js';
import { HTMLGenerator } from '../../src/HTMLGenerator.js';

describe('TestPatterns - çµ±åˆãƒ†ã‚¹ãƒˆ', () => {
  describe('withBrowserManager', () => {
    test('BrowserManagerã‚’ä½¿ç”¨ã™ã‚‹ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³', async () => {
      let testExecuted = false;
      let receivedBrowserManager = null;
      let receivedPage = null;

      await TestPatterns.withBrowserManager(async (browserManager, page) => {
        testExecuted = true;
        receivedBrowserManager = browserManager;
        receivedPage = page;

        expect(browserManager).toBeDefined();
        expect(browserManager.isInitialized()).toBe(true);
        expect(page).toBeDefined();
      });

      expect(testExecuted).toBe(true);
      expect(receivedBrowserManager).not.toBeNull();
      expect(receivedPage).not.toBeNull();
    }, 30000);
  });

  describe('withThreeJsScene', () => {
    test('Three.jsã‚·ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³', async () => {
      let testExecuted = false;

      const sceneBuilder = () => {
        window.testScene = new THREE.Scene();
        window.sceneBuilt = true;
      };

      await TestPatterns.withThreeJsScene(
        sceneBuilder,
        async (browserManager, page) => {
          testExecuted = true;

          const sceneBuilt = await page.evaluate(() => window.sceneBuilt);
          expect(sceneBuilt).toBe(true);

          const hasScene = await page.evaluate(() => !!window.testScene);
          expect(hasScene).toBe(true);
        }
      );

      expect(testExecuted).toBe(true);
    }, 45000);
  });

  describe('TestUtils + HTMLGenerator çµ±åˆ', () => {
    test('HTMLGeneratorã¨TestUtilsã®é€£æº', async () => {
      const testEnv = await TestUtils.setupTest();
      const htmlGenerator = new HTMLGenerator();

      try {
        const html = htmlGenerator.generateTestHTML(() => {
          window.integrationTestComplete = true;
        });

        await testEnv.page.setContent(html);
        
        const result = await testEnv.page.evaluate(() => window.integrationTestComplete);
        expect(result).toBe(true);
      } finally {
        await TestUtils.cleanupTest(testEnv);
      }
    }, 30000);
  });

  describe('è¤‡æ•°ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆçµ±åˆãƒ†ã‚¹ãƒˆ', () => {
    test('TestUtils, BrowserManager, HTMLGeneratorã®é€£æº', async () => {
      const testEnv = await TestUtils.setupTest({
        browserOptions: { width: 800, height: 600 }
      });
      const htmlGenerator = new HTMLGenerator();

      try {
        // HTMLGenerator ã§ãƒ†ã‚¹ãƒˆãƒšãƒ¼ã‚¸ç”Ÿæˆ
        const html = htmlGenerator.generateTestHTML(() => {
          window.multiComponentTest = {
            browserReady: true,
            pageWidth: window.innerWidth,
            pageHeight: window.innerHeight,
            timestamp: Date.now()
          };
        });

        // TestUtilsç®¡ç†ä¸‹ã®BrowserManagerã§ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰
        await testEnv.page.setContent(html);

        // çµæœæ¤œè¨¼
        const result = await testEnv.page.evaluate(() => window.multiComponentTest);
        
        expect(result.browserReady).toBe(true);
        expect(result.pageWidth).toBe(800);
        expect(result.pageHeight).toBe(600);
        expect(result.timestamp).toBeDefined();

        // TestUtilsã«ã‚ˆã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
        await TestUtils.resetGlobalState(testEnv.page);

        const afterReset = await testEnv.page.evaluate(() => window.multiComponentTest);
        expect(afterReset).toBeUndefined();

      } finally {
        await TestUtils.cleanupTest(testEnv);
      }
    }, 45000);
  });
});
</file>

<file path="three-test-suite/__tests__/performance/PerformanceTester.test.js">
import { BrowserManager } from '../src/BrowserManager.js';
import { PerformanceTester } from '../src/PerformanceTester.js';
import { PuppeteerManager } from '../src/PuppeteerManager.js'; // For hybrid test that uses PuppeteerManager facade

describe('PerformanceTester - WebAssemblyæ©Ÿèƒ½', () => {
  let browserManager;
  let tester;

  beforeEach(async () => {
    browserManager = new BrowserManager();
    await browserManager.initialize();
    tester = new PerformanceTester(browserManager);
  });

  afterEach(async () => {
    await browserManager.cleanup();
  });
  
  test('WASMãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆãŒå®Ÿè¡Œã§ãã‚‹', async () => {
    const performance = await tester.benchmarkWebAssembly();
    expect(performance).toBeDefined();
    expect(performance.executionTime).toBeGreaterThanOrEqual(0);
    expect(performance.operationsPerSecond).toBeGreaterThanOrEqual(0);
  });
});

describe('PerformanceTester - WASM + WebGLé€£æºæ©Ÿèƒ½', () => {
  let browserManager;
  let tester;

  beforeEach(async () => {
    browserManager = new BrowserManager();
    await browserManager.initialize();
    tester = new PerformanceTester(browserManager);
  });

  afterEach(async () => {
    await browserManager.cleanup();
  });

  test('WASMè¨ˆç®—çµæœã‚’WebGLã§æç”»ã§ãã‚‹ (via PuppeteerManager facade)', async () => {
    // This test implicitly tests the integration through PuppeteerManager's HTML generation
    // and page content setting, which now uses HTMLGenerator.
    const puppeteerManager = new PuppeteerManager(); // Uses the refactored classes internally
    await puppeteerManager.initialize();

    const testScript = () => {
      window.hybridTestResult = 'pending';
      const wasmBytes = new Uint8Array([
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01,
        0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x0a, 0x01, 0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6f, 0x00,
        0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b
      ]);
      WebAssembly.instantiate(wasmBytes).then(result => {
        const addTwo = result.instance.exports.addTwo;
        const vertices = [
          addTwo(0, 0), addTwo(1, 0), addTwo(0, 0),
          addTwo(1, 0), addTwo(1, 0), addTwo(0, 0),
          addTwo(0, 1), addTwo(1, 0), addTwo(0, 0)
        ];
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl');
        if (gl && vertices.length === 9) {
          const buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
          window.hybridTestResult = 'success';
        } else {
          window.hybridTestResult = 'failed';
        }
      }).catch(() => { window.hybridTestResult = 'error'; });
    };
    
    const html = puppeteerManager.generateTestHTML(testScript);
    await puppeteerManager.page.setContent(html);
    await puppeteerManager.page.waitForFunction('window.hybridTestResult !== "pending"', { timeout: 5000 });
    const result = await puppeteerManager.page.evaluate(() => window.hybridTestResult);
    expect(result).toBe('success');
    
    await puppeteerManager.cleanup();
  });

  test('benchmarkHybridPerformance()ã§WASM+WebGLæ€§èƒ½ã‚’æ¸¬å®šã§ãã‚‹', async () => {
    const performance = await tester.benchmarkHybridPerformance();
    expect(performance).toBeDefined();
    expect(performance.wasmComputeTime).toBeGreaterThanOrEqual(0);
    expect(performance.webglRenderTime).toBeGreaterThanOrEqual(0);
    expect(performance.dataTransferTime).toBeGreaterThanOrEqual(0);
    expect(performance.totalTime).toBeGreaterThanOrEqual(0);
    expect(performance.efficiency).toBeGreaterThanOrEqual(0);
  });

  test('å¤§é‡ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã§ã®WASM+WebGLé€£æºãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹', async () => {
    const performance = await tester.benchmarkHybridPerformance({ 
      dataSize: 10000, // Reduced for faster CI, original was 10000
      iterations: 50   // Reduced for faster CI, original was 100
    });
    expect(performance.totalTime).toBeLessThan(10000); // Adjusted timeout
    expect(performance.efficiency).toBeGreaterThanOrEqual(0); // Efficiency can be low
  });

  test('benchmarkHybridPerformance()ã¯åˆæœŸåŒ–å‰ã«å‘¼ã¶ã¨ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
    const uninitializedBrowserManager = new BrowserManager();
    const uninitTester = new PerformanceTester(uninitializedBrowserManager);
    await expect(uninitTester.benchmarkHybridPerformance()).rejects.toThrow('BrowserManager is not initialized');
  });
});
</file>

<file path="three-test-suite/__tests__/unit/EnvironmentInspector.test.js">
import { BrowserManager } from '../../src/BrowserManager.js';
import { EnvironmentInspector } from '../../src/EnvironmentInspector.js';

describe('EnvironmentInspector - WebGLæ©Ÿèƒ½', () => {
  let browserManager;

  beforeEach(async () => {
    browserManager = new BrowserManager();
    await browserManager.initialize();
  });

  afterEach(async () => {
    await browserManager.cleanup();
  });

  test('WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒå–å¾—ã§ãã‚‹', async () => {
    const webglSupported = await browserManager.page.evaluate(() => {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl');
      return gl !== null;
    });
    expect(webglSupported).toBe(true);
  });

  test('WebGL2ã‚‚åˆ©ç”¨å¯èƒ½', async () => {
    const webgl2Supported = await browserManager.page.evaluate(() => {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl2');
      return gl !== null;
    });
    expect(webgl2Supported).toBe(true);
  });

  test('WebGLã®åŸºæœ¬æƒ…å ±ãŒå–å¾—ã§ãã‚‹', async () => {
    const webglInfo = await browserManager.page.evaluate(() => {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl');
      if (!gl) return null;
      
      return {
        vendor: gl.getParameter(gl.VENDOR),
        renderer: gl.getParameter(gl.RENDERER),
        version: gl.getParameter(gl.VERSION)
      };
    });
    
    expect(webglInfo).not.toBeNull();
    expect(webglInfo.vendor).toBeDefined();
    expect(webglInfo.renderer).toBeDefined();
    expect(webglInfo.version).toBeDefined();
  });

  test('getWebGLInfo()ãƒ¡ã‚½ãƒƒãƒ‰ã§WebGLæƒ…å ±ã‚’å–å¾—ã§ãã‚‹', async () => {
    const inspector = new EnvironmentInspector(browserManager);
    const webglInfo = await inspector.getWebGLInfo();
    
    expect(webglInfo).toBeDefined();
    expect(webglInfo.webglSupported).toBe(true);
    expect(webglInfo.webgl2Supported).toBeDefined();
    expect(webglInfo.vendor).toBeDefined();
    expect(webglInfo.renderer).toBeDefined();
    expect(webglInfo.version).toBeDefined();
  });

  test('getWebGLInfo()ã¯åˆæœŸåŒ–å‰ã«å‘¼ã¶ã¨ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
    const uninitializedBrowserManager = new BrowserManager();
    // Note: We are not calling initialize()
    const inspector = new EnvironmentInspector(uninitializedBrowserManager);
    await expect(inspector.getWebGLInfo()).rejects.toThrow('BrowserManager is not initialized');
  });
});

describe('EnvironmentInspector - WebAssemblyæ©Ÿèƒ½', () => {
  let browserManager;
  let inspector;

  beforeEach(async () => {
    browserManager = new BrowserManager();
    await browserManager.initialize();
    inspector = new EnvironmentInspector(browserManager);
  });

  afterEach(async () => {
    await browserManager.cleanup();
  });

  test('WebAssemblyã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåˆ©ç”¨å¯èƒ½', async () => {
    const wasmSupported = await browserManager.page.evaluate(() => {
      return typeof WebAssembly !== 'undefined' && 
             typeof WebAssembly.instantiate === 'function';
    });
    expect(wasmSupported).toBe(true);
  });

  test('WebAssembly.compileStreamingãŒåˆ©ç”¨å¯èƒ½', async () => {
    const streamingSupported = await browserManager.page.evaluate(() => {
      return typeof WebAssembly.compileStreaming === 'function';
    });
    expect(streamingSupported).toBe(true);
  });

  test('ç°¡å˜ãªWASMãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå®Ÿè¡Œã§ãã‚‹', async () => {
    const wasmResult = await browserManager.page.evaluate(() => {
      const wasmBytes = new Uint8Array([
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01,
        0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x0a, 0x01, 0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6f, 0x00,
        0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b
      ]);
      return WebAssembly.instantiate(wasmBytes)
        .then(result => result.instance.exports.addTwo(5, 3));
    });
    expect(wasmResult).toBe(8);
  });

  test('getWebAssemblyInfo()ãƒ¡ã‚½ãƒƒãƒ‰ã§WASMæƒ…å ±ã‚’å–å¾—ã§ãã‚‹', async () => {
    const wasmInfo = await inspector.getWebAssemblyInfo();
    expect(wasmInfo).toBeDefined();
    expect(wasmInfo.wasmSupported).toBe(true);
    expect(wasmInfo.streamingSupported).toBeDefined();
    // SIMD is not reliably detectable this way, so we check if it's defined.
    // Depending on the environment, it might be false.
    expect(wasmInfo.simdSupported).toBeDefined(); 
  });

  test('getWebAssemblyInfo()ã¯åˆæœŸåŒ–å‰ã«å‘¼ã¶ã¨ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
    const uninitializedBrowserManager = new BrowserManager();
    const uninitInspector = new EnvironmentInspector(uninitializedBrowserManager);
    await expect(uninitInspector.getWebAssemblyInfo()).rejects.toThrow('BrowserManager is not initialized');
  });
});

describe('EnvironmentInspector - WASM + WebGLé€£æºæ©Ÿèƒ½', () => {
  let browserManager;
  let inspector;

  beforeEach(async () => {
    browserManager = new BrowserManager();
    await browserManager.initialize();
    inspector = new EnvironmentInspector(browserManager);
  });

  afterEach(async () => {
    await browserManager.cleanup();
  });

  test('WebAssemblyã¨WebGLãŒåŒæ™‚ã«åˆ©ç”¨å¯èƒ½', async () => {
    const capabilities = await inspector.getHybridCapabilities();
    expect(capabilities.wasmSupported).toBe(true);
    expect(capabilities.webglSupported).toBe(true);
    expect(capabilities.hybridReady).toBe(true);
  });
  
  test('getHybridCapabilities()ãƒ¡ã‚½ãƒƒãƒ‰ã§é€£æºæƒ…å ±ã‚’å–å¾—ã§ãã‚‹', async () => {
    const capabilities = await inspector.getHybridCapabilities();
    expect(capabilities).toBeDefined();
    expect(capabilities.wasmSupported).toBeDefined();
    expect(capabilities.webglSupported).toBeDefined();
    expect(capabilities.hybridReady).toBeDefined();
    expect(capabilities.performanceProfile).toBeDefined();
    expect(capabilities.recommendedStrategy).toBeDefined();
  });

  test('getHybridCapabilities()ã¯åˆæœŸåŒ–å‰ã«å‘¼ã¶ã¨ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
    const uninitializedBrowserManager = new BrowserManager();
    const uninitInspector = new EnvironmentInspector(uninitializedBrowserManager);
    await expect(uninitInspector.getHybridCapabilities()).rejects.toThrow('BrowserManager is not initialized');
  });
});
</file>

<file path="three-test-suite/docs/design-philosophy.md">
# Three.js ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ è¨­è¨ˆæ€æƒ³ã¨ãƒ¡ãƒªãƒƒãƒˆ

## ğŸ“š ç›®æ¬¡
- [å•é¡Œã®èƒŒæ™¯](#å•é¡Œã®èƒŒæ™¯)
- [æŠ€è¡“çš„åˆ¶ç´„ã¨è§£æ±ºã®æµã‚Œ](#æŠ€è¡“çš„åˆ¶ç´„ã¨è§£æ±ºã®æµã‚Œ)
- [ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ä¾¡å€¤](#ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ä¾¡å€¤)
- [å…·ä½“çš„ãªãƒ¡ãƒªãƒƒãƒˆ](#å…·ä½“çš„ãªãƒ¡ãƒªãƒƒãƒˆ)
- [ä»–ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¨ã®æ¯”è¼ƒ](#ä»–ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¨ã®æ¯”è¼ƒ)
- [å®Ÿéš›ã®é–‹ç™ºä½“é¨“](#å®Ÿéš›ã®é–‹ç™ºä½“é¨“)

## å•é¡Œã®èƒŒæ™¯

Three.jsã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ãéš›ã«ç›´é¢ã™ã‚‹æ ¹æœ¬çš„ãªèª²é¡Œï¼š

### ğŸš« Node.jsç’°å¢ƒã§ã®åˆ¶ç´„
```javascript
// âŒ Node.jsç’°å¢ƒã§ã¯ä¸å¯èƒ½
import * as THREE from 'three';

test('ç«‹æ–¹ä½“ä½œæˆãƒ†ã‚¹ãƒˆ', () => {
  const scene = new THREE.Scene();  // ReferenceError: DOMç’°å¢ƒãŒãªã„
  const geometry = new THREE.BoxGeometry();  // WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒãªã„
});
```

**ãªãœå‹•ã‹ãªã„ã®ã‹ï¼š**
- Node.jsã«ã¯DOMãŒãªã„
- Canvasè¦ç´ ãŒå­˜åœ¨ã—ãªã„
- WebGLãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒãªã„
- `window`, `document` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãªã„

## æŠ€è¡“çš„åˆ¶ç´„ã¨è§£æ±ºã®æµã‚Œ

### æ®µéš1: æ ¹æœ¬å•é¡Œã®ç™ºè¦‹
```
Three.jsã®ãƒ†ã‚¹ãƒˆãŒå¿…è¦
    â†“
Node.jsç’°å¢ƒã§ã¯å‹•ä½œã—ãªã„
    â†“
ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒãŒå¿…è¦
```

### æ®µéš2: ç¬¬ä¸€ã®è§£æ±ºç­–ã¨ãã®é™ç•Œ
```
Puppeteerã§ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒã‚’æä¾›
    â†“
âœ… Three.jså‹•ä½œå¯èƒ½
    â†“
âŒ æ¯å›HTMLç’°å¢ƒæ§‹ç¯‰ãŒå¿…è¦
    â†“
æ–°ãŸãªèª²é¡Œï¼šHTMLä½œæˆã®ç…©é›‘ã•
```

### æ®µéš3: æœ€çµ‚è§£æ±ºç­–
```
HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆæ©Ÿèƒ½
    â†“
âœ… HTMLç’°å¢ƒè‡ªå‹•æ§‹ç¯‰
    â†“
âœ… ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ç°¡æ½”åŒ–
    â†“
âœ… é–‹ç™ºè€…ä½“é¨“å‘ä¸Š
```

## ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ä¾¡å€¤

### ğŸ¯ æ ¸å¿ƒçš„ä¾¡å€¤ï¼šæŠ½è±¡åŒ–ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æä¾›

å¾“æ¥ã®é–‹ç™ºãƒ•ãƒ­ãƒ¼ã§ã¯ã€é–‹ç™ºè€…ã¯ä»¥ä¸‹ã®ã™ã¹ã¦ã‚’ç®¡ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸï¼š

1. **ã‚¤ãƒ³ãƒ•ãƒ©å±¤**ï¼šPuppeteerãƒ–ãƒ©ã‚¦ã‚¶ç®¡ç†
2. **ç’°å¢ƒæ§‹ç¯‰å±¤**ï¼šHTML/CSS/JavaScriptç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
3. **ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå±¤**ï¼šThree.jsèª­ã¿è¾¼ã¿ã¨è¨­å®š
4. **ãƒ†ã‚¹ãƒˆå±¤**ï¼šå®Ÿéš›ã®ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯

**ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯1-3ã‚’è‡ªå‹•åŒ–ã—ã€é–‹ç™ºè€…ãŒ4ã«é›†ä¸­ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚**

### ğŸ”„ å•é¡Œè§£æ±ºã®é€£é–
```
æŠ€è¡“çš„åˆ¶ç´„ â†’ è§£æ±ºç­– â†’ æ–°ãŸãªèª²é¡Œ â†’ æœ€çµ‚è§£æ±º

Node.jsåˆ¶ç´„ â†’ Puppeteer â†’ HTMLç…©é›‘ â†’ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ
     â†“           â†“          â†“           â†“
  DOMä¸è¶³    ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒ   æ‰‹ä½œæ¥­å¤šã„    è‡ªå‹•åŒ–
```

## å…·ä½“çš„ãªãƒ¡ãƒªãƒƒãƒˆ

### 1. ğŸ§¹ ã‚³ãƒ¼ãƒ‰ã®ç°¡æ½”æ€§

#### Before: Puppeteerå˜ä½“
```javascript
test('ç«‹æ–¹ä½“ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ', async () => {
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--enable-webgl', '--disable-web-security']
  });
  
  const page = await browser.newPage();
  await page.setViewport({ width: 1024, height: 768 });
  
  await page.setContent(`
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Three.js Test</title>
      <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
      </style>
    </head>
    <body>
      <canvas id="three-canvas"></canvas>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
      <script>
        window.addEventListener('load', function() {
          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
          renderer.setSize(window.innerWidth, window.innerHeight);
          
          const geometry = new THREE.BoxGeometry();
          const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
          const cube = new THREE.Mesh(geometry, material);
          scene.add(cube);
          
          camera.position.z = 5;
          renderer.render(scene, camera);
          
          window.cubeRendered = true;
        });
      </script>
    </body>
    </html>
  `);
  
  await page.waitForFunction('window.cubeRendered', { timeout: 5000 });
  
  const isRendered = await page.evaluate(() => window.cubeRendered);
  expect(isRendered).toBe(true);
  
  await browser.close();
});
```
**è¡Œæ•°ï¼š45è¡Œã€è¤‡é›‘åº¦ï¼šé«˜**

#### After: ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
```javascript
test('ç«‹æ–¹ä½“ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    
    camera.position.z = 5;
    renderer.render(scene, camera);
    
    window.cubeRendered = true;
  });
  
  await manager.page.setContent(html);
  const isRendered = await manager.page.evaluate(() => window.cubeRendered);
  expect(isRendered).toBe(true);
  
  await manager.cleanup();
});
```
**è¡Œæ•°ï¼š23è¡Œã€è¤‡é›‘åº¦ï¼šä½**

### 2. ğŸ¨ é–‹ç™ºè€…ä½“é¨“ã®å‘ä¸Š

#### ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒ»è‡ªå‹•è£œå®Œ
```javascript
// âœ… IDEã®ãƒ•ãƒ«æ©Ÿèƒ½ãŒä½¿ãˆã‚‹
const html = manager.generateTestHTML(() => {
  const scene = new THREE.Scene();        // â† è‡ªå‹•è£œå®Œ
  const camera = new THREE.PerspectiveCamera(
    75,                                    // â† ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ’ãƒ³ãƒˆ
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  
  // å¤‰æ•°å‚ç…§ã€ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚‚æ­£å¸¸å‹•ä½œ
  scene.add(cube);  // â† IDEãŒå¤‰æ•°è¿½è·¡
});
```

#### ã‚¨ãƒ©ãƒ¼æ¤œå‡º
```javascript
// âœ… æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã‚’é–‹ç™ºæ™‚ã«æ¤œå‡º
const html = manager.generateTestHTML(() => {
  const scene = new THREE.Scene();
  scene.add(nonExistentVariable);  // â† IDEãŒè­¦å‘Šè¡¨ç¤º
});
```

### 3. ğŸ”§ è¨­å®šã®æŸ”è»Ÿæ€§

```javascript
// Three.jsãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®š
const html = manager.generateTestHTML(sceneCode, {
  threeJsVersion: 'r140'
});

// è‡ªå‹•å®Ÿè¡Œåˆ¶å¾¡
const html = manager.generateTestHTML(sceneCode, {
  autoExecute: false  // æ‰‹å‹•å®Ÿè¡Œå¯èƒ½
});

// ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«
const html = manager.generateTestHTML(sceneCode, {
  title: 'VR Environment Test'
});
```

### 4. ğŸ§ª ãƒ†ã‚¹ãƒˆã®å†åˆ©ç”¨æ€§

```javascript
// å…±é€šã‚·ãƒ¼ãƒ³ä½œæˆé–¢æ•°
function createBasicScene() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.position.z = 5;
  return { scene, camera, renderer };
}

// è¤‡æ•°ãƒ†ã‚¹ãƒˆã§å†åˆ©ç”¨
test('èµ¤ã„ç«‹æ–¹ä½“', async () => {
  const html = manager.generateTestHTML(() => {
    const { scene, camera, renderer } = createBasicScene();
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    scene.add(cube);
    renderer.render(scene, camera);
  });
});

test('é’ã„çƒä½“', async () => {
  const html = manager.generateTestHTML(() => {
    const { scene, camera, renderer } = createBasicScene();
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(),
      new THREE.MeshBasicMaterial({ color: 0x0000ff })
    );
    scene.add(sphere);
    renderer.render(scene, camera);
  });
});
```

### 5. ğŸ” ãƒ‡ãƒãƒƒã‚°ã®å®¹æ˜“ã•

```javascript
test('ãƒ‡ãƒãƒƒã‚°æƒ…å ±ä»˜ããƒ†ã‚¹ãƒˆ', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    // ... ã‚·ãƒ¼ãƒ³ä½œæˆ
    
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ç°¡å˜ã«å‡ºåŠ›
    window.debugInfo = {
      sceneChildren: scene.children.length,
      cameraPosition: camera.position,
      rendererInfo: renderer.info
    };
  });
  
  await manager.page.setContent(html);
  
  const debugInfo = await manager.page.evaluate(() => window.debugInfo);
  console.log('Debug info:', debugInfo);  // ãƒ†ã‚¹ãƒˆä¸­ã«ç¢ºèªå¯èƒ½
});
```

## ä»–ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¨ã®æ¯”è¼ƒ

### ğŸ“Š æ¯”è¼ƒè¡¨

| ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ | ã‚³ãƒ¼ãƒ‰é‡ | è¤‡é›‘åº¦ | IDEæ”¯æ´ | å†åˆ©ç”¨æ€§ | å­¦ç¿’ã‚³ã‚¹ãƒˆ |
|------------|----------|---------|---------|----------|------------|
| **ç´”ç²‹Puppeteer** | å¤šã„ | é«˜ã„ | âŒ | ä½ã„ | é«˜ã„ |
| **HTMLãƒ•ã‚¡ã‚¤ãƒ«åˆ†é›¢** | ä¸­ç¨‹åº¦ | ä¸­ç¨‹åº¦ | â–³ | ä¸­ç¨‹åº¦ | ä¸­ç¨‹åº¦ |
| **ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯** | å°‘ãªã„ | ä½ã„ | âœ… | é«˜ã„ | ä½ã„ |

### ğŸ›ï¸ HTMLãƒ•ã‚¡ã‚¤ãƒ«åˆ†é›¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¨ã®æ¯”è¼ƒ

#### HTMLãƒ•ã‚¡ã‚¤ãƒ«åˆ†é›¢æ–¹å¼
```html
<!-- test-scene.html -->
<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // å›ºå®šã•ã‚ŒãŸThree.jsã‚³ãƒ¼ãƒ‰
    const scene = new THREE.Scene();
    // ...
  </script>
</body>
</html>
```

```javascript
// ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«
test('ã‚·ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ', async () => {
  await page.goto('file:///path/to/test-scene.html');
  // ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯
});
```

**å•é¡Œç‚¹ï¼š**
- âŒ ãƒ†ã‚¹ãƒˆã”ã¨ã«ç•°ãªã‚‹HTMLãƒ•ã‚¡ã‚¤ãƒ«ãŒå¿…è¦
- âŒ JavaScriptã‚³ãƒ¼ãƒ‰ã¨ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ãŒåˆ†é›¢
- âŒ å‹•çš„ãªãƒ†ã‚¹ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ¸¡ã—ã«ãã„
- âŒ ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ãŒè¤‡é›‘

#### ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
```javascript
test('å‹•çš„ã‚·ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ', async () => {
  const testParams = { color: 0xff0000, size: 2 };
  
  const html = manager.generateTestHTML(() => {
    // ãƒ†ã‚¹ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‹•çš„ã«ä½¿ç”¨
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(testParams.size, testParams.size, testParams.size),
      new THREE.MeshBasicMaterial({ color: testParams.color })
    );
  });
});
```

**åˆ©ç‚¹ï¼š**
- âœ… 1ã¤ã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§å®Œçµ
- âœ… å‹•çš„ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ³¨å…¥å¯èƒ½
- âœ… ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯ã®å¯è¦–æ€§å‘ä¸Š

## å®Ÿéš›ã®é–‹ç™ºä½“é¨“

### ğŸš€ å­¦ç¿’æ›²ç·š

```
å¾“æ¥ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:
æ™‚é–“ â†’
   â†‘
ç¿’å¾—
ãƒ¬ãƒ™ãƒ«     ____
          /
         /
        /
_______/ 
HTMLä½œæˆ, Puppeteer, Three.js ã‚’å…¨ã¦åŒæ™‚ã«å­¦ç¿’

ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯:
æ™‚é–“ â†’
   â†‘        ______
ç¿’å¾—      /
ãƒ¬ãƒ™ãƒ«   /
        /
_______/
Three.jsã«é›†ä¸­ã—ã¦å­¦ç¿’å¯èƒ½
```

### ğŸ¯ é–‹ç™ºãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã®å¤‰åŒ–

#### Before: åˆ†æ•£ã—ãŸãƒ•ã‚©ãƒ¼ã‚«ã‚¹
```
é–‹ç™ºè€…ã®æ³¨æ„åŠ›é…åˆ†:
- 25% HTMLãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ
- 25% Puppeteerè¨­å®š
- 20% CSS/ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´
- 30% Three.jsãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯  â† æœ¬æ¥ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã™ã¹ãéƒ¨åˆ†
```

#### After: é›†ä¸­ã—ãŸãƒ•ã‚©ãƒ¼ã‚«ã‚¹
```
é–‹ç™ºè€…ã®æ³¨æ„åŠ›é…åˆ†:
- 5% ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯è¨­å®š
- 95% Three.jsãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯  â† æœ¬æ¥ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã™ã¹ãéƒ¨åˆ†
```

### âš¡ é–‹ç™ºé€Ÿåº¦ã®å‘ä¸Š

```javascript
// æ–°ã—ã„ãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ã™ã‚‹æ™‚é–“

// Before: 15-30åˆ†
// 1. HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ (5-10åˆ†)
// 2. CSSèª¿æ•´ (3-5åˆ†)
// 3. Three.jsç’°å¢ƒæ§‹ç¯‰ (5-10åˆ†)
// 4. ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯ä½œæˆ (2-5åˆ†)

// After: 2-5åˆ†  
// 1. ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯ä½œæˆã®ã¿ (2-5åˆ†)

// é–‹ç™ºé€Ÿåº¦: 3-6å€å‘ä¸Š
```

## å°†æ¥ã®æ‹¡å¼µæ€§

### ğŸ”® è¿½åŠ å¯èƒ½ãªæ©Ÿèƒ½

```javascript
// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ”¯æ´
const html = manager.generateTestHTML(() => {
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—è‡ªå‹•è¨­å®š
}, { 
  enableAnimation: true,
  animationDuration: 5000 
});

// è¿½åŠ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªè‡ªå‹•èª­ã¿è¾¼ã¿
const html = manager.generateTestHTML(() => {
  // OrbitControlsä½¿ç”¨å¯èƒ½
}, { 
  additionalLibraries: ['OrbitControls', 'GLTFLoader'] 
});

// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
const html = manager.generateTestHTML(() => {
  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±è‡ªå‹•åé›†
}, { 
  enablePerformanceMonitoring: true 
});
```

### ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®åˆ©ç‚¹

ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®è¨­è¨ˆã«ã‚ˆã‚Šã€å°†æ¥çš„ã«ä»¥ä¸‹ã®æ©Ÿèƒ½è¿½åŠ ãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ï¼š

1. **VR/ARç’°å¢ƒã®ã‚µãƒãƒ¼ãƒˆ**
2. **WebXR API ã®ãƒ†ã‚¹ãƒˆæ”¯æ´**
3. **GPUè¨ˆç®—ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½**
4. **3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆ**
5. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯**

## çµè«–

ã“ã®Three.jsãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯ã€å˜ãªã‚‹ã€Œä¾¿åˆ©ãƒ„ãƒ¼ãƒ«ã€ã§ã¯ãªãã€**Three.jsé–‹ç™ºã«ãŠã‘ã‚‹æœ¬è³ªçš„ãªèª²é¡Œã‚’è§£æ±ºã™ã‚‹è¨­è¨ˆæ€æƒ³**ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚

**æ ¸å¿ƒçš„ä¾¡å€¤ï¼š**
- æŠ€è¡“çš„åˆ¶ç´„ã®æŠ½è±¡åŒ–
- é–‹ç™ºè€…ä½“é¨“ã®å‘ä¸Š  
- ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯ã¸ã®é›†ä¸­
- ç”Ÿç”£æ€§ã®é£›èºçš„å‘ä¸Š

ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«ã‚ˆã‚Šã€é–‹ç™ºè€…ã¯Three.jsã®å­¦ç¿’ã¨ãƒ†ã‚¹ãƒˆä½œæˆã«é›†ä¸­ã§ãã€ã‚ˆã‚Šé«˜å“è³ªãª3Dã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åŠ¹ç‡çš„ã«é–‹ç™ºã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
</file>

<file path="three-test-suite/docs/quick-start.md">
# Three.js ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆã‚¬ã‚¤ãƒ‰

## ğŸš€ ã¯ã˜ã‚ã«

ã“ã®ã‚¬ã‚¤ãƒ‰ã§ã¯ã€Three.js ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®åŸºæœ¬çš„ãªä½¿ã„æ–¹ã‚’å­¦ã¹ã¾ã™ã€‚

## ğŸ“‹ å‰ææ¡ä»¶

- Node.js 18ä»¥ä¸Š
- npm ã¾ãŸã¯ yarn
- Three.js ã®åŸºæœ¬çŸ¥è­˜

## âš¡ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ

### 1. åŸºæœ¬çš„ãªãƒ†ã‚¹ãƒˆ

```javascript
import { PuppeteerManager } from '../src/PuppeteerManager.js';

test('æœ€åˆã®Three.jsãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    // ğŸ¯ ã“ã“ã« Three.js ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // ç«‹æ–¹ä½“ã‚’ä½œæˆ
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    
    camera.position.z = 5;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.render(scene, camera);
    
    // ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
    window.sceneReady = true;
  });
  
  await manager.page.setContent(html);
  
  // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
  const isReady = await manager.page.evaluate(() => window.sceneReady);
  expect(isReady).toBe(true);
  
  await manager.cleanup();
});
```

### 2. è¤‡æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ†ã‚¹ãƒˆ

```javascript
test('è¤‡æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¿½åŠ ãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // ç«‹æ–¹ä½“
    const cubeGeometry = new THREE.BoxGeometry();
    const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    cube.position.x = -2;
    scene.add(cube);
    
    // çƒä½“
    const sphereGeometry = new THREE.SphereGeometry();
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.x = 2;
    scene.add(sphere);
    
    camera.position.z = 5;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.render(scene, camera);
    
    // ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿
    window.testResults = {
      objectCount: scene.children.length,
      cubePosition: cube.position.x,
      spherePosition: sphere.position.x
    };
  });
  
  await manager.page.setContent(html);
  
  const results = await manager.page.evaluate(() => window.testResults);
  expect(results.objectCount).toBe(2);
  expect(results.cubePosition).toBe(-2);
  expect(results.spherePosition).toBe(2);
  
  await manager.cleanup();
});
```

### 3. ç•°ãªã‚‹Three.jsãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã®ãƒ†ã‚¹ãƒˆ

```javascript
test('Three.js r140 ã§ã®ãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    // r140ã®æ–°æ©Ÿèƒ½ã‚’ä½¿ç”¨
    const scene = new THREE.Scene();
    window.threeVersion = THREE.REVISION;
  }, {
    threeJsVersion: 'r140',
    title: 'Three.js r140 Test Environment'
  });
  
  await manager.page.setContent(html);
  
  const version = await manager.page.evaluate(() => window.threeVersion);
  expect(version).toBe(140);
  
  await manager.cleanup();
});
```

### 4. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆ

```javascript
test('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    
    camera.position.z = 5;
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    let frameCount = 0;
    function animate() {
      frameCount++;
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;
      
      renderer.render(scene, camera);
      
      if (frameCount < 10) {
        requestAnimationFrame(animate);
      } else {
        // 10ãƒ•ãƒ¬ãƒ¼ãƒ å¾Œã«ãƒ†ã‚¹ãƒˆå®Œäº†
        window.animationComplete = true;
        window.finalRotation = {
          x: cube.rotation.x,
          y: cube.rotation.y
        };
      }
    }
    
    animate();
  });
  
  await manager.page.setContent(html);
  
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã¾ã§å¾…æ©Ÿ
  await manager.page.waitForFunction('window.animationComplete', { timeout: 5000 });
  
  const rotation = await manager.page.evaluate(() => window.finalRotation);
  expect(rotation.x).toBeGreaterThan(0);
  expect(rotation.y).toBeGreaterThan(0);
  
  await manager.cleanup();
});
```

### 5. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãƒ†ã‚¹ãƒˆ

```javascript
test('WebGLéå¯¾å¿œç’°å¢ƒã§ã®å‹•ä½œ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    try {
      const canvas = document.getElementById('three-canvas');
      const context = canvas.getContext('webgl');
      
      if (!context) {
        throw new Error('WebGL not supported');
      }
      
      const scene = new THREE.Scene();
      window.webglSupported = true;
    } catch (error) {
      window.webglError = error.message;
      window.webglSupported = false;
    }
  });
  
  await manager.page.setContent(html);
  
  const isSupported = await manager.page.evaluate(() => window.webglSupported);
  expect(isSupported).toBe(true); // é€šå¸¸ã®ç’°å¢ƒã§ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹
  
  await manager.cleanup();
});
```

## ğŸ¨ é«˜åº¦ãªä½¿ç”¨ä¾‹

### ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ†ãƒªã‚¢ãƒ«ã®ãƒ†ã‚¹ãƒˆ

```javascript
test('ã‚«ã‚¹ã‚¿ãƒ ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // ã‚«ã‚¹ã‚¿ãƒ ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼
    const vertexShader = `
      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    
    const fragmentShader = `
      uniform float time;
      void main() {
        gl_FragColor = vec4(sin(time), cos(time), 0.5, 1.0);
      }
    `;
    
    const material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 1.0 }
      },
      vertexShader: vertexShader,
      fragmentShader: fragmentShader
    });
    
    const geometry = new THREE.PlaneGeometry(2, 2);
    const plane = new THREE.Mesh(geometry, material);
    scene.add(plane);
    
    camera.position.z = 3;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.render(scene, camera);
    
    window.shaderTest = {
      materialType: material.type,
      uniformsCount: Object.keys(material.uniforms).length
    };
  });
  
  await manager.page.setContent(html);
  
  const result = await manager.page.evaluate(() => window.shaderTest);
  expect(result.materialType).toBe('ShaderMaterial');
  expect(result.uniformsCount).toBe(1);
  
  await manager.cleanup();
});
```

### 3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã®ãƒ†ã‚¹ãƒˆï¼ˆãƒ¢ãƒƒã‚¯ï¼‰

```javascript
test('3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // GLTFãƒ­ãƒ¼ãƒ€ãƒ¼ã®ãƒ¢ãƒƒã‚¯ï¼ˆå®Ÿéš›ã®ãƒ­ãƒ¼ãƒ€ãƒ¼ã®ä»£ã‚ã‚Šï¼‰
    function loadModel() {
      return new Promise((resolve) => {
        setTimeout(() => {
          // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
          const geometry = new THREE.BoxGeometry();
          const material = new THREE.MeshBasicMaterial({ color: 0x888888 });
          const model = new THREE.Mesh(geometry, material);
          resolve(model);
        }, 100);
      });
    }
    
    loadModel().then((model) => {
      scene.add(model);
      camera.position.z = 5;
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.render(scene, camera);
      
      window.modelLoaded = {
        success: true,
        objectCount: scene.children.length,
        modelType: model.type
      };
    });
  });
  
  await manager.page.setContent(html);
  
  // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ã¾ã§å¾…æ©Ÿ
  await manager.page.waitForFunction('window.modelLoaded', { timeout: 5000 });
  
  const result = await manager.page.evaluate(() => window.modelLoaded);
  expect(result.success).toBe(true);
  expect(result.objectCount).toBe(1);
  expect(result.modelType).toBe('Mesh');
  
  await manager.cleanup();
});
```

## ğŸ› ï¸ ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. ãƒ†ã‚¹ãƒˆã®æ§‹é€ åŒ–

```javascript
describe('Three.js åŸºæœ¬æ©Ÿèƒ½', () => {
  let manager;
  
  beforeEach(async () => {
    manager = new PuppeteerManager();
    await manager.initialize();
  });
  
  afterEach(async () => {
    await manager.cleanup();
  });
  
  test('ã‚·ãƒ¼ãƒ³ä½œæˆ', async () => {
    // ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯
  });
  
  test('ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½åŠ ', async () => {
    // ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯
  });
});
```

### 2. å…±é€šã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°

```javascript
// ãƒ†ã‚¹ãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼
function createBasicScene() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
  
  camera.position.z = 5;
  renderer.setSize(window.innerWidth, window.innerHeight);
  
  return { scene, camera, renderer };
}

function createTestCube(color = 0x00ff00) {
  const geometry = new THREE.BoxGeometry();
  const material = new THREE.MeshBasicMaterial({ color });
  return new THREE.Mesh(geometry, material);
}

// ä½¿ç”¨ä¾‹
test('ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã‚’ä½¿ã£ãŸãƒ†ã‚¹ãƒˆ', async () => {
  const html = manager.generateTestHTML(() => {
    const { scene, camera, renderer } = createBasicScene();
    const cube = createTestCube(0xff0000);
    
    scene.add(cube);
    renderer.render(scene, camera);
    
    window.testComplete = true;
  });
  
  await manager.page.setContent(html);
  // ãƒ†ã‚¹ãƒˆç¶šè¡Œ...
});
```

### 3. éåŒæœŸå‡¦ç†ã®ãƒ†ã‚¹ãƒˆ

```javascript
test('éåŒæœŸã‚·ãƒ¼ãƒ³æ§‹ç¯‰', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // éåŒæœŸã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
    Promise.resolve().then(() => {
      const cube = new THREE.Mesh(
        new THREE.BoxGeometry(),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
      );
      scene.add(cube);
      
      camera.position.z = 5;
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.render(scene, camera);
      
      window.asyncComplete = {
        objectCount: scene.children.length,
        timestamp: Date.now()
      };
    });
  });
  
  await manager.page.setContent(html);
  
  // éåŒæœŸå‡¦ç†å®Œäº†ã¾ã§å¾…æ©Ÿ
  await manager.page.waitForFunction('window.asyncComplete', { timeout: 5000 });
  
  const result = await manager.page.evaluate(() => window.asyncComplete);
  expect(result.objectCount).toBe(1);
  expect(result.timestamp).toBeGreaterThan(0);
});
```

### 4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

```javascript
test('ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    // å¤šæ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
    const objectCount = 100;
    const startTime = performance.now();
    
    for (let i = 0; i < objectCount; i++) {
      const geometry = new THREE.BoxGeometry();
      const material = new THREE.MeshBasicMaterial({ 
        color: Math.random() * 0xffffff 
      });
      const cube = new THREE.Mesh(geometry, material);
      
      cube.position.x = (Math.random() - 0.5) * 10;
      cube.position.y = (Math.random() - 0.5) * 10;
      cube.position.z = (Math.random() - 0.5) * 10;
      
      scene.add(cube);
    }
    
    const creationTime = performance.now() - startTime;
    
    camera.position.z = 15;
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const renderStartTime = performance.now();
    renderer.render(scene, camera);
    const renderTime = performance.now() - renderStartTime;
    
    window.performanceResults = {
      objectCount,
      creationTime,
      renderTime,
      totalTime: creationTime + renderTime
    };
  });
  
  await manager.page.setContent(html);
  
  const results = await manager.page.evaluate(() => window.performanceResults);
  
  expect(results.objectCount).toBe(100);
  expect(results.creationTime).toBeLessThan(1000); // 1ç§’ä»¥å†…
  expect(results.renderTime).toBeLessThan(100);    // 100msä»¥å†…
  
  console.log('Performance Results:', results);
});
```

## ğŸš¨ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ³•

#### 1. Three.js ãŒèª­ã¿è¾¼ã¾ã‚Œãªã„

```javascript
test('Three.jsèª­ã¿è¾¼ã¿ç¢ºèª', async () => {
  const html = manager.generateTestHTML(() => {
    // Three.jsãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
    if (typeof THREE === 'undefined') {
      window.threeError = 'THREE is not defined';
      return;
    }
    
    window.threeLoaded = true;
    window.threeVersion = THREE.REVISION;
  });
  
  await manager.page.setContent(html);
  
  // Three.jsèª­ã¿è¾¼ã¿å®Œäº†ã¾ã§å¾…æ©Ÿ
  await manager.page.waitForFunction(
    'typeof THREE !== "undefined"', 
    { timeout: 10000 }
  );
  
  const isLoaded = await manager.page.evaluate(() => window.threeLoaded);
  expect(isLoaded).toBe(true);
});
```

#### 2. WebGL ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼

```javascript
test('WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç¢ºèª', async () => {
  const html = manager.generateTestHTML(() => {
    const canvas = document.getElementById('three-canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    window.webglInfo = {
      supported: !!gl,
      vendor: gl ? gl.getParameter(gl.VENDOR) : null,
      renderer: gl ? gl.getParameter(gl.RENDERER) : null
    };
  });
  
  await manager.page.setContent(html);
  
  const webglInfo = await manager.page.evaluate(() => window.webglInfo);
  
  if (!webglInfo.supported) {
    console.warn('WebGL not supported in test environment');
  }
  
  expect(webglInfo.supported).toBe(true);
});
```

#### 3. ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼

```javascript
test('ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¯¾ç­–', async () => {
  const html = manager.generateTestHTML(() => {
    // é‡ã„å‡¦ç†ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    setTimeout(() => {
      const scene = new THREE.Scene();
      // ... ã‚·ãƒ¼ãƒ³æ§‹ç¯‰
      window.heavyProcessComplete = true;
    }, 2000); // 2ç§’å¾Œã«å®Œäº†
  });
  
  await manager.page.setContent(html);
  
  // ååˆ†ãªå¾…æ©Ÿæ™‚é–“ã‚’è¨­å®š
  await manager.page.waitForFunction(
    'window.heavyProcessComplete', 
    { timeout: 5000 }  // 5ç§’ã¾ã§å¾…æ©Ÿ
  );
  
  const isComplete = await manager.page.evaluate(() => window.heavyProcessComplete);
  expect(isComplete).toBe(true);
});
```

## ğŸ”— é–¢é€£ãƒªã‚½ãƒ¼ã‚¹

- [Three.js å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://threejs.org/docs/)
- [Puppeteer å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://pptr.dev/)
- [Jest ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯](https://jestjs.io/)
- [WebGL ä»•æ§˜](https://www.khronos.org/webgl/)

## ğŸ“ ã‚µãƒãƒ¼ãƒˆ

å•é¡ŒãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š

1. Node.js ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒ18ä»¥ä¸Šã‹
2. PuppeteerãŒæ­£å¸¸ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã‹
3. WebGLå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ãŒåˆ©ç”¨å¯èƒ½ã‹

ã•ã‚‰ãªã‚‹ã‚µãƒãƒ¼ãƒˆãŒå¿…è¦ãªå ´åˆã¯ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®Issueã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
</file>

<file path="three-test-suite/src/mocks/MockBrowserManager.js">
/**
 * BrowserManagerã®ãƒ¢ãƒƒã‚¯å®Ÿè£…
 * ãƒ†ã‚¹ãƒˆé–“ã®ä¾å­˜é–¢ä¿‚ã‚’æ’é™¤ã—ã€ç‹¬ç«‹æ€§ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã®ãƒ¢ãƒƒã‚¯ã‚¯ãƒ©ã‚¹
 */
class MockBrowserManager {
  constructor(options = {}) {
    this.options = {
      headless: true,
      width: 1024,
      height: 768,
      ...options
    };
    this.browser = null;
    this.page = null;
    this.isInitialized = false;
    this.instances = new Set(); // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è¿½è·¡
  }

  /**
   * åˆæœŸåŒ–å‡¦ç†ï¼ˆãƒ¢ãƒƒã‚¯ç‰ˆï¼‰
   * å®Ÿéš›ã®Puppeteerã¯èµ·å‹•ã›ãšã€ãƒ¢ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
   */
  async initialize() {
    if (this.isInitialized) {
      throw new Error('BrowserManager already initialized');
    }

    // ãƒ¢ãƒƒã‚¯ãƒ–ãƒ©ã‚¦ã‚¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    this.browser = this.createMockBrowser();
    
    // ãƒ¢ãƒƒã‚¯ãƒšãƒ¼ã‚¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    this.page = this.createMockPage();
    
    this.isInitialized = true;
    this.instances.add(this);
    
    return this;
  }

  /**
   * ãƒ¢ãƒƒã‚¯ãƒ–ãƒ©ã‚¦ã‚¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ
   */
  createMockBrowser() {
    return {
      newPage: async () => this.createMockPage(),
      close: async () => {
        this.isInitialized = false;
        this.instances.delete(this);
      },
      isConnected: () => this.isInitialized,
      pages: async () => [this.page].filter(Boolean),
      version: () => 'MockBrowser/1.0.0'
    };
  }

  /**
   * ãƒ¢ãƒƒã‚¯ãƒšãƒ¼ã‚¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ
   */
  createMockPage() {
    const mockPage = {
      // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³é–¢é€£
      goto: async (url) => {
        mockPage._currentUrl = url;
        return { status: () => 200 };
      },
      
      setContent: async (content) => {
        mockPage._content = content;
        // HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è§£æã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
        await this.simulateContentParsing(content);
      },
      
      content: async () => mockPage._content || '',
      
      url: () => mockPage._currentUrl || 'about:blank',
      
      // è©•ä¾¡é–¢é€£
      evaluate: async (fn, ...args) => {
        // JavaScriptã®è©•ä¾¡ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
        return this.simulateEvaluation(fn, args);
      },
      
      evaluateHandle: async (fn, ...args) => {
        const result = await mockPage.evaluate(fn, ...args);
        return { jsonValue: async () => result };
      },
      
      // å¾…æ©Ÿé–¢æ•°
      waitForFunction: async (fn, options = {}) => {
        const timeout = options.timeout || 30000;
        const startTime = Date.now();
        
        while (Date.now() - startTime < timeout) {
          try {
            const result = await mockPage.evaluate(fn);
            if (result) return result;
          } catch (e) {
            // è©•ä¾¡ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
          }
          await this.delay(100);
        }
        throw new Error(`waitForFunction timeout after ${timeout}ms`);
      },
      
      waitForSelector: async (selector, options = {}) => {
        // ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã®å­˜åœ¨ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
        await this.delay(10);
        return { click: async () => {}, type: async () => {} };
      },
      
      // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆé–¢é€£
      setViewport: async (viewport) => {
        mockPage._viewport = viewport;
      },
      
      viewport: () => mockPage._viewport || this.options,
      
      // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
      screenshot: async (options = {}) => {
        // ãƒ€ãƒŸãƒ¼ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆãƒ‡ãƒ¼ã‚¿
        return Buffer.from('mock-screenshot-data');
      },
      
      // ãƒ­ã‚°è¨˜éŒ²
      on: (event, handler) => {
        mockPage._listeners = mockPage._listeners || {};
        mockPage._listeners[event] = mockPage._listeners[event] || [];
        mockPage._listeners[event].push(handler);
      },
      
      removeListener: (event, handler) => {
        if (mockPage._listeners && mockPage._listeners[event]) {
          const index = mockPage._listeners[event].indexOf(handler);
          if (index > -1) {
            mockPage._listeners[event].splice(index, 1);
          }
        }
      },
      
      // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      close: async () => {
        mockPage._closed = true;
      },
      
      isClosed: () => mockPage._closed || false,
      
      // å†…éƒ¨çŠ¶æ…‹
      _content: '',
      _currentUrl: '',
      _viewport: null,
      _closed: false,
      _listeners: {}
    };
    
    return mockPage;
  }

  /**
   * HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è§£æã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
   */
  async simulateContentParsing(content) {
    // Three.jsã‚¹ã‚¯ãƒªãƒ—ãƒˆã®æ¤œå‡º
    if (content.includes('three.min.js') || content.includes('THREE')) {
      // Three.jsç’°å¢ƒã®åˆæœŸåŒ–ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
      await this.delay(50);
      
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¨­å®šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
      this.setGlobalProperty('THREE', this.createMockThreeJS());
      this.setGlobalProperty('window.THREE', this.createMockThreeJS());
    }
    
    // WebGLã®åˆæœŸåŒ–ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    if (content.includes('WebGLRenderer') || content.includes('canvas')) {
      this.setGlobalProperty('WebGLRenderingContext', this.createMockWebGLContext());
    }
  }

  /**
   * JavaScriptè©•ä¾¡ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
   */
  async simulateEvaluation(fn, args) {
    // é–¢æ•°ã®æ–‡å­—åˆ—åŒ–ã¨è§£æ
    const fnString = fn.toString();
    
    // Three.jsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    if (fnString.includes('new THREE.Scene')) {
      return { type: 'Scene', children: [] };
    }
    
    if (fnString.includes('new THREE.Mesh')) {
      return { type: 'Mesh', geometry: {}, material: {} };
    }
    
    if (fnString.includes('window.')) {
      // window ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
      const match = fnString.match(/window\.(\w+)/);
      if (match) {
        return this.getGlobalProperty(match[1]);
      }
    }
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æˆ»ã‚Šå€¤
    return true;
  }

  /**
   * ãƒ¢ãƒƒã‚¯Three.JSã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ
   */
  createMockThreeJS() {
    return {
      Scene: class MockScene {
        constructor() {
          this.children = [];
          this.type = 'Scene';
        }
        add(object) { this.children.push(object); }
        remove(object) { 
          const index = this.children.indexOf(object);
          if (index > -1) this.children.splice(index, 1);
        }
      },
      
      Mesh: class MockMesh {
        constructor(geometry, material) {
          this.geometry = geometry || {};
          this.material = material || {};
          this.type = 'Mesh';
          this.position = { x: 0, y: 0, z: 0 };
          this.rotation = { x: 0, y: 0, z: 0 };
          this.scale = { x: 1, y: 1, z: 1 };
        }
      },
      
      BoxGeometry: class MockBoxGeometry {
        constructor(width = 1, height = 1, depth = 1) {
          this.type = 'BoxGeometry';
          this.parameters = { width, height, depth };
        }
      },
      
      MeshBasicMaterial: class MockMeshBasicMaterial {
        constructor(parameters = {}) {
          this.type = 'MeshBasicMaterial';
          this.color = parameters.color || 0xffffff;
        }
      },
      
      PerspectiveCamera: class MockPerspectiveCamera {
        constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
          this.type = 'PerspectiveCamera';
          this.fov = fov;
          this.aspect = aspect;
          this.near = near;
          this.far = far;
          this.position = { x: 0, y: 0, z: 0 };
        }
      },
      
      WebGLRenderer: class MockWebGLRenderer {
        constructor(parameters = {}) {
          this.type = 'WebGLRenderer';
          this.domElement = this.createMockCanvas();
          this.info = {
            render: { triangles: 0, calls: 0 },
            memory: { geometries: 0, textures: 0 }
          };
        }
        
        setSize(width, height) {
          this.domElement.width = width;
          this.domElement.height = height;
        }
        
        render(scene, camera) {
          // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
          this.info.render.calls++;
          this.info.render.triangles += scene.children.length * 2;
        }
        
        createMockCanvas() {
          return {
            width: 300,
            height: 150,
            getContext: (type) => {
              if (type === 'webgl' || type === 'experimental-webgl') {
                return this.createMockWebGLContext();
              }
              return null;
            }
          };
        }
        
        createMockWebGLContext() {
          return {
            getParameter: (param) => {
              const paramMap = {
                37445: 'Mock WebGL Vendor',  // VENDOR
                37446: 'Mock WebGL Renderer', // RENDERER
                7938: 'WebGL 1.0 Mock'       // VERSION
              };
              return paramMap[param] || 'Mock Value';
            },
            getExtension: () => null,
            getSupportedExtensions: () => []
          };
        }
      }
    };
  }

  /**
   * ãƒ¢ãƒƒã‚¯WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä½œæˆ
   */
  createMockWebGLContext() {
    return function MockWebGLRenderingContext() {
      return {
        canvas: { width: 300, height: 150 },
        getParameter: (param) => 'Mock WebGL Value',
        getExtension: () => null,
        getSupportedExtensions: () => [],
        createProgram: () => ({}),
        createShader: () => ({}),
        compileShader: () => {},
        linkProgram: () => {},
        useProgram: () => {},
        clear: () => {},
        clearColor: () => {},
        viewport: () => {}
      };
    };
  }

  /**
   * ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®è¨­å®š
   */
  setGlobalProperty(name, value) {
    this._globalProperties = this._globalProperties || {};
    this._globalProperties[name] = value;
  }

  /**
   * ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å–å¾—
   */
  getGlobalProperty(name) {
    this._globalProperties = this._globalProperties || {};
    return this._globalProperties[name];
  }

  /**
   * é…å»¶å‡¦ç†
   */
  async delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†
   */
  async cleanup() {
    if (this.page && !this.page.isClosed()) {
      await this.page.close();
    }
    
    if (this.browser) {
      await this.browser.close();
    }
    
    this.isInitialized = false;
    this.instances.delete(this);
    this._globalProperties = {};
  }

  /**
   * ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  static async cleanupAll() {
    const cleanupPromises = Array.from(MockBrowserManager.instances).map(
      instance => instance.cleanup()
    );
    await Promise.all(cleanupPromises);
    MockBrowserManager.instances.clear();
  }

  /**
   * ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ã®å–å¾—
   */
  static getActiveInstanceCount() {
    return MockBrowserManager.instances.size;
  }
}

// é™çš„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®åˆæœŸåŒ–
MockBrowserManager.instances = new Set();

module.exports = MockBrowserManager;
</file>

<file path="three-test-suite/src/mocks/MockWebGL.js">
/**
 * @file WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ¢ãƒƒã‚¯å®Ÿè£…
 * Three.jsãƒ†ã‚¹ãƒˆã§WebGLæ©Ÿèƒ½ã‚’å®Œå…¨ã«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã€ãƒ†ã‚¹ãƒˆé–“ã®ç‹¬ç«‹æ€§ã‚’ç¢ºä¿
 */

/**
 * @typedef {object} InternalMockCanvas
 * @property {number} width
 * @property {number} height
 * @property {number} clientWidth
 * @property {number} clientHeight
 * @property {() => MockWebGLRenderingContext} getContext - ã“ã®ãƒ¢ãƒƒã‚¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚
 * @property {() => void} addEventListener
 * @property {() => void} removeEventListener
 */
class MockWebGLRenderingContext {
  /** @type {InternalMockCanvas} */
  canvas;

  /**
   * @param {InternalMockCanvas} [canvas] - ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚
   */
  constructor(canvas) {
    this.canvas = canvas || this.createMockCanvas();
    this.programs = new Map();
    this.shaders = new Map();
    this.buffers = new Map();
    this.textures = new Map();
    this.framebuffers = new Map();
    this.renderbuffers = new Map();
    
    // WebGLå®šæ•°ã®å®šç¾©
    this.initializeConstants();
    
    // çŠ¶æ…‹ç®¡ç†
    this.state = {
      viewport: [0, 0, this.canvas.width, this.canvas.height],
      clearColor: [0, 0, 0, 1],
      activeTexture: this.TEXTURE0,
      currentProgram: null,
      blend: false,
      depthTest: true,
      cullFace: false
    };
    
    // ãƒªã‚½ãƒ¼ã‚¹ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
    this.resourceCounters = {
      programs: 0,
      shaders: 0,
      buffers: 0,
      textures: 0,
      framebuffers: 0,
      renderbuffers: 0
    };
  }

  /**
   * WebGLå®šæ•°ã®åˆæœŸåŒ–
   */
  initializeConstants() {
    // ãƒãƒƒãƒ•ã‚¡ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
    this.ARRAY_BUFFER = 34962;
    this.ELEMENT_ARRAY_BUFFER = 34963;
    
    // ãƒ‡ãƒ¼ã‚¿å‹
    this.BYTE = 5120;
    this.UNSIGNED_BYTE = 5121;
    this.SHORT = 5122;
    this.UNSIGNED_SHORT = 5123;
    this.INT = 5124;
    this.UNSIGNED_INT = 5125;
    this.FLOAT = 5126;
    
    // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚¿ã‚¤ãƒ—
    this.VERTEX_SHADER = 35633;
    this.FRAGMENT_SHADER = 35632;
    
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
    this.TEXTURE_2D = 3553;
    this.TEXTURE_CUBE_MAP = 34067;
    
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¦ãƒ‹ãƒƒãƒˆ
    this.TEXTURE0 = 33984;
    this.TEXTURE1 = 33985;
    
    // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡
    this.FRAMEBUFFER = 36160;
    this.RENDERBUFFER = 36161;
    
    // ã‚¢ã‚¿ãƒƒãƒãƒ¡ãƒ³ãƒˆ
    this.COLOR_ATTACHMENT0 = 36064;
    this.DEPTH_ATTACHMENT = 36096;
    this.STENCIL_ATTACHMENT = 36128;
    
    // æç”»ãƒ¢ãƒ¼ãƒ‰
    this.POINTS = 0;
    this.LINES = 1;
    this.TRIANGLES = 4;
    
    // ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼
    this.ZERO = 0;
    this.ONE = 1;
    this.SRC_ALPHA = 770;
    this.ONE_MINUS_SRC_ALPHA = 771;
    
    // ãƒ†ã‚¹ãƒˆé–¢æ•°
    this.NEVER = 512;
    this.LESS = 513;
    this.LEQUAL = 515;
    this.GREATER = 516;
    this.GEQUAL = 518;
    this.ALWAYS = 519;
    
    // ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
    this.NO_ERROR = 0;
    this.INVALID_ENUM = 1280;
    this.INVALID_VALUE = 1281;
    this.INVALID_OPERATION = 1282;
    this.OUT_OF_MEMORY = 1285;
    
    // ãã®ä»–ã®å®šæ•°
    this.VENDOR = 7936;
    this.RENDERER = 7937;
    this.VERSION = 7938;
    this.SHADING_LANGUAGE_VERSION = 35724;
    this.COMPILE_STATUS = 35713;
    this.LINK_STATUS = 35714;
    this.BLEND = 3042;
    this.DEPTH_TEST = 2929;
    this.CULL_FACE = 2884;
  }

  /**
   * ãƒ¢ãƒƒã‚¯Canvasã®ä½œæˆ
   * @returns {InternalMockCanvas}
   */
  createMockCanvas() {
    return {
      width: 300,
      height: 150,
      clientWidth: 300,
      clientHeight: 150,
      getContext: () => this,
      addEventListener: () => {},
      removeEventListener: () => {}
    };
  }

  // === ãƒãƒƒãƒ•ã‚¡ç®¡ç† ===
  
  createBuffer() {
    const id = ++this.resourceCounters.buffers;
    const buffer = { id, data: null, target: null };
    this.buffers.set(id, buffer);
    return buffer;
  }

  deleteBuffer(buffer) {
    if (buffer && this.buffers.has(buffer.id)) {
      this.buffers.delete(buffer.id);
    }
  }

  bindBuffer(target, buffer) {
    if (buffer) {
      buffer.target = target;
    }
  }

  bufferData(target, data, usage) {
    // ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    const buffer = Array.from(this.buffers.values()).find(b => b.target === target);
    if (buffer) {
      buffer.data = data;
      buffer.usage = usage;
    }
  }

  // === ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ç®¡ç† ===
  
  createShader(type) {
    const id = ++this.resourceCounters.shaders;
    const shader = { id, type, source: '', compiled: false };
    this.shaders.set(id, shader);
    return shader;
  }

  deleteShader(shader) {
    if (shader && this.shaders.has(shader.id)) {
      this.shaders.delete(shader.id);
    }
  }

  shaderSource(shader, source) {
    if (shader && this.shaders.has(shader.id)) {
      shader.source = source;
    }
  }

  compileShader(shader) {
    if (shader && this.shaders.has(shader.id)) {
      shader.compiled = true;
      // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã®æˆåŠŸã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    }
  }

  getShaderParameter(shader, pname) {
    if (pname === this.COMPILE_STATUS) {
      return true; // å¸¸ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æˆåŠŸ
    }
    return null;
  }

  getShaderInfoLog(shader) {
    return ''; // ã‚¨ãƒ©ãƒ¼ãªã—
  }

  // === ãƒ—ãƒ­ã‚°ãƒ©ãƒ ç®¡ç† ===
  
  createProgram() {
    const id = ++this.resourceCounters.programs;
    const program = { id, shaders: [], linked: false };
    this.programs.set(id, program);
    return program;
  }

  deleteProgram(program) {
    if (program && this.programs.has(program.id)) {
      this.programs.delete(program.id);
    }
  }

  attachShader(program, shader) {
    if (program && shader) {
      program.shaders.push(shader);
    }
  }

  linkProgram(program) {
    if (program) {
      program.linked = true;
    }
  }

  useProgram(program) {
    this.state.currentProgram = program;
  }

  getProgramParameter(program, pname) {
    if (pname === this.LINK_STATUS) {
      return true; // å¸¸ã«ãƒªãƒ³ã‚¯æˆåŠŸ
    }
    return null;
  }

  getProgramInfoLog(program) {
    return ''; // ã‚¨ãƒ©ãƒ¼ãªã—
  }

  // === å±æ€§ãƒ»ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ç®¡ç† ===
  
  getAttribLocation(program, name) {
    // å±æ€§åã«åŸºã¥ã„ã¦ä¸€æ„ã®ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿”ã™
    return name.length % 16; // 0-15ã®ç¯„å›²
  }

  getUniformLocation(program, name) {
    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ åã«åŸºã¥ã„ã¦ä¸€æ„ã®ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™
    return { name, program };
  }

  enableVertexAttribArray(index) {
    // å±æ€§é…åˆ—ã®æœ‰åŠ¹åŒ–ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  vertexAttribPointer(index, size, type, normalized, stride, offset) {
    // é ‚ç‚¹å±æ€§ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã®è¨­å®šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  uniform1f(location, value) {
    // float ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  uniform1i(location, value) {
    // int ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  uniform3fv(location, value) {
    // vec3 ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  uniform4fv(location, value) {
    // vec4 ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  uniformMatrix4fv(location, transpose, value) {
    // mat4 ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  // === ãƒ†ã‚¯ã‚¹ãƒãƒ£ç®¡ç† ===
  
  createTexture() {
    const id = ++this.resourceCounters.textures;
    const texture = { id, target: null, image: null };
    this.textures.set(id, texture);
    return texture;
  }

  deleteTexture(texture) {
    if (texture && this.textures.has(texture.id)) {
      this.textures.delete(texture.id);
    }
  }

  bindTexture(target, texture) {
    if (texture) {
      texture.target = target;
    }
  }

  texImage2D(target, level, internalformat, width, height, border, format, type, data) {
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è¨­å®šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  texParameteri(target, pname, param) {
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  activeTexture(texture) {
    this.state.activeTexture = texture;
  }

  // === ãƒ•ãƒ¬ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ç®¡ç† ===
  
  createFramebuffer() {
    const id = ++this.resourceCounters.framebuffers;
    const framebuffer = { id, attachments: {} };
    this.framebuffers.set(id, framebuffer);
    return framebuffer;
  }

  deleteFramebuffer(framebuffer) {
    if (framebuffer && this.framebuffers.has(framebuffer.id)) {
      this.framebuffers.delete(framebuffer.id);
    }
  }

  bindFramebuffer(target, framebuffer) {
    // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã®ãƒã‚¤ãƒ³ãƒ‰ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  framebufferTexture2D(target, attachment, textarget, texture, level) {
    // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ã‚¿ãƒƒãƒãƒ¡ãƒ³ãƒˆã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  // === ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒãƒƒãƒ•ã‚¡ç®¡ç† ===
  
  createRenderbuffer() {
    const id = ++this.resourceCounters.renderbuffers;
    const renderbuffer = { id };
    this.renderbuffers.set(id, renderbuffer);
    return renderbuffer;
  }

  deleteRenderbuffer(renderbuffer) {
    if (renderbuffer && this.renderbuffers.has(renderbuffer.id)) {
      this.renderbuffers.delete(renderbuffer.id);
    }
  }

  bindRenderbuffer(target, renderbuffer) {
    // ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒãƒƒãƒ•ã‚¡ã®ãƒã‚¤ãƒ³ãƒ‰ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  renderbufferStorage(target, internalformat, width, height) {
    // ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒãƒƒãƒ•ã‚¡ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®è¨­å®šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  // === æç”»é–¢æ•° ===
  
  clear(mask) {
    // ç”»é¢ã‚¯ãƒªã‚¢ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  clearColor(red, green, blue, alpha) {
    this.state.clearColor = [red, green, blue, alpha];
  }

  drawArrays(mode, first, count) {
    // é…åˆ—æç”»ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  drawElements(mode, count, type, offset) {
    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æç”»ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
  }

  // === çŠ¶æ…‹ç®¡ç† ===
  
  viewport(x, y, width, height) {
    this.state.viewport = [x, y, width, height];
  }

  enable(cap) {
    switch (cap) {
      case this.BLEND:
        this.state.blend = true;
        break;
      case this.DEPTH_TEST:
        this.state.depthTest = true;
        break;
      case this.CULL_FACE:
        this.state.cullFace = true;
        break;
    }
  }

  disable(cap) {
    switch (cap) {
      case this.BLEND:
        this.state.blend = false;
        break;
      case this.DEPTH_TEST:
        this.state.depthTest = false;
        break;
      case this.CULL_FACE:
        this.state.cullFace = false;
        break;
    }
  }

  blendFunc(sfactor, dfactor) {
    this.state.blendFunc = [sfactor, dfactor];
  }

  depthFunc(func) {
    this.state.depthFunc = func;
  }

  cullFace(mode) {
    this.state.cullFaceMode = mode;
  }

  // === æƒ…å ±å–å¾— ===
  
  getParameter(pname) {
    switch (pname) {
      case this.VENDOR:
        return 'Mock WebGL Vendor';
      case this.RENDERER:
        return 'Mock WebGL Renderer';
      case this.VERSION:
        return 'WebGL 1.0 Mock';
      case this.SHADING_LANGUAGE_VERSION:
        return 'WebGL GLSL ES 1.0 Mock';
      case this.MAX_TEXTURE_SIZE:
      case 3379:
        return 4096;
      case this.MAX_RENDERBUFFER_SIZE:
      case 34024:
        return 4096;
      case this.MAX_VERTEX_ATTRIBS:
      case 34921:
        return 16;
      default:
        return null;
    }
  }

  getError() {
    return this.NO_ERROR; // å¸¸ã«ã‚¨ãƒ©ãƒ¼ãªã—
  }

  getExtension(name) {
    // åŸºæœ¬çš„ãªæ‹¡å¼µæ©Ÿèƒ½ã®ãƒ¢ãƒƒã‚¯
    const extensions = {
      'WEBGL_debug_renderer_info': {
        UNMASKED_VENDOR_WEBGL: 37445,
        UNMASKED_RENDERER_WEBGL: 37446
      },
      'OES_texture_float': {},
      'OES_texture_half_float': {},
      'WEBGL_lose_context': {
        loseContext: () => {},
        restoreContext: () => {}
      }
    };
    return extensions[name] || null;
  }

  getSupportedExtensions() {
    return [
      'WEBGL_debug_renderer_info',
      'OES_texture_float',
      'OES_texture_half_float',
      'WEBGL_lose_context'
    ];
  }

  // === ãƒªã‚½ãƒ¼ã‚¹ç®¡ç† ===
  
  /**
   * ã™ã¹ã¦ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  cleanup() {
    this.programs.clear();
    this.shaders.clear();
    this.buffers.clear();
    this.textures.clear();
    this.framebuffers.clear();
    this.renderbuffers.clear();
    
    // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
    Object.keys(this.resourceCounters).forEach(key => {
      this.resourceCounters[key] = 0;
    });
    
    // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    this.state = {
      viewport: [0, 0, this.canvas.width, this.canvas.height],
      clearColor: [0, 0, 0, 1],
      activeTexture: this.TEXTURE0,
      currentProgram: null,
      blend: false,
      depthTest: true,
      cullFace: false
    };
  }

  /**
   * ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨çŠ¶æ³ã®å–å¾—
   */
  getResourceInfo() {
    return {
      programs: this.programs.size,
      shaders: this.shaders.size,
      buffers: this.buffers.size,
      textures: this.textures.size,
      framebuffers: this.framebuffers.size,
      renderbuffers: this.renderbuffers.size
    };
  }
}

/**
 * WebAssemblyãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®ãƒ¢ãƒƒã‚¯å®Ÿè£…
 */
class MockWebAssembly {
  constructor() {
    this.instances = new Map();
    this.modules = new Map();
  }

  /**
   * WebAssemblyãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ï¼ˆãƒ¢ãƒƒã‚¯ï¼‰
   */
  static async compile(bytes) {
    return new MockWebAssemblyModule(bytes);
  }

  /**
   * WebAssemblyã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½œæˆï¼ˆãƒ¢ãƒƒã‚¯ï¼‰
   */
  static async instantiate(moduleOrBytes, importObject) {
    let module;
    if (moduleOrBytes instanceof MockWebAssemblyModule) {
      module = moduleOrBytes;
    } else {
      module = await MockWebAssembly.compile(moduleOrBytes);
    }
    
    const instance = new MockWebAssemblyInstance(module, importObject);
    return { module, instance };
  }

  /**
   * WebAssemblyã®å¯¾å¿œç¢ºèª
   */
  static validate(bytes) {
    return true; // å¸¸ã«æœ‰åŠ¹ã¨ã™ã‚‹
  }
}

/**
 * WebAssemblyãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ¢ãƒƒã‚¯
 */
class MockWebAssemblyModule {
  constructor(bytes) {
    this.bytes = bytes;
    this.exports = ['memory', 'main', 'add', 'multiply']; // ãƒ€ãƒŸãƒ¼ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
  }

  static exports() {
    return ['memory', 'main', 'add', 'multiply'];
  }

  static imports() {
    return [];
  }
}

/**
 * WebAssemblyã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¢ãƒƒã‚¯
 */
class MockWebAssemblyInstance {
  constructor(module, importObject) {
    this.module = module;
    this.importObject = importObject;
    
    // ãƒ¢ãƒƒã‚¯ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆé–¢æ•°
    this.exports = {
      memory: new MockWebAssemblyMemory(),
      main: () => 0,
      add: (a, b) => a + b,
      multiply: (a, b) => a * b,
      // ãã®ä»–ã®ãƒ€ãƒŸãƒ¼é–¢æ•°
      allocate: (size) => 1024, // ãƒ€ãƒŸãƒ¼ãƒã‚¤ãƒ³ã‚¿
      deallocate: (ptr) => {},
      getString: (ptr, len) => 'mock string',
      setString: (ptr, str) => {}
    };
  }
}

/**
 * WebAssemblyãƒ¡ãƒ¢ãƒªã®ãƒ¢ãƒƒã‚¯
 */
class MockWebAssemblyMemory {
  constructor(descriptor = { initial: 1 }) {
    this.descriptor = descriptor;
    this.buffer = new ArrayBuffer(descriptor.initial * 65536); // 64KB pages
  }

  grow(delta) {
    const oldSize = this.buffer.byteLength;
    const newSize = oldSize + (delta * 65536);
    const newBuffer = new ArrayBuffer(newSize);
    new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
    this.buffer = newBuffer;
    return oldSize / 65536;
  }
}

/**
 * ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªWebGL/WebAssemblyãƒ¢ãƒƒã‚¯ã®è¨­å®š
 */
function setupWebGLMocks(global = globalThis) {
  // WebGLRenderingContextã®ãƒ¢ãƒƒã‚¯
  global.WebGLRenderingContext = MockWebGLRenderingContext;
  
  // WebGL2RenderingContextã®ãƒ¢ãƒƒã‚¯ï¼ˆWebGL2å¯¾å¿œï¼‰
  global.WebGL2RenderingContext = class extends MockWebGLRenderingContext {
    constructor(canvas) {
      super(canvas);
      this.version = 2;
    }
    
    getParameter(pname) {
      if (pname === this.VERSION) {
        return 'WebGL 2.0 Mock';
      }
      return super.getParameter(pname);
    }
  };
  
  // HTMLCanvasElementã®ãƒ¢ãƒƒã‚¯
  if (!global.HTMLCanvasElement) {
    global.HTMLCanvasElement = class MockHTMLCanvasElement {
      constructor() {
        this.width = 300;
        this.height = 150;
        this.clientWidth = 300;
        this.clientHeight = 150;
      }
      
      getContext(contextId, options) {
        if (contextId === 'webgl' || contextId === 'experimental-webgl') {
          return new MockWebGLRenderingContext(this);
        }
        if (contextId === 'webgl2') {
          return new global.WebGL2RenderingContext(this);
        }
        return null;
      }
      
      addEventListener() {}
      removeEventListener() {}
    };
  }
  
  // WebAssemblyã®ãƒ¢ãƒƒã‚¯
  global.WebAssembly = MockWebAssembly;
  global.WebAssembly.Module = MockWebAssemblyModule;
  global.WebAssembly.Instance = MockWebAssemblyInstance;
  global.WebAssembly.Memory = MockWebAssemblyMemory;
  
  // ImageDataã®ãƒ¢ãƒƒã‚¯
  if (!global.ImageData) {
    global.ImageData = class MockImageData {
      constructor(dataOrWidth, widthOrHeight, height) {
        if (typeof dataOrWidth === 'object') {
          this.data = dataOrWidth;
          this.width = widthOrHeight;
          this.height = height;
        } else {
          this.width = dataOrWidth;
          this.height = widthOrHeight;
          this.data = new Uint8ClampedArray(this.width * this.height * 4);
        }
      }
    };
  }
}

/**
 * ãƒ†ã‚¹ãƒˆç’°å¢ƒã§ã®ãƒ¢ãƒƒã‚¯åˆæœŸåŒ–
 */
function initializeTestMocks() {
  setupWebGLMocks();
  
  // documentã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¢ãƒƒã‚¯ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
  if (typeof document === 'undefined') {
    global.document = {
      createElement: (tagName) => {
        if (tagName === 'canvas') {
          return new global.HTMLCanvasElement();
        }
        return { tagName };
      },
      getElementById: () => new global.HTMLCanvasElement(),
      addEventListener: () => {},
      removeEventListener: () => {}
    };
  }
  
  // windowã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¢ãƒƒã‚¯ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
  if (typeof window === 'undefined') {
    global.window = {
      ...global,
      addEventListener: () => {},
      removeEventListener: () => {},
      innerWidth: 1024,
      innerHeight: 768,
      devicePixelRatio: 1
    };
  }
}

module.exports = {
  MockWebGLRenderingContext,
  MockWebAssembly,
  MockWebAssemblyModule,
  MockWebAssemblyInstance,
  MockWebAssemblyMemory,
  setupWebGLMocks,
  initializeTestMocks
};
</file>

<file path="three-test-suite/src/utils/TestDataGenerator.js">
/**
 * ãƒ†ã‚¹ãƒˆç’°å¢ƒå°‚ç”¨ã®ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
 * å†ç¾å¯èƒ½ãªãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆã¨ãƒ†ã‚¹ãƒˆé–“ã§ã®ãƒ‡ãƒ¼ã‚¿æ±šæŸ“é˜²æ­¢
 */

class TestDataGenerator {
  constructor(seed = 12345) {
    this.seed = seed;
    this.resetSeed();
    this.counters = new Map();
  }

  /**
   * ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å†ç¾å¯èƒ½ãªä¹±æ•°ç”Ÿæˆã‚’ç¢ºä¿
   */
  resetSeed() {
    this.currentSeed = this.seed;
  }

  /**
   * ã‚·ãƒ¼ãƒ‰ä»˜ãä¹±æ•°ç”Ÿæˆå™¨ï¼ˆç·šå½¢åˆåŒæ³•ï¼‰
   */
  random() {
    this.currentSeed = (this.currentSeed * 1664525 + 1013904223) % 4294967296;
    return this.currentSeed / 4294967296;
  }

  /**
   * æŒ‡å®šç¯„å›²å†…ã®æ•´æ•°ã‚’ç”Ÿæˆ
   */
  randomInt(min = 0, max = 100) {
    return Math.floor(this.random() * (max - min + 1)) + min;
  }

  /**
   * æŒ‡å®šç¯„å›²å†…ã®æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ç”Ÿæˆ
   */
  randomFloat(min = 0, max = 1) {
    return this.random() * (max - min) + min;
  }

  /**
   * ä¸€æ„ãªIDã‚’ç”Ÿæˆ
   */
  generateUniqueId(prefix = 'test') {
    const current = this.counters.get(prefix) || 0;
    const newValue = current + 1;
    this.counters.set(prefix, newValue);
    return `${prefix}-${newValue}`;
  }

  /**
   * Three.jsç”¨ã®ãƒ™ã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateVector3(minRange = -10, maxRange = 10) {
    return {
      x: this.randomFloat(minRange, maxRange),
      y: this.randomFloat(minRange, maxRange),
      z: this.randomFloat(minRange, maxRange)
    };
  }

  /**
   * Three.jsç”¨ã®è‰²ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateColor() {
    return {
      r: this.random(),
      g: this.random(),
      b: this.random(),
      hex: Math.floor(this.random() * 0xffffff)
    };
  }

  /**
   * Three.jsç”¨ã®ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateMaterialData(type = 'basic') {
    const baseData = {
      id: this.generateUniqueId('material'),
      type,
      color: this.generateColor().hex,
      transparent: this.random() > 0.5,
      opacity: this.randomFloat(0.1, 1.0)
    };

    switch (type) {
      case 'standard':
        return {
          ...baseData,
          metalness: this.random(),
          roughness: this.random(),
          emissive: this.generateColor().hex
        };
      case 'physical':
        return {
          ...baseData,
          metalness: this.random(),
          roughness: this.random(),
          clearcoat: this.random(),
          clearcoatRoughness: this.random()
        };
      case 'lambert':
        return {
          ...baseData,
          emissive: this.generateColor().hex
        };
      default:
        return baseData;
    }
  }

  /**
   * Three.jsç”¨ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateGeometryData(type = 'box') {
    const baseData = {
      id: this.generateUniqueId('geometry'),
      type
    };

    switch (type) {
      case 'box':
        return {
          ...baseData,
          width: this.randomFloat(0.5, 5.0),
          height: this.randomFloat(0.5, 5.0),
          depth: this.randomFloat(0.5, 5.0),
          widthSegments: this.randomInt(1, 10),
          heightSegments: this.randomInt(1, 10),
          depthSegments: this.randomInt(1, 10)
        };
      case 'sphere':
        return {
          ...baseData,
          radius: this.randomFloat(0.5, 3.0),
          widthSegments: this.randomInt(8, 32),
          heightSegments: this.randomInt(6, 16),
          phiStart: 0,
          phiLength: Math.PI * 2,
          thetaStart: 0,
          thetaLength: Math.PI
        };
      case 'plane':
        return {
          ...baseData,
          width: this.randomFloat(1.0, 10.0),
          height: this.randomFloat(1.0, 10.0),
          widthSegments: this.randomInt(1, 20),
          heightSegments: this.randomInt(1, 20)
        };
      case 'cylinder':
        return {
          ...baseData,
          radiusTop: this.randomFloat(0.5, 2.0),
          radiusBottom: this.randomFloat(0.5, 2.0),
          height: this.randomFloat(1.0, 5.0),
          radialSegments: this.randomInt(8, 32),
          heightSegments: this.randomInt(1, 10)
        };
      default:
        return baseData;
    }
  }

  /**
   * Three.jsç”¨ã®ãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateLightData(type = 'directional') {
    const baseData = {
      id: this.generateUniqueId('light'),
      type,
      color: this.generateColor().hex,
      intensity: this.randomFloat(0.1, 2.0),
      position: this.generateVector3(-20, 20),
      castShadow: this.random() > 0.5
    };

    switch (type) {
      case 'point':
        return {
          ...baseData,
          distance: this.randomFloat(10, 100),
          decay: this.randomFloat(1, 3)
        };
      case 'spot':
        return {
          ...baseData,
          distance: this.randomFloat(10, 100),
          angle: this.randomFloat(0.1, Math.PI / 3),
          penumbra: this.randomFloat(0, 1),
          decay: this.randomFloat(1, 3),
          target: this.generateVector3(-5, 5)
        };
      case 'hemisphere':
        return {
          ...baseData,
          groundColor: this.generateColor().hex,
          intensity: this.randomFloat(0.1, 1.0)
        };
      default:
        return baseData;
    }
  }

  /**
   * Three.jsç”¨ã®ã‚«ãƒ¡ãƒ©ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateCameraData(type = 'perspective') {
    const baseData = {
      id: this.generateUniqueId('camera'),
      type,
      position: this.generateVector3(-20, 20),
      target: this.generateVector3(-5, 5)
    };

    switch (type) {
      case 'perspective':
        return {
          ...baseData,
          fov: this.randomFloat(30, 120),
          aspect: this.randomFloat(0.5, 2.0),
          near: this.randomFloat(0.01, 1.0),
          far: this.randomFloat(100, 2000)
        };
      case 'orthographic':
        return {
          ...baseData,
          left: this.randomFloat(-10, -1),
          right: this.randomFloat(1, 10),
          top: this.randomFloat(1, 10),
          bottom: this.randomFloat(-10, -1),
          near: this.randomFloat(0.01, 1.0),
          far: this.randomFloat(100, 2000)
        };
      default:
        return baseData;
    }
  }

  /**
   * Three.jsç”¨ã®ãƒ¡ãƒƒã‚·ãƒ¥ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateMeshData(options = {}) {
    const {
      geometryType = 'box',
      materialType = 'basic',
      includeTransform = true
    } = options;

    const mesh = {
      id: this.generateUniqueId('mesh'),
      geometry: this.generateGeometryData(geometryType),
      material: this.generateMaterialData(materialType)
    };

    if (includeTransform) {
      mesh.position = this.generateVector3(-10, 10);
      mesh.rotation = {
        x: this.randomFloat(0, Math.PI * 2),
        y: this.randomFloat(0, Math.PI * 2),
        z: this.randomFloat(0, Math.PI * 2)
      };
      mesh.scale = {
        x: this.randomFloat(0.5, 2.0),
        y: this.randomFloat(0.5, 2.0),
        z: this.randomFloat(0.5, 2.0)
      };
    }

    return mesh;
  }

  /**
   * Three.jsç”¨ã®ã‚·ãƒ¼ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateSceneData(complexity = 'medium') {
    const scene = {
      id: this.generateUniqueId('scene'),
      background: this.generateColor().hex,
      fog: {
        type: this.random() > 0.5 ? 'linear' : 'exponential',
        color: this.generateColor().hex,
        near: this.randomFloat(1, 50),
        far: this.randomFloat(100, 1000),
        density: this.randomFloat(0.001, 0.01)
      },
      objects: [],
      lights: [],
      cameras: []
    };

    // è¤‡é›‘ã•ã«å¿œã˜ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°ã‚’èª¿æ•´
    let objectCount, lightCount;
    switch (complexity) {
      case 'simple':
        objectCount = this.randomInt(1, 3);
        lightCount = this.randomInt(1, 2);
        break;
      case 'complex':
        objectCount = this.randomInt(20, 50);
        lightCount = this.randomInt(3, 8);
        break;
      default: // medium
        objectCount = this.randomInt(5, 15);
        lightCount = this.randomInt(2, 4);
    }

    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆ
    const geometryTypes = ['box', 'sphere', 'plane', 'cylinder'];
    const materialTypes = ['basic', 'standard', 'lambert', 'physical'];
    
    for (let i = 0; i < objectCount; i++) {
      const geometryType = geometryTypes[this.randomInt(0, geometryTypes.length - 1)];
      const materialType = materialTypes[this.randomInt(0, materialTypes.length - 1)];
      scene.objects.push(this.generateMeshData({ geometryType, materialType }));
    }

    // ãƒ©ã‚¤ãƒˆã®ç”Ÿæˆ
    const lightTypes = ['directional', 'point', 'spot', 'hemisphere'];
    for (let i = 0; i < lightCount; i++) {
      const lightType = lightTypes[this.randomInt(0, lightTypes.length - 1)];
      scene.lights.push(this.generateLightData(lightType));
    }

    // ã‚«ãƒ¡ãƒ©ã®ç”Ÿæˆ
    scene.cameras.push(this.generateCameraData('perspective'));
    if (this.random() > 0.7) {
      scene.cameras.push(this.generateCameraData('orthographic'));
    }

    return scene;
  }

  /**
   * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generatePerformanceTestData(testType = 'render') {
    const baseData = {
      id: this.generateUniqueId('perf-test'),
      type: testType,
      timestamp: Date.now(),
      expectedDuration: this.randomInt(100, 5000), // ms
      memoryBudget: this.randomInt(50, 500) // MB
    };

    switch (testType) {
      case 'render':
        return {
          ...baseData,
          triangleCount: this.randomInt(1000, 100000),
          drawCalls: this.randomInt(10, 500),
          textureMemory: this.randomInt(10, 200), // MB
          expectedFPS: this.randomInt(30, 120)
        };
      case 'load':
        return {
          ...baseData,
          fileSize: this.randomInt(1, 100), // MB
          assetCount: this.randomInt(5, 100),
          expectedLoadTime: this.randomInt(500, 10000), // ms
          compressionRatio: this.randomFloat(0.1, 0.8)
        };
      case 'animation':
        return {
          ...baseData,
          frameCount: this.randomInt(60, 1800), // 1-30ç§’ @ 60fps
          objectCount: this.randomInt(10, 200),
          keyframeCount: this.randomInt(5, 50),
          easing: ['linear', 'ease-in', 'ease-out', 'ease-in-out'][this.randomInt(0, 3)]
        };
      case 'physics':
        return {
          ...baseData,
          bodyCount: this.randomInt(10, 1000),
          constraintCount: this.randomInt(5, 500),
          simulationSteps: this.randomInt(1, 10),
          worldSize: this.randomFloat(10, 1000)
        };
      default:
        return baseData;
    }
  }

  /**
   * ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateTextureData(type = 'image') {
    const baseData = {
      id: this.generateUniqueId('texture'),
      type,
      width: Math.pow(2, this.randomInt(4, 10)), // 16-1024
      height: Math.pow(2, this.randomInt(4, 10)), // 16-1024
      format: ['RGB', 'RGBA', 'Luminance', 'LuminanceAlpha'][this.randomInt(0, 3)],
      wrapS: ['Repeat', 'ClampToEdge', 'MirroredRepeat'][this.randomInt(0, 2)],
      wrapT: ['Repeat', 'ClampToEdge', 'MirroredRepeat'][this.randomInt(0, 2)],
      magFilter: ['Nearest', 'Linear'][this.randomInt(0, 1)],
      minFilter: ['Nearest', 'Linear', 'NearestMipmapNearest', 'LinearMipmapLinear'][this.randomInt(0, 3)]
    };

    switch (type) {
      case 'image':
        return {
          ...baseData,
          src: `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==`, // 1x1 transparent PNG
          flipY: this.random() > 0.5,
          premultiplyAlpha: this.random() > 0.5
        };
      case 'canvas':
        return {
          ...baseData,
          canvas: null, // ãƒ¢ãƒƒã‚¯canvasè¦ç´ ã¸ã®å‚ç…§
          needsUpdate: true
        };
      case 'data':
        return {
          ...baseData,
          data: new Uint8Array(baseData.width * baseData.height * 4).fill(255), // ç™½ã„ãƒ†ã‚¯ã‚¹ãƒãƒ£
          needsUpdate: true
        };
      case 'cube':
        return {
          ...baseData,
          images: Array(6).fill(null).map(() => ({
            src: baseData.src,
            width: baseData.width,
            height: baseData.height
          }))
        };
      default:
        return baseData;
    }
  }

  /**
   * ã‚¨ãƒ©ãƒ¼ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateErrorTestData(errorType = 'webgl') {
    const baseData = {
      id: this.generateUniqueId('error-test'),
      type: errorType,
      shouldFail: true,
      expectedError: null
    };

    switch (errorType) {
      case 'webgl':
        return {
          ...baseData,
          expectedError: ['INVALID_OPERATION', 'OUT_OF_MEMORY', 'INVALID_VALUE'][this.randomInt(0, 2)],
          contextLost: this.random() > 0.7,
          extensionMissing: this.random() > 0.8
        };
      case 'shader':
        return {
          ...baseData,
          expectedError: 'COMPILE_ERROR',
          shaderType: ['vertex', 'fragment'][this.randomInt(0, 1)],
          syntaxError: this.random() > 0.5,
          linkError: this.random() > 0.3
        };
      case 'texture':
        return {
          ...baseData,
          expectedError: 'TEXTURE_SIZE_ERROR',
          oversized: this.random() > 0.5,
          invalidFormat: this.random() > 0.6,
          corrupted: this.random() > 0.4
        };
      case 'memory':
        return {
          ...baseData,
          expectedError: 'OUT_OF_MEMORY',
          allocSize: this.randomInt(100, 2000), // MB
          fragmentedMemory: this.random() > 0.5
        };
      default:
        return baseData;
    }
  }

  /**
   * ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆç”¨ã®è¨­å®šãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
   */
  generateTestSuiteConfig(suiteName = 'default') {
    return {
      id: this.generateUniqueId('test-suite'),
      name: suiteName,
      timeout: this.randomInt(5000, 30000), // 5-30ç§’
      retries: this.randomInt(0, 3),
      parallel: this.random() > 0.5,
      headless: this.random() > 0.3,
      viewport: {
        width: [800, 1024, 1280, 1920][this.randomInt(0, 3)],
        height: [600, 768, 720, 1080][this.randomInt(0, 3)]
      },
      deviceScaleFactor: [1, 1.5, 2][this.randomInt(0, 2)],
      environment: {
        webglVersion: this.randomInt(1, 2),
        extensions: this.generateWebGLExtensions(),
        maxTextureSize: Math.pow(2, this.randomInt(10, 14)), // 1024-16384
        maxRenderbufferSize: Math.pow(2, this.randomInt(10, 14))
      },
      performance: {
        memoryLimit: this.randomInt(100, 1000), // MB
        timeLimit: this.randomInt(10, 300), // ç§’
        fpsThreshold: this.randomInt(30, 60)
      }
    };
  }

  /**
   * WebGLæ‹¡å¼µæ©Ÿèƒ½ã®ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ
   */
  generateWebGLExtensions() {
    const availableExtensions = [
      'WEBGL_debug_renderer_info',
      'OES_texture_float',
      'OES_texture_half_float',
      'WEBGL_lose_context',
      'OES_standard_derivatives',
      'OES_vertex_array_object',
      'WEBGL_depth_texture',
      'EXT_texture_filter_anisotropic',
      'WEBGL_compressed_texture_s3tc',
      'WEBGL_compressed_texture_pvrtc'
    ];

    const extensionCount = this.randomInt(3, availableExtensions.length);
    const selectedExtensions = [];
    
    for (let i = 0; i < extensionCount; i++) {
      const index = this.randomInt(0, availableExtensions.length - 1);
      if (!selectedExtensions.includes(availableExtensions[index])) {
        selectedExtensions.push(availableExtensions[index]);
      }
    }

    return selectedExtensions;
  }

  /**
   * ã™ã¹ã¦ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
   */
  resetCounters() {
    this.counters.clear();
    this.resetSeed();
  }

  /**
   * ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
   */
  saveState() {
    return {
      seed: this.seed,
      currentSeed: this.currentSeed,
      counters: new Map(this.counters)
    };
  }

  /**
   * çŠ¶æ…‹ã‚’å¾©å…ƒ
   */
  restoreState(state) {
    this.seed = state.seed;
    this.currentSeed = state.currentSeed;
    this.counters = new Map(state.counters);
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®æ•´åˆæ€§ã‚’æ¤œè¨¼
   */
  validateDataset(dataset) {
    const errors = [];
    
    try {
      // åŸºæœ¬çš„ãªæ§‹é€ ãƒã‚§ãƒƒã‚¯
      if (!dataset || typeof dataset !== 'object') {
        errors.push('Dataset must be an object');
        return errors;
      }

      // IDã®ä¸€æ„æ€§ãƒã‚§ãƒƒã‚¯
      const ids = new Set();
      const checkIds = (obj, path = '') => {
        if (obj && typeof obj === 'object') {
          if (obj.id) {
            if (ids.has(obj.id)) {
              errors.push(`Duplicate ID found: ${obj.id} at ${path}`);
            } else {
              ids.add(obj.id);
            }
          }
          
          // å†å¸°çš„ã«ãƒã‚§ãƒƒã‚¯
          Object.keys(obj).forEach(key => {
            if (Array.isArray(obj[key])) {
              obj[key].forEach((item, index) => {
                checkIds(item, `${path}.${key}[${index}]`);
              });
            } else if (typeof obj[key] === 'object') {
              checkIds(obj[key], `${path}.${key}`);
            }
          });
        }
      };

      checkIds(dataset);

    } catch (error) {
      errors.push(`Validation error: ${error.message}`);
    }

    return errors;
  }
}

/**
 * ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
 */
class TestDataFactory {
  constructor() {
    this.generators = new Map();
    this.presets = new Map();
    this.initializePresets();
  }

  /**
   * ãƒ—ãƒªã‚»ãƒƒãƒˆã®åˆæœŸåŒ–
   */
  initializePresets() {
    // åŸºæœ¬çš„ãªãƒ—ãƒªã‚»ãƒƒãƒˆ
    this.presets.set('minimal', {
      seed: 12345,
      sceneComplexity: 'simple',
      objectCount: 1,
      lightCount: 1
    });

    this.presets.set('standard', {
      seed: 54321,
      sceneComplexity: 'medium',
      objectCount: 10,
      lightCount: 3
    });

    this.presets.set('stress', {
      seed: 98765,
      sceneComplexity: 'complex',
      objectCount: 100,
      lightCount: 10
    });

    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆç”¨
    this.presets.set('performance', {
      seed: 11111,
      generatePerformanceData: true,
      testTypes: ['render', 'load', 'animation', 'physics']
    });

    // ã‚¨ãƒ©ãƒ¼ãƒ†ã‚¹ãƒˆç”¨
    this.presets.set('error', {
      seed: 99999,
      generateErrors: true,
      errorTypes: ['webgl', 'shader', 'texture', 'memory']
    });
  }

  /**
   * æŒ‡å®šã•ã‚ŒãŸãƒ—ãƒªã‚»ãƒƒãƒˆã§ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä½œæˆ
   */
  createGenerator(presetName = 'standard', customSeed = null) {
    const preset = this.presets.get(presetName) || this.presets.get('standard');
    const seed = customSeed || preset.seed;
    
    const generator = new TestDataGenerator(seed);
    this.generators.set(`${presetName}-${seed}`, generator);
    
    return generator;
  }

  /**
   * ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆå…¨ä½“ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’ç”Ÿæˆ
   */
  generateTestSuite(presetName = 'standard', testCount = 10) {
    const generator = this.createGenerator(presetName);
    const preset = this.presets.get(presetName);
    
    const testSuite = {
      id: generator.generateUniqueId('test-suite'),
      name: presetName,
      config: generator.generateTestSuiteConfig(presetName),
      tests: []
    };

    for (let i = 0; i < testCount; i++) {
      const test = {
        id: generator.generateUniqueId('test'),
        name: `${presetName}-test-${i + 1}`,
        scene: generator.generateSceneData(preset.sceneComplexity),
        data: {}
      };

      // ãƒ—ãƒªã‚»ãƒƒãƒˆã«å¿œã˜ã¦è¿½åŠ ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
      if (preset.generatePerformanceData) {
        test.data.performance = preset.testTypes.map(type => 
          generator.generatePerformanceTestData(type)
        );
      }

      if (preset.generateErrors) {
        test.data.errors = preset.errorTypes.map(type => 
          generator.generateErrorTestData(type)
        );
      }

      testSuite.tests.push(test);
    }

    return testSuite;
  }

  /**
   * ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  cleanupGenerators() {
    this.generators.clear();
  }

  /**
   * ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒªã‚»ãƒƒãƒˆã®è¿½åŠ 
   */
  addPreset(name, config) {
    this.presets.set(name, config);
  }

  /**
   * åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒªã‚»ãƒƒãƒˆã®ä¸€è¦§ã‚’å–å¾—
   */
  getAvailablePresets() {
    return Array.from(this.presets.keys());
  }
}

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
const testDataFactory = new TestDataFactory();

module.exports = {
  TestDataGenerator,
  TestDataFactory,
  testDataFactory
};
</file>

<file path="three-test-suite/src/utils/TestIsolationHelper.js">
/**
 * çµ±åˆãƒ†ã‚¹ãƒˆç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
 * Phase2ã§ä½œæˆã—ãŸãƒ¢ãƒƒã‚¯ã¨ãƒ‡ãƒ¼ã‚¿ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’çµ±åˆã—ã€
 * ãƒ†ã‚¹ãƒˆé–“ã®å®Œå…¨ãªç‹¬ç«‹æ€§ã‚’ç¢ºä¿ã™ã‚‹
 */

import MockBrowserManager from '../mocks/MockBrowserManager.js';
import { TestDataGenerator, testDataFactory } from '../utils/TestDataGenerator.js';
import { initializeTestMocks, setupWebGLMocks } from '../mocks/MockWebGL.js';

/**
 * ãƒ†ã‚¹ãƒˆç‹¬ç«‹æ€§ç¢ºä¿ã®ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹
 */
class TestIsolationHelper {
  constructor(testName = 'default', options = {}) {
    this.testName = testName;
    this.options = {
      seed: Date.now() + Math.random(),
      autoCleanup: true,
      enablePerformanceTracking: false,
      enableResourceTracking: true,
      ...options
    };
    
    this.dataGenerator = new TestDataGenerator(this.options.seed);
    this.browserManager = null;
    this.resourceTracker = new ResourceTracker();
    this.performanceTracker = new PerformanceTracker();
    this.isSetup = false;
  }

  /**
   * ãƒ†ã‚¹ãƒˆç’°å¢ƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
   */
  async setup() {
    if (this.isSetup) {
      throw new Error('TestIsolationHelper already setup');
    }

    // ãƒ¢ãƒƒã‚¯ç’°å¢ƒã®åˆæœŸåŒ–
    initializeTestMocks();
    
    // ãƒ–ãƒ©ã‚¦ã‚¶ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ä½œæˆ
    const testConfig = this.dataGenerator.generateTestSuiteConfig(this.testName);
    this.browserManager = new MockBrowserManager(testConfig.viewport);
    
    await this.browserManager.initialize();
    
    // ãƒªã‚½ãƒ¼ã‚¹è¿½è·¡ã®é–‹å§‹
    if (this.options.enableResourceTracking) {
      this.resourceTracker.startTracking();
    }
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¿½è·¡ã®é–‹å§‹
    if (this.options.enablePerformanceTracking) {
      this.performanceTracker.startTracking();
    }
    
    this.isSetup = true;
    return this;
  }

  /**
   * ãƒ†ã‚¹ãƒˆç’°å¢ƒã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  async cleanup() {
    if (!this.isSetup) {
      return;
    }

    try {
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¿½è·¡ã®åœæ­¢
      if (this.options.enablePerformanceTracking) {
        this.performanceTracker.stopTracking();
      }
      
      // ãƒªã‚½ãƒ¼ã‚¹è¿½è·¡ã®åœæ­¢
      if (this.options.enableResourceTracking) {
        this.resourceTracker.stopTracking();
      }
      
      // ãƒ–ãƒ©ã‚¦ã‚¶ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      if (this.browserManager) {
        await this.browserManager.cleanup();
        this.browserManager = null;
      }
      
      // ãƒ‡ãƒ¼ã‚¿ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ãƒªã‚»ãƒƒãƒˆ
      this.dataGenerator.resetCounters();
      
    } finally {
      this.isSetup = false;
    }
  }

  /**
   * Three.jsã‚·ãƒ¼ãƒ³ã®ãƒ†ã‚¹ãƒˆç”¨HTMLã‚’ç”Ÿæˆ
   */
  generateThreeJSTestHTML(sceneSetupFunction, options = {}) {
    if (!this.isSetup) {
      throw new Error('TestIsolationHelper not setup. Call setup() first.');
    }

    const config = {
      threeJsVersion: 'r128',
      title: `Three.js Test - ${this.testName}`,
      autoExecute: true,
      enableWebGL: true,
      ...options
    };

    const sceneScript = sceneSetupFunction.toString();
    
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${config.title}</title>
        <style>
          body { margin: 0; padding: 0; overflow: hidden; background: #000; }
          canvas { display: block; width: 100vw; height: 100vh; }
        </style>
      </head>
      <body>
        <canvas id="three-canvas"></canvas>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/${config.threeJsVersion}/three.min.js"></script>
        <script>
          // ãƒ†ã‚¹ãƒˆç‹¬ç«‹æ€§ç¢ºä¿ã®ãŸã‚ã®åˆæœŸåŒ–
          window.testIsolation = {
            testName: '${this.testName}',
            seed: ${this.options.seed},
            startTime: performance.now()
          };
          
          // WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®åˆæœŸåŒ–ç¢ºèª
          function ensureWebGLContext() {
            const canvas = document.getElementById('three-canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
              throw new Error('WebGL not supported');
            }
            return gl;
          }
          
          // Three.jsç’°å¢ƒã®ç¢ºèª
          function ensureThreeJS() {
            if (typeof THREE === 'undefined') {
              throw new Error('THREE.js not loaded');
            }
            return THREE;
          }
          
          ${config.autoExecute ? `
            window.addEventListener('load', function() {
              try {
                ensureWebGLContext();
                ensureThreeJS();
                
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã®ã‚·ãƒ¼ãƒ³ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—é–¢æ•°ã‚’å®Ÿè¡Œ
                (${sceneScript})();
                
                window.testIsolation.endTime = performance.now();
                window.testIsolation.duration = window.testIsolation.endTime - window.testIsolation.startTime;
                window.testIsolation.success = true;
                
              } catch (error) {
                window.testIsolation.error = error.message;
                window.testIsolation.success = false;
                console.error('Test execution error:', error);
              }
            });
          ` : ''}
        </script>
      </body>
      </html>
    `;
  }

  /**
   * ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆ
   */
  generateTestData(type, complexity = 'medium') {
    switch (type) {
      case 'scene':
        return this.dataGenerator.generateSceneData(complexity);
      case 'mesh':
        return this.dataGenerator.generateMeshData();
      case 'material':
        return this.dataGenerator.generateMaterialData();
      case 'geometry':
        return this.dataGenerator.generateGeometryData();
      case 'light':
        return this.dataGenerator.generateLightData();
      case 'camera':
        return this.dataGenerator.generateCameraData();
      case 'texture':
        return this.dataGenerator.generateTextureData();
      case 'performance':
        return this.dataGenerator.generatePerformanceTestData();
      case 'error':
        return this.dataGenerator.generateErrorTestData();
      default:
        throw new Error(`Unknown test data type: ${type}`);
    }
  }

  /**
   * ãƒšãƒ¼ã‚¸ã§ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
   */
  async executeScript(script) {
    if (!this.browserManager || !this.browserManager.page) {
      throw new Error('Browser manager not initialized');
    }

    return await this.browserManager.page.evaluate(script);
  }

  /**
   * ãƒ†ã‚¹ãƒˆçµæœã®å–å¾—
   */
  async getTestResult() {
    return await this.executeScript(() => window.testIsolation);
  }

  /**
   * ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨çŠ¶æ³ã®å–å¾—
   */
  getResourceUsage() {
    return this.resourceTracker.getUsage();
  }

  /**
   * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã®å–å¾—
   */
  getPerformanceInfo() {
    return this.performanceTracker.getInfo();
  }

  /**
   * ãƒ†ã‚¹ãƒˆã®çŠ¶æ…‹ã‚’ã‚¢ã‚µãƒ¼ãƒˆ
   */
  async assertTestState(expectations = {}) {
    const result = await this.getTestResult();
    
    if (expectations.shouldSucceed !== false && !result.success) {
      throw new Error(`Test failed: ${result.error}`);
    }
    
    if (expectations.maxDuration && result.duration > expectations.maxDuration) {
      throw new Error(`Test took too long: ${result.duration}ms > ${expectations.maxDuration}ms`);
    }
    
    if (expectations.minDuration && result.duration < expectations.minDuration) {
      throw new Error(`Test completed too quickly: ${result.duration}ms < ${expectations.minDuration}ms`);
    }
    
    return result;
  }
}

/**
 * ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨çŠ¶æ³ã®è¿½è·¡
 */
class ResourceTracker {
  constructor() {
    this.isTracking = false;
    this.startSnapshot = null;
    this.usage = {
      browserInstances: 0,
      memoryEstimate: 0,
      startTime: null,
      endTime: null
    };
  }

  startTracking() {
    this.isTracking = true;
    this.startSnapshot = {
      browserInstances: MockBrowserManager.getActiveInstanceCount(),
      timestamp: Date.now()
    };
    this.usage.startTime = this.startSnapshot.timestamp;
  }

  stopTracking() {
    if (!this.isTracking) return;
    
    this.usage.endTime = Date.now();
    this.usage.browserInstances = MockBrowserManager.getActiveInstanceCount() - this.startSnapshot.browserInstances;
    this.usage.memoryEstimate = this.estimateMemoryUsage();
    this.isTracking = false;
  }

  estimateMemoryUsage() {
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®ç°¡æ˜“æ¨å®šï¼ˆãƒ¢ãƒƒã‚¯ç’°å¢ƒï¼‰
    const activeInstances = MockBrowserManager.getActiveInstanceCount();
    return activeInstances * 50; // 1ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚ãŸã‚Šç´„50MBã¨ä»®å®š
  }

  getUsage() {
    return { ...this.usage };
  }
}

/**
 * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã®è¿½è·¡
 */
class PerformanceTracker {
  constructor() {
    this.isTracking = false;
    this.metrics = {
      startTime: null,
      endTime: null,
      duration: null,
      cpuUsage: [],
      memorySnapshots: [],
      frameTimings: []
    };
  }

  startTracking() {
    this.isTracking = true;
    this.metrics.startTime = performance.now();
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã®é–‹å§‹ï¼ˆãƒ¢ãƒƒã‚¯ç’°å¢ƒã§ã¯ç°¡æ˜“å®Ÿè£…ï¼‰
    this.monitoringInterval = setInterval(() => {
      if (this.isTracking) {
        this.collectMetrics();
      }
    }, 100);
  }

  stopTracking() {
    if (!this.isTracking) return;
    
    this.metrics.endTime = performance.now();
    this.metrics.duration = this.metrics.endTime - this.metrics.startTime;
    this.isTracking = false;
    
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }
  }

  collectMetrics() {
    const now = performance.now();
    
    // CPUä½¿ç”¨ç‡ã®ç°¡æ˜“æ¨å®šï¼ˆãƒ¢ãƒƒã‚¯ç’°å¢ƒï¼‰
    this.metrics.cpuUsage.push({
      timestamp: now,
      usage: Math.random() * 100 // 0-100%ã®ãƒ©ãƒ³ãƒ€ãƒ å€¤
    });
    
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®ç°¡æ˜“æ¨å®š
    this.metrics.memorySnapshots.push({
      timestamp: now,
      used: MockBrowserManager.getActiveInstanceCount() * 50,
      total: 1000 // 1GBä»®å®š
    });
    
    // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®è¨˜éŒ²
    this.metrics.frameTimings.push({
      timestamp: now,
      frameTime: 16.67 + (Math.random() - 0.5) * 2 // 60fps Â± 1ms
    });
  }

  getInfo() {
    return {
      ...this.metrics,
      averageCpuUsage: this.calculateAverage(this.metrics.cpuUsage, 'usage'),
      averageMemoryUsage: this.calculateAverage(this.metrics.memorySnapshots, 'used'),
      averageFrameTime: this.calculateAverage(this.metrics.frameTimings, 'frameTime')
    };
  }

  calculateAverage(array, property) {
    if (array.length === 0) return 0;
    const sum = array.reduce((acc, item) => acc + item[property], 0);
    return sum / array.length;
  }
}

/**
 * ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼é–¢æ•°
 */
function createTestIsolation(testName, options = {}) {
  return new TestIsolationHelper(testName, options);
}

/**
 * Jestç”¨ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ»ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ãƒ˜ãƒ«ãƒ‘ãƒ¼
 */
function setupTestIsolation(describe, beforeEach, afterEach) {
  let testHelper;

  beforeEach(async () => {
    testHelper = createTestIsolation(expect.getState().currentTestName);
    await testHelper.setup();
  });

  afterEach(async () => {
    if (testHelper) {
      await testHelper.cleanup();
      testHelper = null;
    }
  });

  return () => testHelper;
}

/**
 * Three.jsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¤œè¨¼ãƒ˜ãƒ«ãƒ‘ãƒ¼
 */
class ThreeJSTestValidator {
  static async validateScene(browserManager, expectations = {}) {
    const result = await browserManager.page.evaluate(() => {
      if (!window.THREE || !window.testScene) {
        return { error: 'Scene not found' };
      }

      const scene = window.testScene;
      return {
        type: scene.type,
        childrenCount: scene.children.length,
        objects: scene.children.map(child => ({
          type: child.type,
          name: child.name,
          visible: child.visible,
          position: child.position,
          rotation: child.rotation,
          scale: child.scale
        }))
      };
    });

    if (result.error) {
      throw new Error(result.error);
    }

    if (expectations.minObjects && result.childrenCount < expectations.minObjects) {
      throw new Error(`Expected at least ${expectations.minObjects} objects, got ${result.childrenCount}`);
    }

    if (expectations.maxObjects && result.childrenCount > expectations.maxObjects) {
      throw new Error(`Expected at most ${expectations.maxObjects} objects, got ${result.childrenCount}`);
    }

    if (expectations.exactObjects && result.childrenCount !== expectations.exactObjects) {
      throw new Error(`Expected exactly ${expectations.exactObjects} objects, got ${result.childrenCount}`);
    }

    return result;
  }

  static async validateRenderer(browserManager, expectations = {}) {
    const result = await browserManager.page.evaluate(() => {
      if (!window.THREE || !window.testRenderer) {
        return { error: 'Renderer not found' };
      }

      const renderer = window.testRenderer;
      return {
        type: renderer.type,
        domElement: {
          width: renderer.domElement.width,
          height: renderer.domElement.height
        },
        info: renderer.info
      };
    });

    if (result.error) {
      throw new Error(result.error);
    }

    if (expectations.minWidth && result.domElement.width < expectations.minWidth) {
      throw new Error(`Canvas width too small: ${result.domElement.width} < ${expectations.minWidth}`);
    }

    if (expectations.minHeight && result.domElement.height < expectations.minHeight) {
      throw new Error(`Canvas height too small: ${result.domElement.height} < ${expectations.minHeight}`);
    }

    return result;
  }

  static async validateWebGLContext(browserManager) {
    const result = await browserManager.page.evaluate(() => {
      const canvas = document.getElementById('three-canvas') || document.querySelector('canvas');
      if (!canvas) {
        return { error: 'Canvas not found' };
      }

      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if (!gl) {
        return { error: 'WebGL context not available' };
      }

      return {
        vendor: gl.getParameter(gl.VENDOR),
        renderer: gl.getParameter(gl.RENDERER),
        version: gl.getParameter(gl.VERSION),
        extensions: gl.getSupportedExtensions()
      };
    });

    if (result.error) {
      throw new Error(result.error);
    }

    return result;
  }
}

/**
 * ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§æ¤œè¨¼
 */
class TestDataValidator {
  static validateTestDataIntegrity(testData) {
    const errors = [];

    try {
      // åŸºæœ¬æ§‹é€ ã®æ¤œè¨¼
      if (!testData || typeof testData !== 'object') {
        errors.push('Test data must be an object');
        return errors;
      }

      // IDã®ä¸€æ„æ€§æ¤œè¨¼
      const ids = new Set();
      const checkIds = (obj, path = '') => {
        if (obj && typeof obj === 'object') {
          if (obj.id) {
            if (ids.has(obj.id)) {
              errors.push(`Duplicate ID found: ${obj.id} at ${path}`);
            } else {
              ids.add(obj.id);
            }
          }

          Object.keys(obj).forEach(key => {
            if (Array.isArray(obj[key])) {
              obj[key].forEach((item, index) => {
                checkIds(item, `${path}.${key}[${index}]`);
              });
            } else if (typeof obj[key] === 'object') {
              checkIds(obj[key], `${path}.${key}`);
            }
          });
        }
      };

      checkIds(testData);

      // æ•°å€¤ç¯„å›²ã®æ¤œè¨¼
      const validateNumericRanges = (obj) => {
        if (obj && typeof obj === 'object') {
          Object.keys(obj).forEach(key => {
            const value = obj[key];
            
            if (typeof value === 'number') {
              if (key.includes('color') && (value < 0 || value > 0xffffff)) {
                errors.push(`Invalid color value: ${value} at ${key}`);
              }
              if (key.includes('opacity') && (value < 0 || value > 1)) {
                errors.push(`Invalid opacity value: ${value} at ${key}`);
              }
              if (key.includes('intensity') && value < 0) {
                errors.push(`Invalid intensity value: ${value} at ${key}`);
              }
            } else if (typeof value === 'object') {
              validateNumericRanges(value);
            } else if (Array.isArray(value)) {
              value.forEach(item => validateNumericRanges(item));
            }
          });
        }
      };

      validateNumericRanges(testData);

    } catch (error) {
      errors.push(`Validation error: ${error.message}`);
    }

    return errors;
  }

  static async validateTestExecution(testResult) {
    const errors = [];

    if (!testResult) {
      errors.push('Test result is null or undefined');
      return errors;
    }

    if (testResult.success === false && !testResult.error) {
      errors.push('Test failed but no error message provided');
    }

    if (testResult.duration && testResult.duration < 0) {
      errors.push('Invalid test duration: negative value');
    }

    if (testResult.startTime && testResult.endTime && testResult.endTime < testResult.startTime) {
      errors.push('Invalid timing: end time before start time');
    }

    return errors;
  }
}

/**
 * ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
 */
export {
  TestIsolationHelper,
  ResourceTracker,
  PerformanceTracker,
  ThreeJSTestValidator,
  TestDataValidator,
  createTestIsolation,
  setupTestIsolation
};

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
export default TestIsolationHelper;
</file>

<file path="three-test-suite/src/EnvironmentInspector.js">
/**
 * EnvironmentInspector
 * ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒã®æƒ…å ±å–å¾—ï¼ˆWebGL, WebAssemblyï¼‰ã‚’æ‹…å½“ã™ã‚‹ã‚¯ãƒ©ã‚¹
 */
export class EnvironmentInspector {
  /**
   * @param {import('./BrowserManager').BrowserManager} browserManager - BrowserManagerã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
   */
  constructor(browserManager) {
    this.browserManager = browserManager;
  }

  /**
   * WebGLã®æƒ…å ±ã¨å¯¾å¿œçŠ¶æ³ã‚’å–å¾—ã™ã‚‹
   * @returns {Promise<WebGLInfo>} WebGLæƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @throws {Error} BrowserManagerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   * 
   * @typedef {Object} WebGLInfo
   * @property {boolean} webglSupported - WebGLã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} webgl2Supported - WebGL2ã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {string|null} vendor - WebGLãƒ™ãƒ³ãƒ€ãƒ¼æƒ…å ±
   * @property {string|null} renderer - ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼æƒ…å ±
   * @property {string|null} version - WebGLãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±
   */
  async getWebGLInfo() {
    this.browserManager._validateInitialized();

    try {
      const webglInfo = await this.browserManager.page.evaluate(this._getWebGLInfoInBrowser);
      return webglInfo;
    } catch (error) {
      throw new Error(`Failed to get WebGL info: ${error.message}`);
    }
  }

  /**
   * WebAssemblyã®æƒ…å ±ã¨å¯¾å¿œçŠ¶æ³ã‚’å–å¾—ã™ã‚‹
   * @returns {Promise<WebAssemblyInfo>} WebAssemblyæƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @throws {Error} BrowserManagerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   * 
   * @typedef {Object} WebAssemblyInfo
   * @property {boolean} wasmSupported - WebAssemblyåŸºæœ¬ã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} streamingSupported - ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} memorySupported - WebAssembly.Memoryã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} tableSupported - WebAssembly.Tableã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} globalSupported - WebAssembly.Globalã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} sharedMemorySupported - SharedArrayBuffer + WebAssemblyã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   * @property {boolean} simdSupported - WASM SIMDã‚µãƒãƒ¼ãƒˆçŠ¶æ³
   */
  async getWebAssemblyInfo() {
    this.browserManager._validateInitialized();

    try {
      const wasmInfo = await this.browserManager.page.evaluate(this._getWebAssemblyInfoInBrowser);
      return wasmInfo;
    } catch (error) {
      throw new Error(`Failed to get WebAssembly info: ${error.message}`);
    }
  }

  /**
   * WebAssemblyã¨WebGLã®é€£æºæ©Ÿèƒ½æƒ…å ±ã‚’å–å¾—ã™ã‚‹
   * @returns {Promise<HybridCapabilities>} é€£æºæ©Ÿèƒ½æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @throws {Error} BrowserManagerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   * 
   * @typedef {Object} HybridCapabilities
   * @property {boolean} wasmSupported - WebAssemblyå¯¾å¿œçŠ¶æ³
   * @property {boolean} webglSupported - WebGLå¯¾å¿œçŠ¶æ³
   * @property {boolean} hybridReady - é€£æºæ©Ÿèƒ½æº–å‚™å®Œäº†
   * @property {Object} performanceProfile - æ€§èƒ½ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«
   * @property {number} performanceProfile.cpuScore - CPUæ€§èƒ½ã‚¹ã‚³ã‚¢
   * @property {number} performanceProfile.gpuScore - GPUæ€§èƒ½ã‚¹ã‚³ã‚¢
   * @property {number} performanceProfile.memoryBandwidth - ãƒ¡ãƒ¢ãƒªå¸¯åŸŸå¹…
   * @property {string} recommendedStrategy - æ¨å¥¨å‡¦ç†æˆ¦ç•¥
   */
  async getHybridCapabilities() {
    this.browserManager._validateInitialized();

    try {
      const capabilities = await this.browserManager.page.evaluate(this._getHybridCapabilitiesInBrowser);
      return capabilities;
    } catch (error) {
      throw new Error(`Failed to get hybrid capabilities: ${error.message}`);
    }
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§WebGLæƒ…å ±ã‚’å–å¾—ã™ã‚‹é–¢æ•°
   * @private
   * @returns {WebGLInfo} WebGLæƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  _getWebGLInfoInBrowser() {
    // WebGLã‚µãƒãƒ¼ãƒˆç¢ºèª
    const canvas = document.createElement('canvas');
    const webglContext = canvas.getContext('webgl');
    const webgl2Context = canvas.getContext('webgl2');

    const result = {
      webglSupported: webglContext !== null,
      webgl2Supported: webgl2Context !== null,
      vendor: null,
      renderer: null,
      version: null
    };

    // WebGLåŸºæœ¬æƒ…å ±ã‚’å–å¾—
    if (webglContext) {
      result.vendor = webglContext.getParameter(webglContext.VENDOR);
      result.renderer = webglContext.getParameter(webglContext.RENDERER);
      result.version = webglContext.getParameter(webglContext.VERSION);
    }

    return result;
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§WebAssemblyæƒ…å ±ã‚’å–å¾—ã™ã‚‹é–¢æ•°
   * å„ç¨®WebAssemblyæ©Ÿèƒ½ã®å¯¾å¿œçŠ¶æ³ã‚’è©³ç´°ã«ç¢ºèª
   * @private
   * @returns {WebAssemblyInfo} WebAssemblyæƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  _getWebAssemblyInfoInBrowser() {
    const result = {
      wasmSupported: false,
      streamingSupported: false,
      memorySupported: false,
      tableSupported: false,
      globalSupported: false,
      sharedMemorySupported: false,
      simdSupported: false
    };

    // WebAssemblyåŸºæœ¬ã‚µãƒãƒ¼ãƒˆç¢ºèª
    if (typeof WebAssembly !== 'undefined') {
      result.wasmSupported = true;
      
      // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚µãƒãƒ¼ãƒˆç¢ºèª
      result.streamingSupported = typeof WebAssembly.compileStreaming === 'function' &&
                                  typeof WebAssembly.instantiateStreaming === 'function';
      
      // Memory, Table, Globalã‚µãƒãƒ¼ãƒˆç¢ºèª
      result.memorySupported = typeof WebAssembly.Memory === 'function';
      result.tableSupported = typeof WebAssembly.Table === 'function';
      result.globalSupported = typeof WebAssembly.Global === 'function';
      
      // SharedMemoryã‚µãƒãƒ¼ãƒˆç¢ºèª
      // SecurityErrorå¯¾ç­–ã®ãŸã‚try-catchã§å›²ã‚€
      try {
        result.sharedMemorySupported = typeof SharedArrayBuffer !== 'undefined' && 
                                      result.memorySupported;
        
        // ã•ã‚‰ã«è©³ç´°ãªç¢ºèª: å®Ÿéš›ã«SharedMemoryãŒä½œæˆå¯èƒ½ã‹
        if (result.sharedMemorySupported) {
          try {
            const testMemory = new WebAssembly.Memory({ 
              initial: 1, 
              maximum: 1, 
              shared: true 
            });
            // æ­£å¸¸ã«ä½œæˆã§ãã‚Œã°trueã€ãã†ã§ãªã‘ã‚Œã°false
            result.sharedMemorySupported = testMemory.buffer instanceof SharedArrayBuffer;
          } catch (e) {
            result.sharedMemorySupported = false;
          }
        }
      } catch (e) {
        result.sharedMemorySupported = false;
      }
      
      // SIMDå¯¾å¿œç¢ºèªï¼ˆå°†æ¥æ‹¡å¼µç”¨ï¼‰
      // ç¾åœ¨ã¯åŸºæœ¬çš„ãªæ¤œæŸ»ã®ã¿ã€‚å®Ÿéš›ã®SIMDå‘½ä»¤ã‚»ãƒƒãƒˆå¯¾å¿œç¢ºèªã¯è¤‡é›‘
      result.simdSupported = false; // ç¾åœ¨ã¯å¸¸ã«falseï¼ˆå°†æ¥ã®æ‹¡å¼µã«å‚™ãˆã¦ï¼‰
    }

    return result;
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§WebAssemblyã¨WebGLã®é€£æºæ©Ÿèƒ½æƒ…å ±ã‚’å–å¾—ã™ã‚‹é–¢æ•°
   * @private
   * @returns {HybridCapabilities} é€£æºæ©Ÿèƒ½æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  _getHybridCapabilitiesInBrowser() {
    // WebAssemblyå¯¾å¿œç¢ºèª
    const wasmSupported = typeof WebAssembly !== 'undefined';
    
    // WebGLå¯¾å¿œç¢ºèª
    const canvas = document.createElement('canvas');
    const webglContext = canvas.getContext('webgl');
    const webglSupported = webglContext !== null;
    
    // é€£æºæ©Ÿèƒ½æº–å‚™å®Œäº†åˆ¤å®š
    const hybridReady = wasmSupported && webglSupported;
    
    // æ€§èƒ½ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨ˆç®—
    let cpuScore = 0;
    let gpuScore = 0;
    let memoryBandwidth = 0;
    
    if (wasmSupported) {
      // ç°¡æ˜“CPUæ€§èƒ½ã‚¹ã‚³ã‚¢ç®—å‡º
      const startTime = performance.now();
      let sum = 0;
      for (let i = 0; i < 100000; i++) {
        sum += i * 2;
      }
      const endTime = performance.now();
      cpuScore = Math.round(100000 / (endTime - startTime));
    }
    
    if (webglSupported) {
      // ç°¡æ˜“GPUæ€§èƒ½ã‚¹ã‚³ã‚¢ç®—å‡ºï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºãƒ™ãƒ¼ã‚¹ï¼‰
      const maxTextureSize = webglContext.getParameter(webglContext.MAX_TEXTURE_SIZE);
      gpuScore = Math.min(maxTextureSize / 1024, 100); // æœ€å¤§100ç‚¹
      
      // ãƒ¡ãƒ¢ãƒªå¸¯åŸŸå¹…æ¨å®šï¼ˆç°¡æ˜“è¨ˆç®—ï¼‰
      const maxViewportDims = webglContext.getParameter(webglContext.MAX_VIEWPORT_DIMS);
      memoryBandwidth = Math.round((maxViewportDims[0] * maxViewportDims[1]) / 1000000); // MB/sæ¨å®š
    }
    
    // æ¨å¥¨å‡¦ç†æˆ¦ç•¥ã®æ±ºå®š
    let recommendedStrategy = 'cpu-only';
    if (hybridReady) {
      if (cpuScore > 50000 && gpuScore > 50) {
        recommendedStrategy = 'balanced-hybrid';
      } else if (cpuScore > 50000) {
        recommendedStrategy = 'cpu-heavy';
      } else if (gpuScore > 50) {
        recommendedStrategy = 'gpu-heavy';
      } else {
        recommendedStrategy = 'simple-hybrid';
      }
    } else if (webglSupported) {
      recommendedStrategy = 'gpu-only';
    }
    
    return {
      wasmSupported,
      webglSupported,
      hybridReady,
      performanceProfile: {
        cpuScore,
        gpuScore,
        memoryBandwidth
      },
      recommendedStrategy
    };
  }
}
</file>

<file path="three-test-suite/src/PerformanceTester.js">
/**
 * PerformanceTester
 * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œã‚’æ‹…å½“ã™ã‚‹ã‚¯ãƒ©ã‚¹
 */
export class PerformanceTester {
  /**
   * @param {import('./BrowserManager').BrowserManager} browserManager - BrowserManagerã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
   */
  constructor(browserManager) {
    this.browserManager = browserManager;
  }

  /**
   * WebAssemblyã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹
   * CPUé›†ç´„çš„ãªå‡¦ç†æ€§èƒ½ã¨ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹æ€§èƒ½ã‚’æ¸¬å®š
   * @returns {Promise<WebAssemblyPerformance>} ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @throws {Error} BrowserManagerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   * 
   * @typedef {Object} WebAssemblyPerformance
   * @property {number} executionTime - å®Ÿè¡Œæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   * @property {number} operationsPerSecond - ç§’é–“æ¼”ç®—å›æ•°
   * @property {number} memoryPerformance - ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹æ€§èƒ½ï¼ˆæ“ä½œ/ç§’ï¼‰
   */
  async benchmarkWebAssembly() {
    this.browserManager._validateInitialized();

    try {
      const performance = await this.browserManager.page.evaluate(this._benchmarkWebAssemblyInBrowser);
      return performance;
    } catch (error) {
      throw new Error(`Failed to benchmark WebAssembly: ${error.message}`);
    }
  }

  /**
   * WebAssemblyã¨WebGLã®é€£æºãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹
   * @param {Object} options - ãƒ†ã‚¹ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @param {number} options.dataSize - ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 5000)
   * @param {number} options.iterations - åå¾©å›æ•° (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 20)
   * @returns {Promise<HybridPerformance>} ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @throws {Error} BrowserManagerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   * 
   * @typedef {Object} HybridPerformance
   * @property {number} wasmComputeTime - WASMè¨ˆç®—æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   * @property {number} webglRenderTime - WebGLæç”»æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   * @property {number} dataTransferTime - ãƒ‡ãƒ¼ã‚¿è»¢é€æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   * @property {number} totalTime - ç·å®Ÿè¡Œæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   * @property {number} efficiency - å‡¦ç†åŠ¹ç‡ï¼ˆ0-1ï¼‰
   * @property {number} throughput - ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆï¼ˆãƒ‡ãƒ¼ã‚¿/ç§’ï¼‰
   */
  async benchmarkHybridPerformance(options = {}) {
    this.browserManager._validateInitialized();

    try {
      const performance = await this.browserManager.page.evaluate(this._benchmarkHybridPerformanceInBrowser, options);
      return performance;
    } catch (error) {
      throw new Error(`Failed to benchmark hybrid performance: ${error.message}`);
    }
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§WebAssemblyãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°
   * æ•°å€¤è¨ˆç®—ã¨ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹ã®ä¸¡æ–¹ã®æ€§èƒ½ã‚’æ¸¬å®š
   * @private
   * @returns {Promise<WebAssemblyPerformance>} ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  _benchmarkWebAssemblyInBrowser() {
    if (typeof WebAssembly === 'undefined') {
      throw new Error('WebAssembly is not supported');
    }

    // ç°¡å˜ãªWASMãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆaddTwoé–¢æ•°: 2ã¤ã®æ•°å€¤ã‚’åŠ ç®—ï¼‰
    // WAT (WebAssembly Text format): 
    // (module
    //   (func $addTwo (param $p1 i32) (param $p2 i32) (result i32)
    //     local.get $p1
    //     local.get $p2
    //     i32.add)
    //   (export "addTwo" (func $addTwo)))
    const wasmBytes = new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01,
      0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x0a, 0x01, 0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6f, 0x00,
      0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b
    ]);

    return WebAssembly.instantiate(wasmBytes)
      .then(result => {
        const addTwo = result.instance.exports.addTwo;
        
        // CPUé›†ç´„çš„å‡¦ç†ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
        const startTime = performance.now();
        const iterations = 100000;
        
        for (let i = 0; i < iterations; i++) {
          addTwo(i, i + 1);
        }
        
        const endTime = performance.now();
        const executionTime = endTime - startTime;
        const operationsPerSecond = Math.round((iterations / executionTime) * 1000);
        
        // ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹æ€§èƒ½ãƒ†ã‚¹ãƒˆ
        const memoryStartTime = performance.now();
        let memoryPerformance = 0;
        
        try {
          const memory = new WebAssembly.Memory({ initial: 1 });
          const buffer = new Uint32Array(memory.buffer);
          const memoryOperations = 1000;
          
          for (let i = 0; i < memoryOperations; i++) {
            buffer[i] = i;
          }
          
          const memoryEndTime = performance.now();
          const memoryTime = memoryEndTime - memoryStartTime;
          memoryPerformance = Math.round((memoryOperations / memoryTime) * 1000);
        } catch (e) {
          // ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ãŸå ´åˆã¯0ã‚’è¿”ã™
          memoryPerformance = 0;
        }
        
        return {
          executionTime: Math.round(executionTime * 100) / 100, // å°æ•°ç‚¹ä»¥ä¸‹2æ¡ã«ä¸¸ã‚ã‚‹
          operationsPerSecond: operationsPerSecond,
          memoryPerformance: memoryPerformance
        };
      })
      .catch(error => {
        throw new Error(`WebAssembly benchmark failed: ${error.message}`);
      });
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§WebAssemblyã¨WebGLã®é€£æºãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°
   * @private
   * @param {Object} options - ãƒ†ã‚¹ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @returns {Promise<HybridPerformance>} ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  _benchmarkHybridPerformanceInBrowser(options) {
    const config = {
      dataSize: 5000,    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’1000ã‹ã‚‰5000ã«å¢—åŠ 
      iterations: 20,    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’10ã‹ã‚‰20ã«å¢—åŠ 
      ...options
    };

    if (typeof WebAssembly === 'undefined') {
      throw new Error('WebAssembly is not supported');
    }

    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl');
    if (!gl) {
      throw new Error('WebGL is not supported');
    }

    // WASMãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆãƒ‡ãƒ¼ã‚¿å‡¦ç†ç”¨ï¼‰
    const wasmBytes = new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01,
      0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x0a, 0x01, 0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6f, 0x00,
      0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b
    ]);

    return WebAssembly.instantiate(wasmBytes)
      .then(result => {
        const addTwo = result.instance.exports.addTwo;
        
        const totalStartTime = performance.now();
        
        let totalWasmTime = 0;
        let totalWebglTime = 0;
        let totalDataTransferTime = 0;
        
        for (let iter = 0; iter < config.iterations; iter++) {
          // WASMè¨ˆç®—ãƒ•ã‚§ãƒ¼ã‚º
          const wasmStartTime = performance.now();
          const vertices = [];
          for (let i = 0; i < config.dataSize; i++) {
            vertices.push(addTwo(i % 100, (i + 1) % 100));
          }
          const wasmEndTime = performance.now();
          totalWasmTime += (wasmEndTime - wasmStartTime);
          
          // ãƒ‡ãƒ¼ã‚¿è»¢é€ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆã‚ˆã‚Šå¤§ããªãƒ‡ãƒ¼ã‚¿ã§æ¸¬å®šç²¾åº¦å‘ä¸Šï¼‰
          const transferStartTime = performance.now();
          
          // ã‚ˆã‚Šè¤‡é›‘ãªãƒ‡ãƒ¼ã‚¿è»¢é€å‡¦ç†ã‚’è¿½åŠ 
          const largeVertexData = new Float32Array(vertices.length * 3); // x, y, z coordinates
          for (let i = 0; i < vertices.length; i++) {
            largeVertexData[i * 3] = vertices[i];
            largeVertexData[i * 3 + 1] = vertices[i] + 1;
            largeVertexData[i * 3 + 2] = vertices[i] + 2;
          }
          
          // è¿½åŠ ã®é…åˆ—å¤‰æ›å‡¦ç†ã§ãƒ‡ãƒ¼ã‚¿è»¢é€æ™‚é–“ã‚’ç¢ºå®Ÿã«æ¸¬å®š
          const normalData = new Float32Array(largeVertexData.length);
          for (let i = 0; i < largeVertexData.length; i++) {
            normalData[i] = largeVertexData[i] / Math.max(1, Math.abs(largeVertexData[i]));
          }
          
          const transferEndTime = performance.now();
          const transferTime = transferEndTime - transferStartTime;
          totalDataTransferTime += Math.max(transferTime, 0.01); // æœ€å°0.01msä¿è¨¼
          
          // WebGLæç”»ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆå‡¦ç†ã‚’é‡ãã—ã¦æ¸¬å®šå¯èƒ½ã«ã™ã‚‹ï¼‰
          const webglStartTime = performance.now();
          
          // è¤‡æ•°ã®ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã—ã¦å‡¦ç†ã‚’é‡ãã™ã‚‹
          const buffers = [];
          for (let bufIdx = 0; bufIdx < 5; bufIdx++) {
            const buffer = gl.createBuffer();
            buffers.push(buffer);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, largeVertexData, gl.STATIC_DRAW);
            
            // è¿½åŠ ã® WebGL æ“ä½œ
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.viewport(0, 0, 100, 100);
          }
          
          const webglEndTime = performance.now();
          const webglTime = webglEndTime - webglStartTime;
          totalWebglTime += Math.max(webglTime, 0.01); // æœ€å°0.01msä¿è¨¼
          
          // ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          buffers.forEach(buffer => gl.deleteBuffer(buffer));
        }
        
        const totalEndTime = performance.now();
        const totalTime = totalEndTime - totalStartTime;
        
        // å¹³å‡æ™‚é–“è¨ˆç®—
        const wasmComputeTime = Math.round((totalWasmTime / config.iterations) * 100) / 100;
        const webglRenderTime = Math.round((totalWebglTime / config.iterations) * 100) / 100;
        const dataTransferTime = Math.round((totalDataTransferTime / config.iterations) * 100) / 100;
        
        // åŠ¹ç‡è¨ˆç®—ï¼ˆç†æƒ³çš„ãªä¸¦åˆ—å‡¦ç†ã«å¯¾ã™ã‚‹å®Ÿéš›ã®æ€§èƒ½æ¯”ï¼‰
        const idealTime = Math.max(wasmComputeTime, webglRenderTime);
        const actualTime = wasmComputeTime + dataTransferTime + webglRenderTime;
        const efficiency = Math.min(idealTime / actualTime, 1.0);
        
        // ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆè¨ˆç®—ï¼ˆãƒ‡ãƒ¼ã‚¿/ç§’ï¼‰
        const throughput = Math.round((config.dataSize * config.iterations * 1000) / totalTime);
        
        return {
          wasmComputeTime,
          webglRenderTime,
          dataTransferTime,
          totalTime: Math.round(totalTime * 100) / 100,
          efficiency: Math.round(efficiency * 1000) / 1000,
          throughput
        };
      })
      .catch(error => {
        throw new Error(`Hybrid performance benchmark failed: ${error.message}`);
      });
  }
}
</file>

<file path="three-test-suite/README.md">
# Three.js ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯

**Three.jsã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãŸã‚ã®åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³**

[![Tests](https://github.com/usaganikki/Web3DExplorer/actions/workflows/test.yml/badge.svg)](https://github.com/usaganikki/Web3DExplorer/actions/workflows/test.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## ğŸ¯ æ¦‚è¦

ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯ã€Three.jsã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆã‚’åŠ‡çš„ã«ç°¡å˜ã«ã—ã¾ã™ã€‚Node.jsç’°å¢ƒã§ã®DOMä¸è¶³ã‚„WebGLéå¯¾å¿œã¨ã„ã£ãŸæŠ€è¡“çš„åˆ¶ç´„ã‚’è§£æ±ºã—ã€é–‹ç™ºè€…ãŒThree.jsã®ãƒ†ã‚¹ãƒˆãƒ­ã‚¸ãƒƒã‚¯ã«é›†ä¸­ã§ãã‚‹ç’°å¢ƒã‚’æä¾›ã—ã¾ã™ã€‚

### ğŸš¨ è§£æ±ºã™ã‚‹å•é¡Œ

```javascript
// âŒ Node.jsç’°å¢ƒã§ã¯ä¸å¯èƒ½
import * as THREE from 'three';
test('Three.js test', () => {
  const scene = new THREE.Scene();  // ReferenceError: DOMç’°å¢ƒãªã—
});

// âœ… ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§å¯èƒ½
test('Three.js test', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();  // æ­£å¸¸å‹•ä½œï¼
  });
});
```

## ğŸš€ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ

### ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
cd three-test-suite
npm install
```

### åŸºæœ¬çš„ãªä½¿ç”¨æ³•

```javascript
import { PuppeteerManager } from './src/PuppeteerManager.js';

test('æœ€åˆã®Three.jsãƒ†ã‚¹ãƒˆ', async () => {
  const manager = new PuppeteerManager();
  await manager.initialize();
  
  const html = manager.generateTestHTML(() => {
    // ğŸ¯ Three.jsã‚³ãƒ¼ãƒ‰ã‚’ã“ã“ã«æ›¸ã
    const scene = new THREE.Scene();
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    scene.add(cube);
    
    // ãƒ†ã‚¹ãƒˆç”¨ã®å€¤ã‚’è¨­å®š
    window.cubeCreated = true;
  });
  
  await manager.page.setContent(html);
  
  const result = await manager.page.evaluate(() => window.cubeCreated);
  expect(result).toBe(true);
  
  await manager.cleanup();
});
```

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ã‚³ã‚¢æ©Ÿèƒ½

```
PuppeteerManager
â”œâ”€â”€ initialize()           # ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒã®åˆæœŸåŒ–
â”œâ”€â”€ generateTestHTML()     # HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ
â”œâ”€â”€ getWebGLInfo()        # WebGLç’°å¢ƒæƒ…å ±å–å¾—
â””â”€â”€ cleanup()             # ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
```

### ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆã®ä»•çµ„ã¿

```javascript
// å†…éƒ¨çš„ãªå‡¦ç†ãƒ•ãƒ­ãƒ¼
generateTestHTML(userScript, options) {
  // 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’æ–‡å­—åˆ—åŒ–
  const scriptString = userScript.toString();
  
  // 2. HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«åŸ‹ã‚è¾¼ã¿
  return `
    <!DOCTYPE html>
    <html>
      <head>
        <script src="Three.js CDN"></script>
      </head>
      <body>
        <canvas id="three-canvas"></canvas>
        <script>
          window.addEventListener('load', () => {
            (${scriptString})();  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
          });
        </script>
      </body>
    </html>
  `;
}
```

## ğŸ“Š å¾“æ¥æ‰‹æ³•ã¨ã®æ¯”è¼ƒ

| ç‰¹å¾´ | å¾“æ¥ã®Puppeteer | ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ | æ”¹å–„åº¦ |
|------|----------------|------------------|--------|
| **ã‚³ãƒ¼ãƒ‰é‡** | 45è¡Œ+ | 23è¡Œ | 48%å‰Šæ¸› |
| **è¤‡é›‘åº¦** | é«˜ã„ | ä½ã„ | å¤§å¹…æ”¹å–„ |
| **IDEæ”¯æ´** | âŒ æ–‡å­—åˆ—å†…JS | âœ… ãƒ•ãƒ«æ©Ÿèƒ½ | å®Œå…¨å¯¾å¿œ |
| **å†åˆ©ç”¨æ€§** | ä½ã„ | é«˜ã„ | å¤§å¹…å‘ä¸Š |
| **å­¦ç¿’ã‚³ã‚¹ãƒˆ** | é«˜ã„ | ä½ã„ | å¤§å¹…è»½æ¸› |

### Before: å¾“æ¥ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
```javascript
test('Three.js test', async () => {
  // ğŸ˜° æ¯å›45è¡Œã®HTMLãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆ
  await page.setContent(`
    <!DOCTYPE html>
    <html>
      <head>
        <script src="https://three.js..."></script>
        <style>/* CSS */</style>
      </head>
      <body>
        <canvas></canvas>
        <script>
          // ğŸ˜¢ æ–‡å­—åˆ—å†…ã®JavaScriptï¼ˆIDEæ”¯æ´ãªã—ï¼‰
          const scene = new THREE.Scene();
          // ... è¤‡é›‘ãªæ–‡å­—åˆ—ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        </script>
      </body>
    </html>
  `);
});
```

### After: ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
```javascript
test('Three.js test', async () => {
  // ğŸ˜ 23è¡Œã«çŸ­ç¸®ã€IDEæ”¯æ´ãƒ•ãƒ«æ´»ç”¨
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();  // è‡ªå‹•è£œå®Œã€ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    // ... æ™®é€šã®JavaScriptã¨ã—ã¦è¨˜è¿°
  });
  
  await manager.page.setContent(html);
});
```

## ğŸ¨ é«˜åº¦ãªæ©Ÿèƒ½

### è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³

```javascript
const html = manager.generateTestHTML(userScript, {
  title: 'ã‚«ã‚¹ã‚¿ãƒ ãƒ†ã‚¹ãƒˆãƒšãƒ¼ã‚¸',
  threeJsVersion: 'r140',      // Three.jsãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®š
  autoExecute: false           // æ‰‹å‹•å®Ÿè¡Œåˆ¶å¾¡
});
```

### WebGLç’°å¢ƒæƒ…å ±ã®å–å¾—

```javascript
const webglInfo = await manager.getWebGLInfo();
console.log(webglInfo);
// {
//   webglSupported: true,
//   webgl2Supported: true,
//   vendor: "Google Inc.",
//   renderer: "Chrome",
//   version: "WebGL 1.0"
// }
```

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```javascript
// ç„¡åŠ¹ãªå¼•æ•°ã®æ¤œå‡º
expect(() => {
  manager.generateTestHTML('not a function');
}).toThrow('userScript must be a function');

// åˆæœŸåŒ–ãƒã‚§ãƒƒã‚¯
await expect(
  manager.getWebGLInfo()  // åˆæœŸåŒ–å‰
).rejects.toThrow('PuppeteerManager is not initialized');
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆä¾‹

### åŸºæœ¬çš„ãªã‚·ãƒ¼ãƒ³ä½œæˆ

```javascript
test('åŸºæœ¬ã‚·ãƒ¼ãƒ³ä½œæˆ', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas') });
    
    window.sceneInfo = {
      childrenCount: scene.children.length,
      cameraFov: camera.fov,
      rendererType: renderer.type
    };
  });
  
  await manager.page.setContent(html);
  
  const info = await manager.page.evaluate(() => window.sceneInfo);
  expect(info.childrenCount).toBe(0);
  expect(info.cameraFov).toBe(75);
  expect(info.rendererType).toBe('WebGLRenderer');
});
```

### ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ

```javascript
test('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³', async () => {
  const html = manager.generateTestHTML(() => {
    const scene = new THREE.Scene();
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    scene.add(cube);
    
    let frameCount = 0;
    function animate() {
      frameCount++;
      cube.rotation.x += 0.01;
      
      if (frameCount >= 10) {
        window.animationResult = {
          frames: frameCount,
          rotation: cube.rotation.x
        };
        return;
      }
      
      requestAnimationFrame(animate);
    }
    
    animate();
  });
  
  await manager.page.setContent(html);
  await manager.page.waitForFunction('window.animationResult');
  
  const result = await manager.page.evaluate(() => window.animationResult);
  expect(result.frames).toBe(10);
  expect(result.rotation).toBeCloseTo(0.1, 2);
});
```

### ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ†ãƒªã‚¢ãƒ«

```javascript
test('ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«', async () => {
  const html = manager.generateTestHTML(() => {
    const material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 1.0 },
        color: { value: new THREE.Color(0xff0000) }
      },
      vertexShader: `
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 color;
        void main() {
          gl_FragColor = vec4(color * sin(time), 1.0);
        }
      `
    });
    
    window.shaderInfo = {
      type: material.type,
      uniformCount: Object.keys(material.uniforms).length,
      hasVertexShader: !!material.vertexShader,
      hasFragmentShader: !!material.fragmentShader
    };
  });
  
  await manager.page.setContent(html);
  
  const info = await manager.page.evaluate(() => window.shaderInfo);
  expect(info.type).toBe('ShaderMaterial');
  expect(info.uniformCount).toBe(2);
  expect(info.hasVertexShader).toBe(true);
  expect(info.hasFragmentShader).toBe(true);
});
```

## ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

```
three-test-suite/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ PuppeteerManager.js    # ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
â”œâ”€â”€ __tests__/
â”‚   â””â”€â”€ PuppeteerManager.test.js # ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ design-philosophy.md   # è¨­è¨ˆæ€æƒ³ãƒ»ãƒ¡ãƒªãƒƒãƒˆ
â”‚   â”œâ”€â”€ quick-start.md        # ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆã‚¬ã‚¤ãƒ‰
â”‚   â””â”€â”€ README.md             # ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«
â”œâ”€â”€ package.json
â””â”€â”€ package-lock.json
```

## ğŸ”§ é–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆ

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```bash
# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm test

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«
npm test -- PuppeteerManager.test.js

# ã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰
npm run test:watch

# ã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ã
npm run test:coverage
```

### é–‹ç™ºæ™‚ã®ãƒ’ãƒ³ãƒˆ

```javascript
// ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶è¡¨ç¤ºï¼‰
const manager = new PuppeteerManager({ headless: false });

// ã‚«ã‚¹ã‚¿ãƒ è¨­å®š
const manager = new PuppeteerManager({
  width: 1920,
  height: 1080,
  args: ['--enable-webgl2']  // WebGL2å¼·åˆ¶æœ‰åŠ¹åŒ–
});
```

## ğŸ¯ è¨­è¨ˆæ€æƒ³

### å•é¡Œè§£æ±ºã®æµã‚Œ

```
1. Node.jsç’°å¢ƒåˆ¶ç´„
   âŒ DOMãƒ»Canvasãƒ»WebGLä¸è¶³
   â†“
2. Puppeteerã§è§£æ±º
   âœ… ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒæä¾›
   âŒ HTMLä½œæˆã®ç…©é›‘ã•
   â†“
3. ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆã§è§£æ±º
   âœ… HTMLè‡ªå‹•ç”Ÿæˆ
   âœ… é–‹ç™ºè€…ä½“é¨“å‘ä¸Š
```

### æ ¸å¿ƒçš„ä¾¡å€¤

- **æŠ½è±¡åŒ–**: æŠ€è¡“çš„åˆ¶ç´„ã‚’éš è”½
- **é›†ä¸­**: Three.jsãƒ­ã‚¸ãƒƒã‚¯ã«ç‰¹åŒ–
- **ç”Ÿç”£æ€§**: é–‹ç™ºé€Ÿåº¦3-6å€å‘ä¸Š
- **å“è³ª**: IDEæ”¯æ´ã§ã‚¨ãƒ©ãƒ¼å‰Šæ¸›

è©³ç´°ã¯ [`docs/design-philosophy.md`](./docs/design-philosophy.md) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## ğŸš€ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹

### ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯çµæœ

```
ãƒ†ã‚¹ãƒˆä½œæˆæ™‚é–“ã®æ¯”è¼ƒ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ‰‹æ³•            â”‚ å¾“æ¥æ‰‹æ³• â”‚ ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯  â”‚ æ”¹å–„ç‡  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ åˆå›ãƒ†ã‚¹ãƒˆä½œæˆ  â”‚ 15-30åˆ†  â”‚ 2-5åˆ†          â”‚ 83%çŸ­ç¸® â”‚
â”‚ è¿½åŠ ãƒ†ã‚¹ãƒˆä½œæˆ  â”‚ 10-15åˆ†  â”‚ 1-3åˆ†          â”‚ 80%çŸ­ç¸® â”‚
â”‚ ãƒ†ã‚¹ãƒˆä¿®æ­£      â”‚ 5-10åˆ†   â”‚ 1-2åˆ†          â”‚ 75%çŸ­ç¸® â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ã‚³ãƒ¼ãƒ‰é‡ã®æ¯”è¼ƒ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ—    â”‚ å¾“æ¥æ‰‹æ³• â”‚ ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯  â”‚ å‰Šæ¸›ç‡  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ åŸºæœ¬ã‚·ãƒ¼ãƒ³      â”‚ 45è¡Œ     â”‚ 23è¡Œ           â”‚ 48%å‰Šæ¸› â”‚
â”‚ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³  â”‚ 60è¡Œ     â”‚ 30è¡Œ           â”‚ 50%å‰Šæ¸› â”‚
â”‚ ã‚«ã‚¹ã‚¿ãƒ æ©Ÿèƒ½    â”‚ 80è¡Œ     â”‚ 35è¡Œ           â”‚ 56%å‰Šæ¸› â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”® ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

### Phase 1: åŸºç›¤æ©Ÿèƒ½ âœ…
- [x] PuppeteerManageråŸºç›¤
- [x] WebGLæœ‰åŠ¹åŒ–
- [x] HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ

### Phase 2: æ‹¡å¼µæ©Ÿèƒ½ ğŸš§
- [ ] Three.jsã‚·ãƒ¼ãƒ³æ³¨å…¥
- [ ] ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ”¯æ´
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š

### Phase 3: é«˜åº¦æ©Ÿèƒ½ ğŸ“‹
- [ ] VR/ARç’°å¢ƒã‚µãƒãƒ¼ãƒˆ
- [ ] WebXR API ãƒ†ã‚¹ãƒˆ
- [ ] 3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æ”¯æ´
- [ ] GPUè¨ˆç®—ãƒ†ã‚¹ãƒˆ

### Phase 4: ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ  ğŸ’­
- [ ] ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ 
- [ ] TypeScriptå¯¾å¿œ
- [ ] CI/CDçµ±åˆ
- [ ] ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«å›å¸°ãƒ†ã‚¹ãƒˆ

## ğŸ¤ ã‚³ãƒ³ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³

### é–‹ç™ºã«å‚åŠ ã™ã‚‹

```bash
# ãƒªãƒã‚¸ãƒˆãƒªã‚¯ãƒ­ãƒ¼ãƒ³
git clone https://github.com/usaganikki/Web3DExplorer.git
cd Web3DExplorer/three-test-suite

# ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install

# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm test

# é–‹ç™ºãƒ–ãƒ©ãƒ³ãƒä½œæˆ
git checkout -b feature/your-feature
```

### Issueå ±å‘Š

ä»¥ä¸‹ã®æƒ…å ±ã‚’å«ã‚ã¦Issueã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼š

- ç’°å¢ƒæƒ…å ±ï¼ˆNode.jsã€OSã€ãƒ–ãƒ©ã‚¦ã‚¶ï¼‰
- å†ç¾æ‰‹é †
- æœŸå¾…ã™ã‚‹å‹•ä½œ
- å®Ÿéš›ã®å‹•ä½œ
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

## ğŸ“„ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹

MIT License - è©³ç´°ã¯ [LICENSE](../LICENSE) ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## ğŸ™ è¬è¾

- [Three.js](https://threejs.org/) - ç´ æ™´ã‚‰ã—ã„3Dãƒ©ã‚¤ãƒ–ãƒ©ãƒª
- [Puppeteer](https://pptr.dev/) - ãƒ–ãƒ©ã‚¦ã‚¶è‡ªå‹•åŒ–ãƒ„ãƒ¼ãƒ«
- [Jest](https://jestjs.io/) - ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯

## ğŸ“ ã‚µãƒãƒ¼ãƒˆ

- ğŸ“§ Email: [GitHubãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«](https://github.com/usaganikki)
- ğŸ› Issues: [GitHub Issues](https://github.com/usaganikki/Web3DExplorer/issues)
- ğŸ“– Documentation: [`docs/`](./docs/) ãƒ•ã‚©ãƒ«ãƒ€

---

**Three.jsãƒ†ã‚¹ãƒˆã®æ–°ã—ã„æ¨™æº–ã‚’ä¸€ç·’ã«ä½œã‚Šã¾ã—ã‚‡ã†ï¼** ğŸš€
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# nyc test coverage
.nyc_output

# Dependency directories
jspm_packages/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.local
.env.development.local
.env.test.local
.env.production.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Build outputs
dist/
build/
lib/
out/

# Logs
logs
*.log

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Test artifacts
__tests__/screenshots/
__tests__/videos/
test-results/

# Temporary files
*.tmp
*.temp

# Package manager lock files (keep package-lock.json but ignore others)
yarn.lock
pnpm-lock.yaml

# Local environment files
.env.local
.env.development.local
.env.test.local
.env.production.local

# Storybook build outputs
storybook-static

# Rush temporary files
common/deploy/
common/temp/
common/autoinstallers/*/.npmrc
**/.rush/temp/

# MacOS
.AppleDouble
.LSOverride

# Windows
Desktop.ini
$RECYCLE.BIN/
*.cab
*.msi
*.msm
*.msp
*.lnk
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- TypeScript migration with comprehensive type definitions
- React Three Fiber integration
- GIS coordinate transformation system
- Tokyo Station area 3D visualization
- Performance monitoring and metrics
- Comprehensive testing framework with Three.js utilities
- Event-driven architecture
- Modern build system with Vite

## [0.1.0] - 2025-06-01

### Added
- âœ¨ **TypeScript First Implementation**
  - Complete type safety with comprehensive type definitions
  - Strict TypeScript configuration with modern ES modules
  - Full IntelliSense support for Three.js objects

- âœ¨ **Core 3D Engine**
  - `Explorer` class for managing 3D scenes, cameras, and renderers
  - Object lifecycle management with configuration support
  - Performance metrics tracking and optimization
  - Event system for interaction handling

- âœ¨ **React Integration**
  - `Web3DExplorerComponent` for seamless React integration
  - React Three Fiber compatibility
  - TypeScript-safe React hooks and components
  - Performance monitoring with React state integration

- âœ¨ **GIS Integration**
  - `GISManager` for geographic data handling
  - Tokyo projection system for accurate coordinate transformation
  - Support for terrain, buildings, roads, and POI data
  - Automatic 3D object generation from GIS data

- âœ¨ **Tokyo Station Explorer**
  - Specialized component for Tokyo Station area visualization
  - Real-world geographic data integration
  - Interactive 3D building and infrastructure models
  - Loading progress and error handling

- âœ¨ **Testing Framework**
  - `ThreeTestUtils` for testing Three.js applications
  - Custom Jest matchers for 3D objects, materials, and geometries
  - Mock scene and object generators
  - Visual regression testing support
  - Performance testing utilities

- âœ¨ **Modern Development Environment**
  - Vite build system with TypeScript support
  - ESLint configuration for TypeScript and React
  - Jest testing setup with TypeScript integration
  - Prettier code formatting
  - GitHub Actions ready configuration

- âœ¨ **Documentation and Examples**
  - Comprehensive README with usage examples
  - TypeScript API documentation
  - React integration examples
  - Vanilla JavaScript examples
  - GIS data loading examples

### Technical Details

#### Type System
- **Core Types**: `Web3DExplorer`, `PerformanceMetrics`, `Object3DConfig`
- **GIS Types**: `GeoCoordinates`, `BuildingData`, `TerrainData`, `ProjectionSystem`
- **Testing Types**: `TestScenario`, `VisualTest`, `PerformanceTest`, `ThreeTestUtils`
- **React Types**: Full component prop typing with event handlers

#### Architecture
- **Event-Driven**: Built-in event system for object interactions and performance monitoring
- **Modular Design**: Separate core engine, GIS functionality, and React components
- **Plugin System**: Extensible architecture for custom functionality
- **Performance-First**: Built-in optimization and monitoring tools

#### Browser Support
- **Modern Browsers**: Chrome 90+, Firefox 88+, Safari 14+, Edge 90+
- **WebGL**: Requires WebGL 1.0 support (WebGL 2.0 recommended)
- **ES Modules**: Native ES module support required
- **TypeScript**: Full TypeScript 5.0+ compatibility

#### Dependencies
- **Three.js**: 0.163.0+ (peer dependency)
- **React**: 18.2.0+ (optional, for React components)
- **React Three Fiber**: 8.16.0+ (optional, for advanced React integration)

### Migration Notes

This release represents a complete TypeScript migration from the previous JavaScript codebase:

1. **Type Safety**: All APIs now have comprehensive type definitions
2. **Better IntelliSense**: IDEs provide complete autocompletion for Three.js objects
3. **Runtime Error Prevention**: TypeScript catches many errors at compile time
4. **Improved Documentation**: Types serve as inline documentation
5. **Better Refactoring**: Safe refactoring with TypeScript's type checking

### Breaking Changes

- **Minimum Node.js Version**: Requires Node.js 16.0+
- **Build System**: Now uses Vite instead of Webpack
- **Module System**: Fully converted to ES modules
- **API Changes**: Some method signatures updated for better type safety
- **Testing**: New testing utilities replace previous testing approach

### Performance Improvements

- **Bundle Size**: Optimized build with tree-shaking support
- **Runtime Performance**: Better memory management and object disposal
- **Development Experience**: Faster development builds with Vite
- **Type Checking**: Incremental TypeScript compilation

### Known Issues

- **WebGL Context Loss**: Automatic recovery not yet implemented
- **Memory Leaks**: Some edge cases in object disposal need attention
- **Mobile Performance**: Touch controls need optimization for mobile devices
- **Safari Compatibility**: Some WebGL extensions may not be available

### Future Roadmap

- **WebXR Support**: VR/AR integration planned for v0.2.0
- **WebGL 2.0**: Enhanced renderer features for supported browsers
- **Advanced GIS**: Integration with popular GIS data sources
- **Performance**: Further optimization for large-scale scenes
- **Accessibility**: Improved accessibility features for 3D content

---

## Development

### Version 0.1.0 Development Timeline

- **2025-06-01**: Initial TypeScript migration planning
- **2025-06-01**: Core type definitions implemented
- **2025-06-01**: Explorer class TypeScript conversion
- **2025-06-01**: React components with TypeScript
- **2025-06-01**: GIS integration and Tokyo projection
- **2025-06-01**: Testing framework implementation
- **2025-06-01**: Documentation and examples
- **2025-06-01**: v0.1.0 release

### Contributors

- **usaganikki** - Initial TypeScript migration and core development

### Acknowledgments

- **Three.js Community** - For the excellent 3D library
- **React Three Fiber Team** - For React integration inspiration
- **TypeScript Team** - For the powerful type system
- **Vite Team** - For the fast build tool
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 usaganikki

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWE.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["DOM", "DOM.Iterable", "ES6", "ES2022"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@/types/*": ["./src/types/*"],
      "@/components/*": ["./src/components/*"],
      "@/utils/*": ["./src/utils/*"],
      "@/three/*": ["./src/three/*"]
    }
  },
  "include": [
    "src/**/*",
    "three-test-suite/src/**/*",
    "__tests__/**/*",
    "*.ts",
    "*.tsx"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "build"
  ]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';
import path from 'path';
import typescript from '@rollup/plugin-typescript'; // Rollupã®TypeScriptãƒ—ãƒ©ã‚°ã‚¤ãƒ³

export default defineConfig({
  build: {
    lib: {
      entry: path.resolve(__dirname, 'src/index.ts'),
      name: 'Web3DExplorer',
      fileName: (format) => `web3d-explorer.${format}.js`,
      formats: ['es', 'umd', 'cjs'], // CommonJSãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚‚è¿½åŠ 
    },
    rollupOptions: {
      external: ['three', 'react', 'react-dom', '@react-three/fiber'],
      output: {
        globals: {
          three: 'THREE',
          react: 'React',
          'react-dom': 'ReactDOM',
          '@react-three/fiber': 'ReactThreeFiber',
        },
        // ESãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ 'exports: "named"' ã‚’æŒ‡å®šã™ã‚‹ã¨è­¦å‘Šã‚’å›é¿ã§ãã‚‹å ´åˆãŒã‚ã‚‹
        exports: 'named',
      },
      plugins: [
        typescript({ // tsconfig.json ã‚’ä½¿ç”¨ã—ã¦ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«
          tsconfig: './tsconfig.json',
          declaration: true, // å‹å®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ (tscå´ã§ã‚‚ç”Ÿæˆã—ã¦ã„ã‚‹ãŒå¿µã®ãŸã‚)
          declarationDir: 'dist/types', // å‹å®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«ã®å‡ºåŠ›å…ˆ (tscã®outDirã¨åˆã‚ã›ã‚‹ã‹æ¤œè¨)
          rootDir: 'src', // ã‚½ãƒ¼ã‚¹ã®ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        }),
      ],
    },
    sourcemap: true,
    // emptyOutDir: false, // tsc ãŒ dist ã‚’ä½¿ã†ã®ã§ã€Vite ãŒã‚¯ãƒªã‚¢ã—ãªã„ã‚ˆã†ã«ã™ã‚‹ (å¿…è¦ã«å¿œã˜ã¦)
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
    },
  },
});
</file>

<file path="__tests__/GISManager.test.ts">
import { GISManager } from '../src/gis/GISManager';
import { TOKYO_PROJECTION, BuildingData, RoadData, POIData, TerrainData } from '../src/types/gis';
import * as THREE from 'three';

describe('GISManager', () => {
  let gisManager: GISManager;

  beforeEach(() => {
    gisManager = new GISManager();
  });

  describe('coordinate transformation', () => {
    it('should transform geographic coordinates to world coordinates', () => {
      const geoCoords = { latitude: 35.6812, longitude: 139.7671, altitude: 10 };
      const worldCoords = gisManager.geoToWorld(geoCoords);
      
      expect(typeof worldCoords.x).toBe('number');
      expect(typeof worldCoords.y).toBe('number');
      expect(typeof worldCoords.z).toBe('number');
      expect(worldCoords.y).toBe(10); // altitude should be preserved
    });

    it('should transform world coordinates back to geographic coordinates', () => {
      const originalGeo = { latitude: 35.6812, longitude: 139.7671, altitude: 10 };
      const worldCoords = gisManager.geoToWorld(originalGeo);
      const backToGeo = gisManager.worldToGeo(worldCoords);
      
      expect(backToGeo.latitude).toBeCloseTo(originalGeo.latitude, 5);
      expect(backToGeo.longitude).toBeCloseTo(originalGeo.longitude, 5);
      expect(backToGeo.altitude).toBeCloseTo(originalGeo.altitude!, 5);
    });

    it('should handle Tokyo Station coordinates correctly', () => {
      const tokyoStation = { latitude: 35.6812, longitude: 139.7671, altitude: 0 };
      const worldCoords = gisManager.geoToWorld(tokyoStation);
      
      // æ±äº¬é§…ãŒä¸­å¿ƒãªã®ã§ã€worldåº§æ¨™ã¯åŸç‚¹ä»˜è¿‘ã«ãªã‚‹ã¯ãš
      expect(Math.abs(worldCoords.x)).toBeLessThan(1);
      expect(Math.abs(worldCoords.z)).toBeLessThan(1);
      expect(worldCoords.y).toBe(0);
    });
  });

  describe('3D object creation', () => {
    it('should create terrain from terrain data', () => {
      const terrainData: TerrainData = {
        id: 'test-terrain', // Added id
        width: 10,
        height: 10,
        data: new Float32Array(100).fill(0),
        bounds: {
          min: { latitude: 35.680, longitude: 139.765 },
          max: { latitude: 35.682, longitude: 139.769 }
        },
        resolution: 1
      };
      
      const terrain = gisManager.createTerrain(terrainData);
      
      expect(terrain).toBeInstanceOf(THREE.Mesh);
      expect(terrain.geometry).toBeInstanceOf(THREE.PlaneGeometry);
      expect(terrain.material).toBeInstanceOf(THREE.MeshLambertMaterial);
    });

    it('should create building from building data', () => {
      const buildingData: BuildingData = {
        id: 'test-building',
        name: 'Test Building',
        coordinates: { latitude: 35.6812, longitude: 139.7671, altitude: 0 },
        height: 50,
        footprint: [
          { latitude: 35.6810, longitude: 139.7669 },
          { latitude: 35.6814, longitude: 139.7669 },
          { latitude: 35.6814, longitude: 139.7673 },
          { latitude: 35.6810, longitude: 139.7673 }
        ],
        properties: {
          type: 'office',
          floors: 10
        }
      };
      
      const building = gisManager.createBuilding(buildingData);
      
      expect(building).toBeInstanceOf(THREE.Group);
      expect(building.name).toBe('building-test-building');
      expect(building.children.length).toBeGreaterThan(0);
    });

    it('should create road from road data', () => {
      const roadData: RoadData = {
        id: 'test-road',
        name: 'Test Road',
        type: 'street',
        coordinates: [
          { latitude: 35.6810, longitude: 139.7669 },
          { latitude: 35.6814, longitude: 139.7673 }
        ],
        width: 8,
        properties: {
          surface: 'asphalt'
        }
      };
      
      const road = gisManager.createRoad(roadData);
      
      expect(road).toBeInstanceOf(THREE.Line);
      expect(road.name).toBe('road-test-road');
    });

    it('should create POI from POI data', () => {
      const poiData: POIData = {
        id: 'test-poi',
        name: 'Test POI',
        type: 'station',
        coordinate: { latitude: 35.6812, longitude: 139.7671 }, // Changed 'coordinates' to 'coordinate'
        properties: {}
      };
      
      const poi = gisManager.createPOI(poiData);
      
      expect(poi).toBeInstanceOf(THREE.Sprite);
      expect(poi.name).toBe('poi-test-poi');
    });
  });

  describe('layer management', () => {
    it('should add and retrieve layers', () => {
      const layer = {
        id: 'test-layer',
        name: 'Test Layer',
        type: 'building' as const, // Changed 'buildings' to 'building'
        visible: true,
        opacity: 1,
        data: []
      };
      
      gisManager.addLayer(layer);
      
      const retrievedLayer = gisManager.getLayer('test-layer');
      expect(retrievedLayer).toBe(layer);
    });

    it('should remove layers', () => {
      const layer = {
        id: 'test-layer',
        name: 'Test Layer',
        type: 'building' as const, // Changed 'buildings' to 'building'
        visible: true,
        opacity: 1,
        data: []
      };
      
      gisManager.addLayer(layer);
      gisManager.removeLayer('test-layer');
      
      const retrievedLayer = gisManager.getLayer('test-layer');
      expect(retrievedLayer).toBeUndefined();
    });

    it('should toggle layer visibility', () => {
      const layer = {
        id: 'test-layer',
        name: 'Test Layer',
        type: 'building' as const, // Changed 'buildings' to 'building'
        visible: true,
        opacity: 1,
        data: []
      };
      
      gisManager.addLayer(layer);
      gisManager.toggleLayer('test-layer');
      
      expect(layer.visible).toBe(false);
      
      gisManager.toggleLayer('test-layer');
      expect(layer.visible).toBe(true);
    });
  });
});
</file>

<file path="src/components/TokyoStationExplorer.tsx">
import React, { useEffect, useState, useCallback } from 'react';
import { Web3DExplorerComponent } from './Web3DExplorerComponent';
import { Explorer } from '../core/Explorer';
import { GISManager } from '../gis/GISManager';
import {
  Web3DExplorerConfig,
  PerformanceMetrics,
  GeoCoordinates
} from '../types';
import {
  TokyoStationArea,
  BuildingData,
  RoadData,
  POIData,
  TOKYO_PROJECTION
} from '../types/gis';
import * as THREE from 'three';

interface TokyoStationExplorerProps {
  className?: string;
  style?: React.CSSProperties;
  onLoadComplete?: () => void;
  showDebugInfo?: boolean;
}

/**
 * æ±äº¬é§…ã‚¨ãƒªã‚¢å°‚ç”¨ã®3Dæ¢ç´¢ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
export const TokyoStationExplorer: React.FC<TokyoStationExplorerProps> = ({
  className,
  style,
  onLoadComplete,
  showDebugInfo = false
}) => {
  const [explorer, setExplorer] = useState<Explorer | null>(null);
  const [gisManager, setGisManager] = useState<GISManager | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [metrics, setMetrics] = useState<PerformanceMetrics | null>(null);

  // æ±äº¬é§…ã‚¨ãƒªã‚¢ç”¨ã®è¨­å®š
  const config: Web3DExplorerConfig = {
    scene: {
      background: new THREE.Color(0x87ceeb), // ç©ºè‰²
      fog: {
        type: 'linear',
        color: new THREE.Color(0x87ceeb),
        near: 100,
        far: 1000
      },
      ambientLight: {
        color: new THREE.Color(0xffffff),
        intensity: 0.6
      }
    },
    camera: {
      fov: 60,
      aspect: window.innerWidth / window.innerHeight,
      near: 0.1,
      far: 2000,
      position: { x: 0, y: 50, z: 100 },
      target: { x: 0, y: 0, z: 0 }
    },
    renderer: {
      antialias: true,
      alpha: false,
      powerPreference: 'high-performance'
    },
    lights: [
      {
        type: 'directional',
        color: new THREE.Color(0xffffff),
        intensity: 1.0,
        position: { x: 50, y: 100, z: 50 },
        castShadow: true
      },
      {
        type: 'directional',
        color: new THREE.Color(0x4040ff),
        intensity: 0.3,
        position: { x: -50, y: 50, z: -50 },
        castShadow: false
      }
    ],
    debug: showDebugInfo,
    performance: {
      enableStats: showDebugInfo,
      maxFPS: 60,
      adaptiveQuality: true
    }
  };

  // æ±äº¬é§…ã‚¨ãƒªã‚¢ã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
  const loadTokyoStationData = useCallback(async (): Promise<TokyoStationArea> => {
    // ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯å¤–éƒ¨APIã‹ã‚‰å–å¾—ï¼‰
    const mockTokyoStation: BuildingData = {
      id: 'tokyo-station-main',
      name: 'æ±äº¬é§…',
      coordinates: { latitude: 35.6812, longitude: 139.7671, altitude: 0 },
      height: 30,
      footprint: [
        { latitude: 35.6810, longitude: 139.7669 },
        { latitude: 35.6814, longitude: 139.7669 },
        { latitude: 35.6814, longitude: 139.7673 },
        { latitude: 35.6810, longitude: 139.7673 }
      ],
      properties: {
        type: 'station',
        floors: 5,
        yearBuilt: 1914,
        material: 'brick'
      }
    };

    const mockBuildings: BuildingData[] = [
      {
        id: 'marunouchi-building',
        name: 'ä¸¸ã®å†…ãƒ“ãƒ«',
        coordinates: { latitude: 35.6815, longitude: 139.7665, altitude: 0 },
        height: 180,
        footprint: [
          { latitude: 35.6813, longitude: 139.7663 },
          { latitude: 35.6817, longitude: 139.7663 },
          { latitude: 35.6817, longitude: 139.7667 },
          { latitude: 35.6813, longitude: 139.7667 }
        ],
        properties: {
          type: 'office',
          floors: 37,
          yearBuilt: 2002
        }
      }
    ];

    const mockRoads: RoadData[] = [
      {
        id: 'marunouchi-nakadori',
        name: 'ä¸¸ã®å†…ä»²é€šã‚Š',
        type: 'street',
        coordinates: [
          { latitude: 35.6805, longitude: 139.7665 },
          { latitude: 35.6820, longitude: 139.7665 }
        ],
        width: 8,
        properties: {
          surface: 'asphalt',
          lanes: 2
        }
      }
    ];

    const mockPOIs: POIData[] = [
      {
        id: 'marunouchi-exit',
        name: 'ä¸¸ã®å†…å£',
        type: 'station',
        coordinate: { latitude: 35.6812, longitude: 139.7665 }, // Changed 'coordinates' to 'coordinate'
        properties: {
          exitNumber: 'A1'
        }
      }
    ];

    return {
      station: mockTokyoStation,
      platforms: [],
      concourse: [],
      exits: mockPOIs,
      nearbyBuildings: mockBuildings,
      roads: mockRoads,
      terrain: {
        id: 'tokyo-terrain', // Added id
        width: 200,
        height: 200,
        data: new Float32Array(200 * 200).fill(0), // å¹³å¦ãªåœ°å½¢
        bounds: {
          min: { latitude: 35.6800, longitude: 139.7650 },
          max: { latitude: 35.6825, longitude: 139.7690 }
        },
        resolution: 1
      }
    };
  }, []);

  // 3Dã‚·ãƒ¼ãƒ³ã«ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
  const setupTokyoStationScene = useCallback(async (explorer: Explorer) => {
    try {
      setLoadingProgress(10);
      
      const gisManager = new GISManager(); // Removed TOKYO_PROJECTION argument
      setGisManager(gisManager);
      
      setLoadingProgress(30);
      
      const tokyoStationData = await loadTokyoStationData();
      
      setLoadingProgress(50);
      
      // åœ°å½¢ã®è¿½åŠ 
      const terrain = gisManager.createTerrain(tokyoStationData.terrain);
      explorer.addObject(terrain, { name: 'terrain' });
      
      setLoadingProgress(60);
      
      // å»ºç‰©ã®è¿½åŠ 
      const stationBuilding = gisManager.createBuilding(tokyoStationData.station);
      explorer.addObject(stationBuilding, { name: 'tokyo-station' });
      
      tokyoStationData.nearbyBuildings.forEach((building: BuildingData, index: number) => {
        const buildingObject = gisManager.createBuilding(building);
        explorer.addObject(buildingObject, { name: `building-${index}` });
      });
      
      setLoadingProgress(80);
      
      // é“è·¯ã®è¿½åŠ 
      tokyoStationData.roads.forEach((road: RoadData, index: number) => {
        const roadObject = gisManager.createRoad(road);
        explorer.addObject(roadObject, { name: `road-${index}` });
      });
      
      // POIã®è¿½åŠ 
      tokyoStationData.exits.forEach((poi: POIData, index: number) => {
        const poiObject = gisManager.createPOI(poi);
        explorer.addObject(poiObject, { name: `poi-${index}` });
      });
      
      setLoadingProgress(100);
      setIsLoading(false);
      
      if (onLoadComplete) {
        onLoadComplete();
      }
      
    } catch (error) {
      console.error('Error setting up Tokyo Station scene:', error);
      setError(error instanceof Error ? error.message : 'Unknown error');
      setIsLoading(false);
    }
  }, [loadTokyoStationData, onLoadComplete]);

  const handleExplorerReady = useCallback((explorer: Explorer) => {
    setExplorer(explorer);
    setupTokyoStationScene(explorer);
  }, [setupTokyoStationScene]);

  const handlePerformanceUpdate = useCallback((newMetrics: PerformanceMetrics) => {
    setMetrics(newMetrics);
  }, []);

  if (error) {
    return (
      <div className="tokyo-station-error" style={{ padding: '20px', color: 'red' }}>
        <h3>Error loading Tokyo Station Explorer</h3>
        <p>{error}</p>
        <button onClick={() => window.location.reload()}>Reload</button>
      </div>
    );
  }

  return (
    <div 
      className={`tokyo-station-explorer ${className || ''}`}
      style={{
        width: '100%',
        height: '100%',
        position: 'relative',
        ...style
      }}
    >
      <Web3DExplorerComponent
        config={config}
        onExplorerReady={handleExplorerReady}
        onPerformanceUpdate={handlePerformanceUpdate}
      />
      
      {isLoading && (
        <div 
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(255, 255, 255, 0.9)',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000
          }}
        >
          <div style={{ fontSize: '18px', marginBottom: '20px' }}>
            Loading Tokyo Station Explorer...
          </div>
          <div 
            style={{
              width: '300px',
              height: '10px',
              background: '#e0e0e0',
              borderRadius: '5px',
              overflow: 'hidden'
            }}
          >
            <div 
              style={{
                width: `${loadingProgress}%`,
                height: '100%',
                background: 'linear-gradient(90deg, #4CAF50, #8BC34A)',
                transition: 'width 0.3s ease'
              }}
            />
          </div>
          <div style={{ marginTop: '10px', fontSize: '14px', color: '#666' }}>
            {loadingProgress}%
          </div>
        </div>
      )}
      
      {showDebugInfo && metrics && (
        <div 
          style={{
            position: 'absolute',
            top: '10px',
            right: '10px',
            background: 'rgba(0, 0, 0, 0.8)',
            color: 'white',
            padding: '15px',
            borderRadius: '8px',
            fontFamily: 'monospace',
            fontSize: '12px',
            minWidth: '200px',
            zIndex: 1000
          }}
        >
          <div style={{ fontWeight: 'bold', marginBottom: '10px' }}>
            Performance Metrics
          </div>
          <div>FPS: {metrics.fps}</div>
          <div>Frame Time: {metrics.frameTime?.toFixed(2)}ms</div>
          <div>Render Time: {metrics.renderTime?.toFixed(2)}ms</div>
          <div>Triangles: {metrics.triangleCount?.toLocaleString()}</div>
          <div>Draw Calls: {metrics.drawCalls}</div>
          <div>Memory: {metrics.memoryUsage.total}MB</div>
        </div>
      )}
      
      {!isLoading && (
        <div 
          style={{
            position: 'absolute',
            bottom: '20px',
            left: '20px',
            background: 'rgba(0, 0, 0, 0.7)',
            color: 'white',
            padding: '15px',
            borderRadius: '8px',
            maxWidth: '300px',
            zIndex: 1000
          }}
        >
          <h3 style={{ margin: '0 0 10px 0', fontSize: '16px' }}>
            Tokyo Station Explorer
          </h3>
          <p style={{ margin: '0', fontSize: '14px', lineHeight: '1.4' }}>
            æ±äº¬é§…å‘¨è¾ºã®3Då¯è¦–åŒ–ã§ã™ã€‚ãƒã‚¦ã‚¹ã§è¦–ç‚¹ã‚’æ“ä½œã—ã€å»ºç‰©ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è©³ç´°ã‚’ç¢ºèªã§ãã¾ã™ã€‚
          </p>
        </div>
      )}
    </div>
  );
};

export default TokyoStationExplorer;
</file>

<file path="src/core/Explorer.ts">
import * as THREE from 'three';
import { EventEmitter } from '../utils/EventEmitter';
import {
  Web3DExplorer as IWeb3DExplorer, // Aliased import
  Web3DExplorerConfig,
  Object3DConfig,
  PerformanceMetrics,
  EventHandler
} from '../types';

/**
 * Web3DExplorer ã®ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹
 * Three.js ã‚’ãƒ™ãƒ¼ã‚¹ã¨ã—ãŸ 3D å¯è¦–åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚³ã‚¢ã‚¨ãƒ³ã‚¸ãƒ³
 */
export class Explorer extends EventEmitter implements IWeb3DExplorer { // Use aliased interface
  public scene!: THREE.Scene; // Definite assignment assertion
  public camera!: THREE.PerspectiveCamera; // Definite assignment assertion
  public renderer!: THREE.WebGLRenderer; // Definite assignment assertion
  public config: Web3DExplorerConfig;
  
  private animationId: number | null = null;
  private stats: PerformanceMetrics;
  private clock: THREE.Clock;
  private raycaster: THREE.Raycaster;
  private mouse: THREE.Vector2;
  private isDisposed = false;

  constructor(config: Web3DExplorerConfig, container?: HTMLElement) {
    super();
    this.config = config;
    this.clock = new THREE.Clock();
    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2();
    
    this.initializeScene();
    this.initializeCamera();
    this.initializeRenderer(container);
    this.initializeLights();
    this.setupEventListeners();
    
    this.stats = this.createInitialStats();
    
    if (this.config.debug) {
      console.log('Web3DExplorer initialized', this.config);
    }
  }

  private initializeScene(): void {
    this.scene = new THREE.Scene();
    
    const sceneConfig = this.config.scene;
    if (sceneConfig?.background) { // Optional chaining
      this.scene.background = new THREE.Color(sceneConfig.background); // Ensure THREE.Color instance
    }
    
    if (sceneConfig?.fog) { // Optional chaining
      const { type, color, near, far, density } = sceneConfig.fog;
      if (type === 'linear' && near !== undefined && far !== undefined) {
        this.scene.fog = new THREE.Fog(new THREE.Color(color), near, far);
      } else if (type === 'exponential' && density !== undefined) {
        this.scene.fog = new THREE.FogExp2(new THREE.Color(color), density);
      }
    }
  }

  private initializeCamera(): void {
    const camConfig = this.config.camera; // Store in a variable for safer access
    if (!camConfig) {
        // Handle missing camera config, e.g., by creating a default camera
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 5, 10);
        return;
    }
    const { fov = 75, aspect = window.innerWidth / window.innerHeight, near = 0.1, far = 1000, position, target } = camConfig;
    this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    
    if (position) {
      this.camera.position.set(position.x, position.y, position.z);
    }
    
    if (target) {
      this.camera.lookAt(target.x, target.y, target.z);
    }
  }

  private initializeRenderer(container?: HTMLElement): void {
    const rendererConfig = this.config.renderer;
    this.renderer = new THREE.WebGLRenderer({
      canvas: rendererConfig?.canvas, // Optional chaining
      antialias: rendererConfig?.antialias ?? true,
      alpha: rendererConfig?.alpha ?? false,
      preserveDrawingBuffer: rendererConfig?.preserveDrawingBuffer ?? false,
      powerPreference: rendererConfig?.powerPreference ?? 'default',
      stencil: rendererConfig?.stencil ?? true,
      depth: rendererConfig?.depth ?? true,
      logarithmicDepthBuffer: rendererConfig?.logarithmicDepthBuffer ?? false
    });
    
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    if (container) {
      container.appendChild(this.renderer.domElement);
    } else if (document.body) {
      document.body.appendChild(this.renderer.domElement);
    }
  }

  private initializeLights(): void {
    this.config.lights?.forEach((lightConfig: any) => { // Added optional chaining and type annotation
      const light = this.createLight(lightConfig);
      if (light) {
        this.scene.add(light);
      }
    });
    
    // ã‚¢ãƒ³ãƒ“ã‚¨ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®è¿½åŠ 
    if (this.config.scene?.ambientLight) { // Optional chaining
      const { color, intensity } = this.config.scene.ambientLight;
      const ambientLight = new THREE.AmbientLight(new THREE.Color(color), intensity);
      this.scene.add(ambientLight);
    }
  }

  private createLight(config: any): THREE.Light | null {
    const { type, color, intensity, position, castShadow } = config;
    let light: THREE.Light;
    
    switch (type) {
      case 'directional':
        light = new THREE.DirectionalLight(color, intensity);
        if (castShadow) {
          light.castShadow = true;
          const shadowCam = (light as THREE.DirectionalLight).shadow.camera as THREE.OrthographicCamera;
          shadowCam.left = -50;
          shadowCam.right = 50;
          shadowCam.top = 50;
          shadowCam.bottom = -50;
          shadowCam.near = 0.1;
          shadowCam.far = 100;
        }
        break;
        
      case 'point':
        light = new THREE.PointLight(color, intensity);
        if (castShadow) {
          light.castShadow = true;
        }
        break;
        
      case 'spot':
        light = new THREE.SpotLight(color, intensity);
        if (castShadow) {
          light.castShadow = true;
        }
        break;
        
      case 'hemisphere':
        light = new THREE.HemisphereLight(color, color, intensity);
        break;
        
      default:
        console.warn(`Unsupported light type: ${type}`);
        return null;
    }
    
    if (position) {
      light.position.set(position.x, position.y, position.z);
    }
    
    return light;
  }

  private setupEventListeners(): void {
    window.addEventListener('resize', this.handleResize.bind(this));
    this.renderer.domElement.addEventListener('mousemove', this.handleMouseMove.bind(this));
    this.renderer.domElement.addEventListener('click', this.handleClick.bind(this));
  }

  private handleResize(): void {
    const width = window.innerWidth;
    const height = window.innerHeight;
    this.resize(width, height);
  }

  private handleMouseMove(event: MouseEvent): void {
    const rect = this.renderer.domElement.getBoundingClientRect();
    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  }

  private handleClick(event: MouseEvent): void {
    this.raycaster.setFromCamera(this.mouse, this.camera);
    const intersects = this.raycaster.intersectObjects(this.scene.children, true);
    
    if (intersects.length > 0) {
      const intersection = intersects[0];
      this.emit('object-click', {
        object: intersection.object,
        point: intersection.point,
        face: intersection.face,
        uv: intersection.uv,
        originalEvent: event
      });
    }
  }

  private createInitialStats(): PerformanceMetrics {
    return {
      fps: 0,
      frameTime: 0,
      renderTime: 0,
      triangles: 0, // Added missing 'triangles'
      triangleCount: 0,
      drawCalls: 0,
      memoryUsage: {
        geometries: 0,
        textures: 0,
        total: 0
      }
    };
  }

  private updateStats(): void {
    const info = this.renderer.info;
    
    this.stats = {
      fps: Math.round(1 / this.clock.getDelta()),
      frameTime: this.clock.getDelta() * 1000,
      renderTime: 0, // WebGLRenderer doesn't provide this directly
      triangles: info.render.triangles, // Added missing 'triangles'
      triangleCount: info.render.triangles,
      drawCalls: info.render.calls,
      memoryUsage: {
        geometries: info.memory.geometries,
        textures: info.memory.textures,
        total: info.memory.geometries + info.memory.textures
      }
    };
  }

  // Public API methods
  
  public addObject(object: THREE.Object3D, config?: Object3DConfig): void {
    if (config) {
      if (config.position) {
        object.position.set(config.position.x, config.position.y, config.position.z);
      }
      if (config.rotation) {
        object.rotation.set(config.rotation.x, config.rotation.y, config.rotation.z);
      }
      if (config.scale) {
        object.scale.set(config.scale.x, config.scale.y, config.scale.z);
      }
      if (config.visible !== undefined) {
        object.visible = config.visible;
      }
      if (config.name) {
        object.name = config.name;
      }
    }
    
    this.scene.add(object);
    this.emit('object-added', { object, config });
  }

  public removeObject(object: THREE.Object3D): void {
    this.scene.remove(object);
    this.emit('object-removed', { object });
  }

  public animate(callback?: () => void): void {
    if (this.isDisposed) return;
    
    this.animationId = requestAnimationFrame(() => this.animate(callback));
    
    this.updateStats();
    
    if (callback) {
      callback();
    }
    
    this.render();
    this.emit('frame', { stats: this.stats });
  }

  public render(): void {
    if (this.isDisposed) return;
    
    const startTime = performance.now();
    this.renderer.render(this.scene, this.camera);
    const endTime = performance.now();
    
    this.stats.renderTime = endTime - startTime;
  }

  public resize(width: number, height: number): void {
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(width, height);
    this.emit('resize', { width, height });
  }

  public getMetrics(): PerformanceMetrics {
    return { ...this.stats };
  }

  public dispose(): void {
    if (this.isDisposed) return;
    
    this.isDisposed = true;
    
    if (this.animationId !== null) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    
    // ãƒªã‚¹ãƒŠãƒ¼ã®å‰Šé™¤
    window.removeEventListener('resize', this.handleResize.bind(this));
    
    // Three.js ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ”¾
    this.scene.traverse((object) => {
      if (object instanceof THREE.Mesh) {
        object.geometry.dispose();
        if (Array.isArray(object.material)) {
          object.material.forEach(material => material.dispose());
        } else {
          object.material.dispose();
        }
      }
    });
    
    this.renderer.dispose();
    
    // DOMè¦ç´ ã®å‰Šé™¤
    if (this.renderer.domElement.parentElement) {
      this.renderer.domElement.parentElement.removeChild(this.renderer.domElement);
    }
    
    this.removeAllListeners();
    this.emit('disposed');
  }

  // EventEmitter methods are inherited
  public on<T>(event: string, handler: EventHandler<T>): void {
    super.on(event, handler);
  }

  public off<T>(event: string, handler: EventHandler<T>): void {
    super.off(event, handler);
  }

  public emit<T>(event: string, data?: T): void {
    super.emit(event, data);
  }
}

export default Explorer;
</file>

<file path="src/index.ts">
// ãƒ¡ã‚¤ãƒ³ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
import Explorer from './core/Explorer'; // Import Explorer as default
export { Explorer }; // Re-export Explorer
export { GISManager } from './gis/GISManager';
export { EventEmitter } from './utils/EventEmitter';

// React ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export { Web3DExplorerComponent } from './components/Web3DExplorerComponent';
export { TokyoStationExplorer } from './components/TokyoStationExplorer';

// å‹å®šç¾©
export * from './types';
export * from './types/gis';
export * from './types/testing';

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
import * as THREE from 'three';
import { Web3DExplorerConfig } from './types';
import type { TOKYO_PROJECTION } from './types/gis'; // Import as type

/**
 * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® Web3DExplorer è¨­å®š
 */
export const DEFAULT_CONFIG: Web3DExplorerConfig = {
  scene: {
    background: new THREE.Color(0x222222),
    fog: {
      type: 'linear',
      color: new THREE.Color(0x222222),
      near: 50,
      far: 500
    },
    ambientLight: {
      color: new THREE.Color(0x404040),
      intensity: 0.4
    }
  },
  camera: {
    fov: 75,
    aspect: window.innerWidth / window.innerHeight,
    near: 0.1,
    far: 1000,
    position: { x: 0, y: 5, z: 10 }
  },
  renderer: {
    antialias: true,
    alpha: false,
    powerPreference: 'default'
  },
  lights: [
    {
      type: 'directional',
      color: new THREE.Color(0xffffff),
      intensity: 1.0,
      position: { x: 5, y: 10, z: 5 },
      castShadow: true
    }
  ],
  debug: false
};

/**
 * æ±äº¬é§…ã‚¨ãƒªã‚¢å°‚ç”¨ã®è¨­å®š
 */
export const TOKYO_STATION_CONFIG: Web3DExplorerConfig = {
  scene: {
    background: new THREE.Color(0x87ceeb),
    fog: {
      type: 'linear',
      color: new THREE.Color(0x87ceeb),
      near: 100,
      far: 1000
    },
    ambientLight: {
      color: new THREE.Color(0xffffff),
      intensity: 0.6
    }
  },
  camera: {
    fov: 60,
    aspect: window.innerWidth / window.innerHeight,
    near: 0.1,
    far: 2000,
    position: { x: 0, y: 50, z: 100 },
    target: { x: 0, y: 0, z: 0 }
  },
  renderer: {
    antialias: true,
    alpha: false,
    powerPreference: 'high-performance'
  },
  lights: [
    {
      type: 'directional',
      color: new THREE.Color(0xffffff),
      intensity: 1.0,
      position: { x: 50, y: 100, z: 50 },
      castShadow: true
    },
    {
      type: 'directional',
      color: new THREE.Color(0x4040ff),
      intensity: 0.3,
      position: { x: -50, y: 50, z: -50 },
      castShadow: false
    }
  ],
  debug: false
};

// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
/**
 * Web3DExplorer ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
 */
export function createExplorer(config?: Partial<Web3DExplorerConfig>, container?: HTMLElement): Explorer {
  const finalConfig = { ...DEFAULT_CONFIG, ...config };
  return new Explorer(finalConfig, container);
}

/**
 * æ±äº¬é§…ã‚¨ãƒªã‚¢å°‚ç”¨ã® Explorer ã‚’ä½œæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
 */
export function createTokyoStationExplorer(container?: HTMLElement): Explorer {
  return new Explorer(TOKYO_STATION_CONFIG, container);
}

// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³
export type { TOKYO_PROJECTION }; // Export as type

// ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±
export const VERSION = '0.1.0';
export const LIBRARY_NAME = 'Web3DExplorer';
</file>

<file path="three-test-suite/__tests__/unit/HTMLGenerator.test.js">
import { HTMLGenerator } from '../../src/HTMLGenerator.js';
import { BrowserManager } from '../../src/BrowserManager.js'; // For tests that need to load HTML

describe('HTMLGenerator - HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ', () => {
  let htmlGenerator;
  let browserManager; // For tests that need to load HTML

  beforeAll(() => {
    htmlGenerator = new HTMLGenerator();
  });

  beforeEach(async () => {
    // Initialize browserManager only for tests that need it
  });

  afterEach(async () => {
    if (browserManager && browserManager.isInitialized()) {
      await browserManager.cleanup();
    }
    browserManager = null; // Reset for next test
  });

  test('åŸºæœ¬HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒç”Ÿæˆã•ã‚Œã‚‹', () => {
    const html = htmlGenerator.generateTestHTML(() => {});
    expect(html).toContain('<!DOCTYPE html>');
    expect(html).toContain('https://cdnjs.cloudflare.com/ajax/libs/three.js/0.173.0/three.module.min.js'); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ¼ã‚¸ãƒ§ãƒ³ç¢ºèª
    expect(html).toContain('<canvas');
    expect(html).toContain('id="three-canvas"');
  });

  test('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒæ³¨å…¥ã•ã‚Œã‚‹', () => {
    const userScript = () => { console.log('test'); };
    const html = htmlGenerator.generateTestHTML(userScript);
    expect(html).toContain(userScript.toString());
  });

  test('ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«ãŒè¨­å®šã•ã‚Œã‚‹', () => {
    const customTitle = 'Custom Three.js Test';
    const html = htmlGenerator.generateTestHTML(() => {}, { title: customTitle });
    expect(html).toContain(`<title>${customTitle}</title>`);
  });

  test('ç•°ãªã‚‹Three.jsãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒæŒ‡å®šã§ãã‚‹', () => {
    const customVersion = '0.173.0'; 
    const html = htmlGenerator.generateTestHTML(() => {}, { threeJsVersion: customVersion });
    expect(html).toContain(`https://cdnjs.cloudflare.com/ajax/libs/three.js/${customVersion}/three.module.min.js`); 
  });

  test('ç•°ãªã‚‹Three.jsãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒæŒ‡å®šã§ãã‚‹ (0.172.0ä»¥é™)', () => {
    const customVersion = '0.173.0';
    const html = htmlGenerator.generateTestHTML(() => {}, { threeJsVersion: customVersion });
    expect(html).toContain(`https://cdnjs.cloudflare.com/ajax/libs/three.js/${customVersion}/three.module.min.js`); 
  });

  test('è‡ªå‹•å®Ÿè¡Œã‚’ç„¡åŠ¹ã«ã§ãã‚‹', () => {
    const userScript = () => { console.log('test'); };
    const html = htmlGenerator.generateTestHTML(userScript, { autoExecute: false });
    expect(html).toContain('window.userScript');
    expect(html).not.toContain("window.addEventListener('load'");
  });

  test('ç„¡åŠ¹ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', () => {
    expect(() => htmlGenerator.generateTestHTML('not a function')).toThrow('userScript must be a function');
    expect(() => htmlGenerator.generateTestHTML(null)).toThrow('userScript must be a function');
  });
  
  test('ãƒ‡ãƒãƒƒã‚°æƒ…å ±è¦ç´ ãŒå«ã¾ã‚Œã‚‹', () => {
    const html = htmlGenerator.generateTestHTML(() => {});
    expect(html).toContain('class="debug-info"');
    expect(html).toContain('id="debug-info"');
  });
});
</file>

<file path="three-test-suite/__tests__/unit/PuppeteerManager.test.js">
import { PuppeteerManager } from '../../src/PuppeteerManager.js';
import { BrowserManager } from '../../src/BrowserManager.js';
import { EnvironmentInspector } from '../../src/EnvironmentInspector.js';
import { PerformanceTester } from '../../src/PerformanceTester.js';
import { HTMLGenerator } from '../../src/HTMLGenerator.js';
import { ThreeTestSuite } from '../../src/threejs/ThreeTestSuite.js';

describe('PuppeteerManager - ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã‚¯ãƒ©ã‚¹ã¨ã—ã¦ã®ãƒ†ã‚¹ãƒˆ', () => {
  let manager;

  beforeEach(async () => {
    manager = new PuppeteerManager({ headless: true });
    await manager.initialize();
  });

  afterEach(async () => {
    if (manager) {
      await manager.cleanup();
      manager = null;
    }
  });

  test('initializeã¨cleanupãŒBrowserManagerã«å§”è­²ã•ã‚Œã‚‹', () => {
    expect(manager.browserManager).toBeInstanceOf(BrowserManager);
    expect(manager.isInitialized()).toBe(true);
  });

  // === Issue #18 Phase1å¯¾å¿œ: ThreeTestSuiteçµ±åˆãƒ†ã‚¹ãƒˆ ===
  test('ThreeTestSuiteã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä½œæˆã•ã‚Œã‚‹', () => {
    expect(manager.threeTestSuite).toBeInstanceOf(ThreeTestSuite);
    expect(manager.getThreeTestSuite()).toBe(manager.threeTestSuite);
  });

  test('getWebGLInfoãŒEnvironmentInspectorã«å§”è­²ã•ã‚Œã‚‹', async () => {
    const webglInfo = await manager.getWebGLInfo();
    expect(webglInfo).toBeDefined();
    expect(webglInfo.webglSupported).toBe(true);
  });

  test('benchmarkWebAssemblyãŒPerformanceTesterã«å§”è­²ã•ã‚Œã‚‹', async () => {
    const perf = await manager.benchmarkWebAssembly();
    expect(perf).toBeDefined();
    expect(perf.executionTime).toBeGreaterThanOrEqual(0);
  });

  test('generateTestHTMLãŒHTMLGeneratorã«å§”è­²ã•ã‚Œã‚‹', () => {
    const html = manager.generateTestHTML(() => {});
    expect(html).toContain('three.module.min.js');
  });
  
  test('page getterãŒBrowserManagerã®pageã‚’è¿”ã™', () => {
    expect(manager.page).toBe(manager.browserManager.page);
  });

  test('browser getterãŒBrowserManagerã®browserã‚’è¿”ã™', () => {
    expect(manager.browser).toBe(manager.browserManager.browser);
  });
  
  test('options getterãŒBrowserManagerã®optionsã‚’è¿”ã™', () => {
    expect(manager.options).toBe(manager.browserManager.options);
  });
});

describe('PuppeteerManager - Three.jsã‚·ãƒ¼ãƒ³æ³¨å…¥ï¼ˆThreeTestSuiteã¸ã®å§”è­²ãƒ†ã‚¹ãƒˆï¼‰', () => {
  let manager;

  beforeEach(async () => {
    manager = new PuppeteerManager({ headless: true });
    await manager.initialize();
  });

  afterEach(async () => {
    if (manager) {
      await manager.cleanup();
      manager = null;
    }
  });

  test('loadThreeSceneãŒThreeTestSuiteã«å§”è­²ã•ã‚Œã‚‹', async () => {
    await manager.loadThreeScene(() => {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();
      renderer = new THREE.WebGLRenderer();
      window.setupComplete = true;
    });
    
    const setupComplete = await manager.page.evaluate(() => window.setupComplete);
    expect(setupComplete).toBe(true);
  });

  test('runComprehensiveTestãŒThreeTestSuiteã«å§”è­²ã•ã‚Œã‚‹', async () => {
    const result = await manager.runComprehensiveTest();
    expect(result).toMatchObject({
      success: true,
      message: expect.stringContaining('Phase2 feature')
    });
  });

  test('getVisibleObjectsãŒThreeTestSuiteã«å§”è­²ã•ã‚Œã‚‹', async () => {
    const objects = await manager.getVisibleObjects();
    expect(objects).toEqual([]);
  });

  test('validateRenderingãŒThreeTestSuiteã«å§”è­²ã•ã‚Œã‚‹', async () => {
    const result = await manager.validateRendering();
    expect(result).toMatchObject({
      success: true,
      message: expect.stringContaining('Phase3 feature')
    });
  });

  test('loadThreeScene()ã¯åˆæœŸåŒ–å‰ã«å‘¼ã¶ã¨ThreeTestSuiteã§ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
    const uninitializedManager = new PuppeteerManager();
    
    await expect(
      uninitializedManager.loadThreeScene(() => {})
    ).rejects.toThrow('BrowserManager is not initialized');
  });

  test('ç„¡åŠ¹ãªã‚·ãƒ¼ãƒ³é–¢æ•°ã§ThreeTestSuiteãŒã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
    await expect(manager.loadThreeScene('not a function')).rejects.toThrow('sceneBuilderFunction must be a function');
    await expect(manager.loadThreeScene(null)).rejects.toThrow('sceneBuilderFunction must be a function');
    await expect(manager.loadThreeScene(undefined)).rejects.toThrow('sceneBuilderFunction must be a function');
  });

  test('window.sceneReadyãŒ true ã«ãªã‚‹', async () => {
    await manager.loadThreeScene(() => {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();
      renderer = new THREE.WebGLRenderer();
    });
    
    const sceneReady = await manager.page.evaluate(() => window.sceneReady);
    expect(sceneReady).toBe(true);
  });

  test('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã®é©åˆ‡ãªå‡¦ç†', async () => {
    await expect(manager.loadThreeScene(() => {
      throw new Error('Test error');
    })).rejects.toThrow('Test error');
  });

  test('Three.jsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ­£ã—ãä½œæˆã•ã‚Œã‚‹', async () => {
    await manager.loadThreeScene(() => {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer();
      
      const isValidWebGLRenderer = (
        renderer instanceof THREE.WebGLRenderer &&
        renderer.constructor === THREE.WebGLRenderer &&
        typeof renderer.render === 'function' &&
        typeof renderer.setSize === 'function'
      );
      
      window.sceneObjects = {
        sceneType: scene.type,
        cameraType: camera.type,
        isValidWebGLRenderer: isValidWebGLRenderer,
        rendererHasRenderMethod: typeof renderer.render === 'function',
        rendererHasSetSizeMethod: typeof renderer.setSize === 'function',
        sceneName: scene.name || 'Scene',
        threeAvailable: typeof THREE !== 'undefined',
        webglRendererAvailable: typeof THREE !== 'undefined' && typeof THREE.WebGLRenderer !== 'undefined',
        isRendererInstanceOfWebGL: renderer instanceof THREE.WebGLRenderer,
        rendererConstructorName: renderer.constructor.name
      };
    });
    
    const sceneObjects = await manager.page.evaluate(() => window.sceneObjects);
    
    expect(sceneObjects.threeAvailable).toBe(true);
    expect(sceneObjects.webglRendererAvailable).toBe(true);
    expect(sceneObjects.isRendererInstanceOfWebGL).toBe(true);
    expect(sceneObjects.isValidWebGLRenderer).toBe(true);
    expect(sceneObjects.rendererHasRenderMethod).toBe(true);
    expect(sceneObjects.rendererHasSetSizeMethod).toBe(true);
    expect(sceneObjects.sceneType).toBe('Scene');
    expect(sceneObjects.cameraType).toBe('PerspectiveCamera');
  });

  test('è¤‡é›‘ãªã‚·ãƒ¼ãƒ³ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãŒå®Ÿè¡Œã•ã‚Œã‚‹', async () => {
    await manager.loadThreeScene(() => {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer();
      
      const geometry = new THREE.BoxGeometry();
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);
      
      const light = new THREE.DirectionalLight(0xffffff, 1);
      scene.add(light);
      
      camera.position.z = 5;
      renderer.setSize(800, 600);
      renderer.render(scene, camera);
      
      window.sceneAnalysis = {
        objectCount: scene.children.length,
        hasLight: scene.children.some(child => child.type.includes('Light')),
        hasMesh: scene.children.some(child => child.type === 'Mesh'),
        cameraPosition: { x: camera.position.x, y: camera.position.y, z: camera.position.z }
      };
    });
    
    const analysis = await manager.page.evaluate(() => window.sceneAnalysis);
    expect(analysis.objectCount).toBe(2);
    expect(analysis.hasLight).toBe(true);
    expect(analysis.hasMesh).toBe(true);
    expect(analysis.cameraPosition.z).toBe(5);
  });

  test('ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒé©ç”¨ã•ã‚Œã‚‹', async () => {
    await manager.loadThreeScene(() => {
      window.customSceneLoaded = true;
    }, {
      title: 'Custom Scene Test',
      threeJsVersion: '0.150.0',
      timeout: 15000
    });
    
    const customSceneLoaded = await manager.page.evaluate(() => window.customSceneLoaded);
    expect(customSceneLoaded).toBe(true);
    
    const title = await manager.page.title();
    expect(title).toBe('Custom Scene Test');
  });
});

// === æ—¢å­˜ã®äº’æ›æ€§ãƒ†ã‚¹ãƒˆã‚’ç¶­æŒ ===
describe('PuppeteerManager - æ—¢å­˜æ©Ÿèƒ½ã®äº’æ›æ€§ãƒ†ã‚¹ãƒˆ', () => {
  let manager;

  beforeEach(async () => {
    manager = new PuppeteerManager({ headless: true });
    await manager.initialize();
  });

  afterEach(async () => {
    if (manager) {
      await manager.cleanup();
      manager = null;
    }
  });

  test('æ—¢å­˜ã®loadThreeSceneãƒ¡ã‚½ãƒƒãƒ‰ãŒå‹•ä½œã™ã‚‹ï¼ˆéæ¨å¥¨ï¼‰', async () => {
    // @deprecated ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¤ã¤ã€äº’æ›æ€§ã‚’ãƒ†ã‚¹ãƒˆ
    await manager.loadThreeScene(() => {
      const scene = new THREE.Scene();
      window.legacyTestComplete = true;
    });
    
    const testComplete = await manager.page.evaluate(() => window.legacyTestComplete);
    expect(testComplete).toBe(true);
  });

  test('æ—¢å­˜ã®Three.jsæ©Ÿèƒ½ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒç¶­æŒã•ã‚Œã‚‹', async () => {
    // PuppeteerManagerçµŒç”±ã§Three.jsæ©Ÿèƒ½ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã“ã¨ã‚’ç¢ºèª
    const comprehensiveResult = await manager.runComprehensiveTest();
    const visibleObjects = await manager.getVisibleObjects();
    const renderingResult = await manager.validateRendering();
    
    expect(comprehensiveResult.success).toBe(true);
    expect(visibleObjects).toEqual([]);
    expect(renderingResult.success).toBe(true);
  });
});
</file>

<file path="three-test-suite/__tests__/unit/SceneInspector.test.js">
/**
 * SceneInspector ã®ãƒ†ã‚¹ãƒˆ
 * Issue #18 Phase1ã§è¿½åŠ ã•ã‚ŒãŸSceneInspectorã‚¯ãƒ©ã‚¹ã®å˜ä½“ãƒ†ã‚¹ãƒˆ
 */
import { SceneInspector } from '../../src/threejs/SceneInspector.js';
import { BrowserManager } from '../../src/BrowserManager.js';
import { HTMLGenerator } from '../../src/HTMLGenerator.js';

describe('SceneInspector', () => {
  let browserManager;
  let sceneInspector;
  let htmlGenerator;

  beforeEach(async () => {
    browserManager = new BrowserManager({
      headless: true,
      timeout: 10000
    });
    await browserManager.initialize();
    sceneInspector = new SceneInspector(browserManager);
    htmlGenerator = new HTMLGenerator();
  });

  afterEach(async () => {
    if (browserManager && browserManager.isInitialized()) {
      await browserManager.cleanup();
    }
  });

  describe('Constructor', () => {
    it('should create SceneInspector instance with BrowserManager', () => {
      expect(sceneInspector).toBeInstanceOf(SceneInspector);
      expect(sceneInspector.browserManager).toBe(browserManager);
    });

    it('should throw error when BrowserManager is not provided', () => {
      expect(() => {
        new SceneInspector();
      }).toThrow('BrowserManager instance is required');
    });

    it('should throw error when null BrowserManager is provided', () => {
      expect(() => {
        new SceneInspector(null);
      }).toThrow('BrowserManager instance is required');
    });
  });

  describe('Scene Information Retrieval', () => {
    beforeEach(async () => {
      // Three.jsã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
      const htmlContent = htmlGenerator.generateTestHTML(() => {}, {
        threeJsVersion: '0.163.0',
        autoExecute: false
      });
      
      await browserManager.page.setContent(htmlContent, {
        waitUntil: 'networkidle0',
        timeout: 10000
      });

      // Three.jsã®èª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…æ©Ÿ
      await browserManager.page.waitForFunction(
        () => window.threeJsLoaded === true,
        { timeout: 10000 }
      );
    });

    it('should throw error when BrowserManager is not initialized', async () => {
      const uninitializedBrowserManager = new BrowserManager();
      const uninitializedInspector = new SceneInspector(uninitializedBrowserManager);
      
      await expect(
        uninitializedInspector.getSceneInfo()
      ).rejects.toThrow('BrowserManager is not initialized');
    });

    it('should return unavailable status when scene is not found', async () => {
      const sceneInfo = await sceneInspector.getSceneInfo();
      
      expect(sceneInfo).toMatchObject({
        available: false,
        error: 'Scene not found in window.scene'
      });
    });

    it('should return scene information when scene exists', async () => {
      // ã‚·ãƒ¼ãƒ³ã‚’ä½œæˆ
      await browserManager.page.evaluate(() => {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x404040);
        window.scene = scene;
      });

      const sceneInfo = await sceneInspector.getSceneInfo();
      
      expect(sceneInfo).toMatchObject({
        available: true,
        children: 0,
        background: expect.any(String),
        fog: null,
        autoUpdate: true,
        matrixAutoUpdate: true,
        uuid: expect.any(String),
        type: 'Scene'
      });
    });

    it('should return scene with fog information', async () => {
      await browserManager.page.evaluate(() => {
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xcccccc, 10, 15);
        window.scene = scene;
      });

      const sceneInfo = await sceneInspector.getSceneInfo();
      
      expect(sceneInfo.fog).toMatchObject({
        type: 'Fog',
        near: 10,
        far: 15,
        color: expect.any(Number)
      });
    });
  });

  describe('Camera Information Retrieval', () => {
    beforeEach(async () => {
      const htmlContent = htmlGenerator.generateTestHTML(() => {}, {
        threeJsVersion: '0.163.0',
        autoExecute: false
      });
      
      await browserManager.page.setContent(htmlContent, {
        waitUntil: 'networkidle0',
        timeout: 10000
      });

      await browserManager.page.waitForFunction(
        () => window.threeJsLoaded === true,
        { timeout: 10000 }
      );
    });

    it('should return unavailable status when camera is not found', async () => {
      const cameraInfo = await sceneInspector.getCameraInfo();
      
      expect(cameraInfo).toMatchObject({
        available: false,
        error: 'Camera not found in window.camera'
      });
    });

    it('should return camera information when camera exists', async () => {
      await browserManager.page.evaluate(() => {
        const camera = new THREE.PerspectiveCamera(75, 16/9, 0.1, 1000);
        camera.position.set(0, 0, 5);
        window.camera = camera;
      });

      const cameraInfo = await sceneInspector.getCameraInfo();
      
      expect(cameraInfo).toMatchObject({
        available: true,
        type: 'PerspectiveCamera',
        position: {
          x: 0,
          y: 0,
          z: 5
        },
        rotation: {
          x: expect.any(Number),
          y: expect.any(Number),
          z: expect.any(Number)
        },
        fov: 75,
        aspect: expect.any(Number),
        near: 0.1,
        far: 1000,
        zoom: 1,
        uuid: expect.any(String)
      });
    });

    it('should handle orthographic camera', async () => {
      await browserManager.page.evaluate(() => {
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
        window.camera = camera;
      });

      const cameraInfo = await sceneInspector.getCameraInfo();
      
      expect(cameraInfo.type).toBe('OrthographicCamera');
      expect(cameraInfo.fov).toBeNull();
    });
  });

  describe('Renderer Information Retrieval', () => {
    beforeEach(async () => {
      const htmlContent = htmlGenerator.generateTestHTML(() => {}, {
        threeJsVersion: '0.163.0',
        autoExecute: false
      });
      
      await browserManager.page.setContent(htmlContent, {
        waitUntil: 'networkidle0',
        timeout: 10000
      });

      await browserManager.page.waitForFunction(
        () => window.threeJsLoaded === true,
        { timeout: 10000 }
      );
    });

    it('should return unavailable status when renderer is not found', async () => {
      const rendererInfo = await sceneInspector.getRendererInfo();
      
      expect(rendererInfo).toMatchObject({
        available: false,
        error: 'Renderer not found in window.renderer'
      });
    });

    it('should return renderer information when renderer exists', async () => {
      await browserManager.page.evaluate(() => {
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(800, 600);
        window.renderer = renderer;
      });

      const rendererInfo = await sceneInspector.getRendererInfo();
      
      expect(rendererInfo).toMatchObject({
        available: true,
        type: 'WebGLRenderer',
        size: {
          width: expect.any(Number),
          height: expect.any(Number)
        },
        pixelRatio: expect.any(Number),
        shadowMap: {
          enabled: expect.any(Boolean),
          type: expect.any(Number)
        },
        autoClear: expect.any(Boolean),
        sortObjects: expect.any(Boolean)
      });
    });
  });

  describe('Comprehensive Information', () => {
    beforeEach(async () => {
      const htmlContent = htmlGenerator.generateTestHTML(() => {}, {
        threeJsVersion: '0.163.0',
        autoExecute: false
      });
      
      await browserManager.page.setContent(htmlContent, {
        waitUntil: 'networkidle0',
        timeout: 10000
      });

      await browserManager.page.waitForFunction(
        () => window.threeJsLoaded === true,
        { timeout: 10000 }
      );
    });

    it('should return comprehensive information for complete scene', async () => {
      // å®Œå…¨ãªã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
      await browserManager.page.evaluate(() => {
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 16/9, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(800, 600);
        
        window.scene = scene;
        window.camera = camera;
        window.renderer = renderer;
      });

      const info = await sceneInspector.getComprehensiveInfo();
      
      expect(info).toMatchObject({
        timestamp: expect.any(String),
        scene: {
          available: true
        },
        camera: {
          available: true
        },
        renderer: {
          available: true
        },
        status: {
          sceneReady: true,
          cameraReady: true,
          rendererReady: true,
          allReady: true
        }
      });
    });

    it('should return mixed status when only some components are available', async () => {
      await browserManager.page.evaluate(() => {
        const scene = new THREE.Scene();
        window.scene = scene;
        // cameraã¨rendererã¯æ„å›³çš„ã«ã‚»ãƒƒãƒˆã—ãªã„
      });

      const info = await sceneInspector.getComprehensiveInfo();
      
      expect(info.status).toMatchObject({
        sceneReady: true,
        cameraReady: false,
        rendererReady: false,
        allReady: false
      });
    });
  });

  describe('Utility Methods', () => {
    beforeEach(async () => {
      const htmlContent = htmlGenerator.generateTestHTML(() => {}, {
        threeJsVersion: '0.163.0',
        autoExecute: false
      });
      
      await browserManager.page.setContent(htmlContent, {
        waitUntil: 'networkidle0',
        timeout: 10000
      });

      await browserManager.page.waitForFunction(
        () => window.threeJsLoaded === true,
        { timeout: 10000 }
      );
    });

    it('should return 0 object count when scene is not available', async () => {
      const count = await sceneInspector.getObjectCount();
      expect(count).toBe(0);
    });

    it('should return correct object count when scene has objects', async () => {
      await browserManager.page.evaluate(() => {
        const scene = new THREE.Scene();
        const cube = new THREE.Mesh(
          new THREE.BoxGeometry(),
          new THREE.MeshBasicMaterial({ color: 0x00ff00 })
        );
        scene.add(cube);
        window.scene = scene;
      });

      const count = await sceneInspector.getObjectCount();
      expect(count).toBe(1);
    });

    it('should return Three.js status information', async () => {
      const status = await sceneInspector.getThreeJsStatus();
      
      expect(status).toMatchObject({
        threeLoaded: true,
        version: expect.any(String),
        webglAvailable: expect.any(Boolean),
        webgl2Available: expect.any(Boolean),
        sceneReady: expect.any(Boolean),
        threeJsLoaded: expect.any(Boolean)
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle page evaluation errors gracefully', async () => {
      // ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¦ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã‚’ä½œã‚‹
      await browserManager.cleanup();
      
      await expect(
        sceneInspector.getSceneInfo()
      ).rejects.toThrow();
    });

    it('should provide meaningful error messages', async () => {
      await browserManager.cleanup();
      
      try {
        await sceneInspector.getCameraInfo();
      } catch (error) {
        expect(error.message).toContain('BrowserManager is not initialized');
      }
    });
  });
});
</file>

<file path="three-test-suite/__tests__/unit/TestUtils.test.js">
import { TestUtils } from '../../src/utils/TestUtils.js';
import { BrowserManager } from '../../src/BrowserManager.js';

describe('TestUtils - åŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ', () => {
  describe('createIsolatedBrowserInstance', () => {
    test('ç‹¬ç«‹ã—ãŸãƒ–ãƒ©ã‚¦ã‚¶ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä½œæˆã•ã‚Œã‚‹', async () => {
      const browserManager = await TestUtils.createIsolatedBrowserInstance();
      
      expect(browserManager).toBeInstanceOf(BrowserManager);
      expect(browserManager.isInitialized()).toBe(true);
      expect(browserManager.page).toBeDefined();
      expect(browserManager.browser).toBeDefined();
      
      await browserManager.cleanup();
    }, 30000);

    test('ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒé©ç”¨ã•ã‚Œã‚‹', async () => {
      const customOptions = {
        width: 800,
        height: 600,
        headless: true
      };
      
      const browserManager = await TestUtils.createIsolatedBrowserInstance(customOptions);
      
      expect(browserManager.options.width).toBe(800);
      expect(browserManager.options.height).toBe(600);
      expect(browserManager.options.headless).toBe(true);
      
      await browserManager.cleanup();
    }, 30000);
  });

  describe('resetGlobalState', () => {
    let browserManager;

    beforeEach(async () => {
      browserManager = await TestUtils.createIsolatedBrowserInstance();
    });

    afterEach(async () => {
      if (browserManager && browserManager.isInitialized()) {
        await browserManager.cleanup();
      }
    });

    test('windowãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚¯ãƒªã‚¢ã•ã‚Œã‚‹', async () => {
      // ãƒ†ã‚¹ãƒˆç”¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®š
      await browserManager.page.evaluate(() => {
        window.testProperty = 'test value';
        window.sceneReady = true;
        window.cubeRendered = true;
      });

      // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      const beforeReset = await browserManager.page.evaluate(() => ({
        testProperty: window.testProperty,
        sceneReady: window.sceneReady,
        cubeRendered: window.cubeRendered
      }));

      expect(beforeReset.testProperty).toBe('test value');
      expect(beforeReset.sceneReady).toBe(true);
      expect(beforeReset.cubeRendered).toBe(true);

      // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      await TestUtils.resetGlobalState(browserManager.page);

      // ãƒ†ã‚¹ãƒˆç”¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚¯ãƒªã‚¢ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      const afterReset = await browserManager.page.evaluate(() => ({
        testProperty: window.testProperty,
        sceneReady: window.sceneReady,
        cubeRendered: window.cubeRendered
      }));

      expect(afterReset.testProperty).toBeUndefined();
      expect(afterReset.sceneReady).toBeUndefined();
      expect(afterReset.cubeRendered).toBeUndefined();
    });

    test('pageã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç„¡åŠ¹ãªå ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
      await expect(TestUtils.resetGlobalState(null)).rejects.toThrow('Page object is required for resetting global state');
      await expect(TestUtils.resetGlobalState(undefined)).rejects.toThrow('Page object is required for resetting global state');
    });
  });

  describe('setupTest ã¨ cleanupTest', () => {
    test('çµ±ä¸€çš„ãªãƒ†ã‚¹ãƒˆç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—', async () => {
      const testEnv = await TestUtils.setupTest();

      expect(testEnv).toBeDefined();
      expect(testEnv.browserManager).toBeInstanceOf(BrowserManager);
      expect(testEnv.page).toBeDefined();
      expect(testEnv.browser).toBeDefined();
      expect(testEnv.browserManager.isInitialized()).toBe(true);

      await TestUtils.cleanupTest(testEnv);

      // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å¾Œã®çŠ¶æ…‹ç¢ºèª
      expect(testEnv.page).toBeNull();
      expect(testEnv.browser).toBeNull();
      expect(testEnv.browserManager).toBeNull();
    }, 30000);

    test('ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—', async () => {
      const options = {
        browserOptions: { width: 1200, height: 800 },
        timeout: 20000
      };

      const testEnv = await TestUtils.setupTest(options);

      expect(testEnv.browserManager.options.width).toBe(1200);
      expect(testEnv.browserManager.options.height).toBe(800);

      await TestUtils.cleanupTest(testEnv);
    }, 30000);

    test('nullã§ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã¯å®‰å…¨ã«å‡¦ç†ã•ã‚Œã‚‹', async () => {
      await expect(TestUtils.cleanupTest(null)).resolves.not.toThrow();
      await expect(TestUtils.cleanupTest(undefined)).resolves.not.toThrow();
    });
  });

  describe('waitForCondition', () => {
    let browserManager;

    beforeEach(async () => {
      browserManager = await TestUtils.createIsolatedBrowserInstance();
    });

    afterEach(async () => {
      if (browserManager && browserManager.isInitialized()) {
        await browserManager.cleanup();
      }
    });

    test('æ¡ä»¶ãŒæº€ãŸã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã™ã‚‹', async () => {
      // 1ç§’å¾Œã«ãƒ•ãƒ©ã‚°ã‚’trueã«ã™ã‚‹
      await browserManager.page.evaluate(() => {
        setTimeout(() => {
          window.testCondition = true;
        }, 1000);
      });

      await TestUtils.waitForCondition(
        browserManager.page,
        'window.testCondition === true',
        { timeout: 5000, interval: 100 }
      );

      const condition = await browserManager.page.evaluate(() => window.testCondition);
      expect(condition).toBe(true);
    });

    test('ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã«ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', async () => {
      await expect(
        TestUtils.waitForCondition(
          browserManager.page,
          'window.nonExistentCondition === true',
          { timeout: 1000, retries: 1 }
        )
      ).rejects.toThrow('Condition not met within timeout');
    });
  });

  describe('safeCleanup', () => {
    test('è¤‡æ•°ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°ã‚’å®‰å…¨ã«å®Ÿè¡Œã™ã‚‹', async () => {
      let count = 0;
      
      const cleanup1 = async () => { count += 1; };
      const cleanup2 = async () => { count += 2; };
      const cleanup3 = async () => { throw new Error('Cleanup error'); };
      const cleanup4 = async () => { count += 4; };

      await TestUtils.safeCleanup(cleanup1, cleanup2, cleanup3, cleanup4);

      // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ãŒã‚ã£ã¦ã‚‚ã€ä»–ã¯å®Ÿè¡Œã•ã‚Œã‚‹
      expect(count).toBe(7); // 1 + 2 + 4
    });
  });

  describe('generateRandomPort', () => {
    test('æŒ‡å®šç¯„å›²å†…ã®ãƒ©ãƒ³ãƒ€ãƒ ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã™ã‚‹', () => {
      const port = TestUtils.generateRandomPort(8000, 8100);
      expect(port).toBeGreaterThanOrEqual(8000);
      expect(port).toBeLessThanOrEqual(8100);
    });

    test('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç¯„å›²ã§ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã™ã‚‹', () => {
      const port = TestUtils.generateRandomPort();
      expect(port).toBeGreaterThanOrEqual(8000);
      expect(port).toBeLessThanOrEqual(9999);
    });
  });
});

describe('TestUtilsçµ±åˆãƒ†ã‚¹ãƒˆ', () => {
  test('è¤‡æ•°ã®ãƒ†ã‚¹ãƒˆãŒç‹¬ç«‹ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹', async () => {
    // æœ€åˆã®ãƒ†ã‚¹ãƒˆç’°å¢ƒ
    const testEnv1 = await TestUtils.setupTest();
    await testEnv1.page.evaluate(() => {
      window.testId = 'test1';
      window.uniqueValue = Math.random();
    });
    const test1Value = await testEnv1.page.evaluate(() => window.uniqueValue);

    // 2ç•ªç›®ã®ãƒ†ã‚¹ãƒˆç’°å¢ƒï¼ˆç‹¬ç«‹ï¼‰
    const testEnv2 = await TestUtils.setupTest();
    await testEnv2.page.evaluate(() => {
      window.testId = 'test2';
      window.uniqueValue = Math.random();
    });
    const test2Value = await testEnv2.page.evaluate(() => window.uniqueValue);

    // ä¸¡æ–¹ã®ãƒ†ã‚¹ãƒˆç’°å¢ƒãŒç‹¬ç«‹ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
    expect(test1Value).not.toBe(test2Value);

    const test1Id = await testEnv1.page.evaluate(() => window.testId);
    const test2Id = await testEnv2.page.evaluate(() => window.testId);

    expect(test1Id).toBe('test1');
    expect(test2Id).toBe('test2');

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await TestUtils.cleanupTest(testEnv1);
    await TestUtils.cleanupTest(testEnv2);
  }, 60000);
});
</file>

<file path="three-test-suite/__tests__/unit/ThreeTestSuite.test.js">
/**
 * ThreeTestSuite ã®ãƒ†ã‚¹ãƒˆ
 * Issue #18 Phase1ã§è¿½åŠ ã•ã‚ŒãŸThreeTestSuiteã‚¯ãƒ©ã‚¹ã®å˜ä½“ãƒ†ã‚¹ãƒˆ
 */
import { ThreeTestSuite } from '../../src/threejs/ThreeTestSuite.js';
import { BrowserManager } from '../../src/BrowserManager.js';

describe('ThreeTestSuite', () => {
  let browserManager;
  let threeTestSuite;

  beforeEach(async () => {
    browserManager = new BrowserManager({
      headless: true,
      timeout: 10000
    });
    await browserManager.initialize();
    threeTestSuite = new ThreeTestSuite(browserManager);
  });

  afterEach(async () => {
    if (browserManager && browserManager.isInitialized()) {
      await browserManager.cleanup();
    }
  });

  describe('Constructor', () => {
    it('should create ThreeTestSuite instance with BrowserManager', () => {
      expect(threeTestSuite).toBeInstanceOf(ThreeTestSuite);
      expect(threeTestSuite.browserManager).toBe(browserManager);
    });

    it('should throw error when BrowserManager is not provided', () => {
      expect(() => {
        new ThreeTestSuite();
      }).toThrow('BrowserManager instance is required');
    });

    it('should throw error when null BrowserManager is provided', () => {
      expect(() => {
        new ThreeTestSuite(null);
      }).toThrow('BrowserManager instance is required');
    });
  });

  describe('Initialization', () => {
    it('should initialize without errors', async () => {
      await expect(threeTestSuite.initialize()).resolves.not.toThrow();
    });
  });

  describe('SceneInspector Management', () => {
    it('should return null for SceneInspector initially', () => {
      const inspector = threeTestSuite.getSceneInspector();
      expect(inspector).toBeNull();
    });
  });

  describe('Three.js Scene Loading', () => {
    it('should throw error when BrowserManager is not initialized', async () => {
      const uninitializedBrowserManager = new BrowserManager();
      const uninitializedSuite = new ThreeTestSuite(uninitializedBrowserManager);
      
      const sceneFunction = () => {
        const scene = new THREE.Scene();
        window.scene = scene;
      };

      await expect(
        uninitializedSuite.loadThreeScene(sceneFunction)
      ).rejects.toThrow('BrowserManager is not initialized');
    });

    it('should throw error when sceneBuilderFunction is not a function', async () => {
      await expect(
        threeTestSuite.loadThreeScene('not a function')
      ).rejects.toThrow('sceneBuilderFunction must be a function');
    });

    it('should throw error when sceneBuilderFunction is null', async () => {
      await expect(
        threeTestSuite.loadThreeScene(null)
      ).rejects.toThrow('sceneBuilderFunction must be a function');
    });

    it('should load Three.js scene successfully', async () => {
      const sceneFunction = () => {
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        
        window.scene = scene;
        window.camera = camera;
        window.renderer = renderer;
      };

      await expect(
        threeTestSuite.loadThreeScene(sceneFunction, { timeout: 15000 })
      ).resolves.not.toThrow();
    }, 20000);

    it('should handle custom timeout option', async () => {
      const sceneFunction = () => {
        const scene = new THREE.Scene();
        window.scene = scene;
      };

      await expect(
        threeTestSuite.loadThreeScene(sceneFunction, { timeout: 5000 })
      ).resolves.not.toThrow();
    }, 10000);
  });

  describe('HTML Generation', () => {
    it('should generate valid HTML with default options', () => {
      const html = threeTestSuite._generateThreeJsHTML();
      
      expect(html).toContain('<!DOCTYPE html>');
      expect(html).toContain('<title>Three.js Test Scene</title>');
      expect(html).toContain('<script type="importmap">');
      expect(html).toContain('"three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.173.0/three.module.min.js"');
      expect(html).toContain('<script type="module">');
      expect(html).toContain('window.THREE = THREE;');
      expect(html).toContain('window.threeJsLoaded = true;');
    });

    it('should generate HTML with custom options', () => {
      const options = {
        title: 'Custom Test Scene',
        threeJsVersion: '0.173.0' // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’0.173.0ã«
      };
      
      const html = threeTestSuite._generateThreeJsHTML(options);
      
      expect(html).toContain('<title>Custom Test Scene</title>');
      expect(html).toContain('<script type="importmap">');
      expect(html).toContain('"three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.173.0/three.module.min.js"');
      expect(html).toContain('<script type="module">');
    });
  });

  describe('Future Features (Placeholders)', () => {
    it('should return placeholder for runComprehensiveTest', async () => {
      const result = await threeTestSuite.runComprehensiveTest();
      
      expect(result).toMatchObject({
        success: true,
        message: expect.stringContaining('Phase2 feature')
      });
      expect(result.timestamp).toBeDefined();
    });

    it('should return empty array for getVisibleObjects', async () => {
      const objects = await threeTestSuite.getVisibleObjects();
      expect(objects).toEqual([]);
    });

    it('should return placeholder for validateRendering', async () => {
      const result = await threeTestSuite.validateRendering();
      
      expect(result).toMatchObject({
        success: true,
        message: expect.stringContaining('Phase3 feature')
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle scene execution errors gracefully', async () => {
      const errorFunction = () => {
        throw new Error('Test scene error');
      };

      await expect(
        threeTestSuite.loadThreeScene(errorFunction, { timeout: 5000 })
      ).rejects.toThrow();
    }, 10000);

    it('should timeout properly when Three.js loading takes too long', async () => {
      const sceneFunction = () => {
        const scene = new THREE.Scene();
        window.scene = scene;
      };

      // éå¸¸ã«çŸ­ã„ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šã—ã¦ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ãƒ†ã‚¹ãƒˆ
      await expect(
        threeTestSuite.loadThreeScene(sceneFunction, { timeout: 1 })
      ).rejects.toThrow(/timeout/);
    }, 10000);
  });
});
</file>

<file path="three-test-suite/src/threejs/SceneInspector.js">
/**
 * SceneInspector
 * Three.jsã‚·ãƒ¼ãƒ³ã®æ¤œæŸ»ãƒ»è§£ææ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ã‚¯ãƒ©ã‚¹
 * Issue #18 Phase1ã§å®Ÿè£…ã•ã‚Œã‚‹ã‚·ãƒ¼ãƒ³æ¤œæŸ»æ©Ÿèƒ½
 */
export class SceneInspector {
  constructor(browserManager) {
    if (!browserManager) {
      throw new Error('BrowserManager instance is required');
    }
    this.browserManager = browserManager;
  }

  /**
   * ã‚·ãƒ¼ãƒ³æƒ…å ±ã‚’å–å¾—
   * @returns {Promise<Object>} ã‚·ãƒ¼ãƒ³æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  async getSceneInfo() {
    if (!this.browserManager.isInitialized()) {
      throw new Error('BrowserManager is not initialized');
    }

    try {
      const sceneInfo = await this.browserManager.page.evaluate(() => {
        if (typeof window.scene === 'undefined') {
          return {
            available: false,
            error: 'Scene not found in window.scene'
          };
        }

        const scene = window.scene;
        return {
          available: true,
          children: scene.children.length,
          background: scene.background ? scene.background.toString() : null,
          fog: scene.fog ? {
            type: scene.fog.isFog ? 'Fog' : scene.fog.constructor.name,
            near: scene.fog.near,
            far: scene.fog.far,
            color: scene.fog.color ? scene.fog.color.getHex() : null
          } : null,
          autoUpdate: scene.autoUpdate !== undefined ? scene.autoUpdate : true, // Default to true if undefined
          matrixAutoUpdate: scene.matrixAutoUpdate !== undefined ? scene.matrixAutoUpdate : true, // Default to true if undefined
          uuid: scene.uuid,
          type: scene.isScene ? 'Scene' : scene.constructor.name
        };
      });

      return sceneInfo;
    } catch (error) {
      throw new Error(`Failed to get scene info: ${error.message}`);
    }
  }

  /**
   * ã‚«ãƒ¡ãƒ©æƒ…å ±ã‚’å–å¾—
   * @returns {Promise<Object>} ã‚«ãƒ¡ãƒ©æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  async getCameraInfo() {
    if (!this.browserManager.isInitialized()) {
      throw new Error('BrowserManager is not initialized');
    }

    try {
      const cameraInfo = await this.browserManager.page.evaluate(() => {
        if (typeof window.camera === 'undefined') {
          return {
            available: false,
            error: 'Camera not found in window.camera'
          };
        }

        const camera = window.camera;
        let cameraType = camera.constructor.name;
        if (camera.isPerspectiveCamera) cameraType = 'PerspectiveCamera';
        else if (camera.isOrthographicCamera) cameraType = 'OrthographicCamera';
        
        return {
          available: true,
          type: cameraType,
          position: {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z
          },
          rotation: {
            x: camera.rotation.x,
            y: camera.rotation.y,
            z: camera.rotation.z
          },
          fov: camera.fov || null,
          aspect: camera.aspect || null,
          near: camera.near || null,
          far: camera.far || null,
          zoom: camera.zoom || null,
          uuid: camera.uuid
        };
      });

      return cameraInfo;
    } catch (error) {
      throw new Error(`Failed to get camera info: ${error.message}`);
    }
  }

  /**
   * ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼æƒ…å ±ã‚’å–å¾—
   * @returns {Promise<Object>} ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  async getRendererInfo() {
    if (!this.browserManager.isInitialized()) {
      throw new Error('BrowserManager is not initialized');
    }

    try {
      const rendererInfo = await this.browserManager.page.evaluate(() => {
        if (typeof window.renderer === 'undefined') {
          return {
            available: false,
            error: 'Renderer not found in window.renderer'
          };
        }

        const renderer = window.renderer;
        const canvas = renderer.domElement;
        
        return {
          available: true,
          type: renderer.isWebGLRenderer ? 'WebGLRenderer' : renderer.constructor.name,
          size: {
            width: canvas.width,
            height: canvas.height
          },
          pixelRatio: renderer.getPixelRatio(),
          antialias: renderer.capabilities ? renderer.capabilities.antialias : null,
          powerPreference: renderer.capabilities ? renderer.capabilities.powerPreference : null,
          precision: renderer.capabilities ? renderer.capabilities.precision : null,
          maxAnisotropy: renderer.capabilities ? renderer.capabilities.getMaxAnisotropy() : null,
          shadowMap: {
            enabled: renderer.shadowMap.enabled,
            type: renderer.shadowMap.type
          },
          autoClear: renderer.autoClear,
          sortObjects: renderer.sortObjects
        };
      });

      return rendererInfo;
    } catch (error) {
      throw new Error(`Failed to get renderer info: ${error.message}`);
    }
  }

  /**
   * ã‚·ãƒ¼ãƒ³å…¨ä½“ã®ç·åˆæƒ…å ±ã‚’å–å¾—
   * @returns {Promise<Object>} ç·åˆæƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  async getComprehensiveInfo() {
    try {
      const [sceneInfo, cameraInfo, rendererInfo] = await Promise.all([
        this.getSceneInfo(),
        this.getCameraInfo(), 
        this.getRendererInfo()
      ]);

      return {
        timestamp: new Date().toISOString(),
        scene: sceneInfo,
        camera: cameraInfo,
        renderer: rendererInfo,
        status: {
          sceneReady: sceneInfo.available,
          cameraReady: cameraInfo.available,
          rendererReady: rendererInfo.available,
          allReady: sceneInfo.available && cameraInfo.available && rendererInfo.available
        }
      };
    } catch (error) {
      throw new Error(`Failed to get comprehensive info: ${error.message}`);
    }
  }

  /**
   * ã‚·ãƒ¼ãƒ³å†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°ã‚’å–å¾—
   * @returns {Promise<number>} ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°
   */
  async getObjectCount() {
    try {
      const sceneInfo = await this.getSceneInfo();
      return sceneInfo.available ? sceneInfo.children : 0;
    } catch (error) {
      throw new Error(`Failed to get object count: ${error.message}`);
    }
  }

  /**
   * Three.jsã®ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã‚’ç¢ºèª
   * @returns {Promise<Object>} Three.jsã®çŠ¶æ…‹æƒ…å ±
   */
  async getThreeJsStatus() {
    if (!this.browserManager.isInitialized()) {
      throw new Error('BrowserManager is not initialized');
    }

    try {
      const status = await this.browserManager.page.evaluate(() => {
        return {
          threeLoaded: typeof THREE !== 'undefined',
          version: typeof THREE !== 'undefined' && THREE.REVISION ? THREE.REVISION : null,
          webglAvailable: typeof THREE !== 'undefined' && THREE.WebGL ? THREE.WebGL.isWebGLAvailable() : false,
          webgl2Available: typeof THREE !== 'undefined' && THREE.WebGL ? THREE.WebGL.isWebGL2Available() : false,
          sceneReady: window.sceneReady || false,
          sceneError: window.sceneError || null,
          threeJsLoaded: window.threeJsLoaded || false,
          threeJsLoadError: window.threeJsLoadError || null
        };
      });

      return status;
    } catch (error) {
      throw new Error(`Failed to get Three.js status: ${error.message}`);
    }
  }
}
</file>

<file path="three-test-suite/src/utils/TestUtils.js">
import { BrowserManager } from '../BrowserManager.js';

/**
 * ãƒ†ã‚¹ãƒˆç”¨ã®å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹
 * ãƒ†ã‚¹ãƒˆé–“ã®ç‹¬ç«‹æ€§ã‚’ç¢ºä¿ã—ã€ä¸€è²«ã—ãŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ»ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’æä¾›
 */
export class TestUtils {
  /**
   * ãƒ†ã‚¹ãƒˆé–“ã§ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
   * @param {Object} page - Puppeteerã®pageã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  static async resetGlobalState(page) {
    if (!page) {
      throw new Error('Page object is required for resetting global state');
    }

    try {
      await page.evaluate(() => {
        // window ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ ãƒ†ã‚¹ãƒˆç”¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤
        const testProperties = [
          'cubeRendered', 'sceneReady', 'setupComplete', 'animationComplete',
          'finalRotation', 'webglSupported', 'webglError', 'threeLoaded',
          'threeVersion', 'debugInfo', 'testResults', 'sceneInfo',
          'animationResult', 'shaderTest', 'modelLoaded', 'performanceResults',
          'heavyProcessComplete', 'webglInfo', 'customSceneLoaded',
          'legacyTestComplete', 'sceneObjects', 'sceneAnalysis',
          'userScript', 'scene', 'camera', 'renderer', 'testProperty',
          'testCondition', 'testComplete', 'integrationTestComplete',
          'multiComponentTest', 'testScene', 'sceneBuilt'
        ];

        testProperties.forEach(prop => {
          if (window.hasOwnProperty(prop)) {
            delete window[prop];
          }
        });

        // ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚¯ãƒªã‚¢
        if (window.removeEventListener) {
          // ä¸€èˆ¬çš„ãªãƒ†ã‚¹ãƒˆç”¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‰Šé™¤
          ['load', 'DOMContentLoaded', 'resize', 'beforeunload'].forEach(eventType => {
            try {
              // ã™ã¹ã¦ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å®Œå…¨ã«å‰Šé™¤ã™ã‚‹ã®ã¯å›°é›£ãªãŸã‚ã€
              // æ–°ã—ã„ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰ã§å¯¾å‡¦ã™ã‚‹æ–¹é‡
            } catch (e) {
              // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼å‰Šé™¤ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ç¶šè¡Œ
            }
          });
        }

        // å‹•çš„ã«è¿½åŠ ã•ã‚ŒãŸDOMã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã‚’ã‚¯ãƒªã‚¢
        const dynamicElements = document.querySelectorAll('[data-test-element]');
        dynamicElements.forEach(element => element.remove());

        // Canvasã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        const canvases = document.querySelectorAll('canvas');
        canvases.forEach(canvas => {
          const context = canvas.getContext('2d') || canvas.getContext('webgl') || canvas.getContext('webgl2');
          if (context && context.clear) {
            try {
              context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
            } catch (e) {
              // WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¯ãƒªã‚¢ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ç¶šè¡Œ
            }
          }
        });

        // Three.jsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚’ã‚¯ãƒªã‚¢
        if (window.THREE) {
          // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªThree.jsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚’ã‚¯ãƒªã‚¢
          ['scene', 'camera', 'renderer', 'controls'].forEach(prop => {
            if (window[prop]) {
              try {
                if (typeof window[prop].dispose === 'function') {
                  window[prop].dispose();
                }
                delete window[prop];
              } catch (e) {
                // disposeå¤±æ•—æ™‚ã‚‚ç¶šè¡Œ
                delete window[prop];
              }
            }
          });
        }
      });
    } catch (error) {
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ã€ãƒ†ã‚¹ãƒˆã‚’ç¶šè¡Œã™ã‚‹
      console.warn('Global state reset failed:', error.message);
    }
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç‹¬ç«‹ã—ã¦ä½œæˆã—ã€é©åˆ‡ã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹
   * @param {Object} options - BrowserManagerã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @returns {BrowserManager} è¨­å®šæ¸ˆã¿ã®BrowserManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
   */
  static async createIsolatedBrowserInstance(options = {}) {
    const defaultOptions = {
      headless: true,
      width: 1024,
      height: 768,
      args: [
        '--enable-webgl',
        '--disable-web-security',
        '--disable-dev-shm-usage',
        '--no-sandbox',
        // å„ãƒ†ã‚¹ãƒˆã§ç‹¬ç«‹ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ç”¨
        '--disable-extensions-except',
        '--disable-extensions',
        // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã‚’æŠ‘åˆ¶
        '--memory-pressure-off',
        '--max_old_space_size=4096'
      ]
    };

    const mergedOptions = { ...defaultOptions, ...options };
    const browserManager = new BrowserManager(mergedOptions);
    
    await browserManager.initialize();
    
    // åˆæœŸçŠ¶æ…‹ã§ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
    await TestUtils.resetGlobalState(browserManager.page);
    
    return browserManager;
  }

  /**
   * éåŒæœŸå‡¦ç†ã‚’å®‰å…¨ã«å¾…æ©Ÿã—ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ»ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ã‚’æä¾›
   * @param {Function} condition - å¾…æ©Ÿã™ã‚‹æ¡ä»¶ã‚’è¿”ã™é–¢æ•°
   * @param {Object} options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¨­å®š
   * @returns {Promise} æ¡ä»¶ãŒæº€ãŸã•ã‚ŒãŸæ™‚ç‚¹ã§è§£æ±º
   */
  static async waitForCondition(page, condition, options = {}) {
    const {
      timeout = 10000,
      interval = 100,
      retries = 3,
      errorMessage = 'Condition not met within timeout'
    } = options;

    let attempt = 0;
    
    while (attempt < retries) {
      try {
        await page.waitForFunction(condition, { 
          timeout: timeout / retries,
          polling: interval 
        });
        return; // æˆåŠŸæ™‚ã¯å³åº§ã«è¿”ã‚‹
      } catch (error) {
        attempt++;
        if (attempt >= retries) {
          throw new Error(`${errorMessage} (after ${retries} attempts): ${error.message}`);
        }
        
        // ãƒªãƒˆãƒ©ã‚¤å‰ã«çŸ­æ™‚é–“å¾…æ©Ÿ
        await new Promise(resolve => setTimeout(resolve, interval));
      }
    }
  }

  /**
   * çµ±ä¸€çš„ãªãƒ†ã‚¹ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ˜ãƒ«ãƒ‘ãƒ¼
   * beforeEach ã§ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æƒ³å®š
   * @param {Object} options - ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @returns {Object} ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã•ã‚ŒãŸãƒ†ã‚¹ãƒˆç’°å¢ƒ
   */
  static async setupTest(options = {}) {
    const {
      browserOptions = {},
      resetGlobalState = true,
      timeout = 30000
    } = options;

    try {
      const browserManager = await TestUtils.createIsolatedBrowserInstance(browserOptions);
      
      if (resetGlobalState) {
        await TestUtils.resetGlobalState(browserManager.page);
      }

      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®š
      if (browserManager.page.setDefaultTimeout) {
        await browserManager.page.setDefaultTimeout(timeout);
      }

      return {
        browserManager,
        page: browserManager.page,
        browser: browserManager.browser
      };
    } catch (error) {
      throw new Error(`Test setup failed: ${error.message}`);
    }
  }

  /**
   * çµ±ä¸€çš„ãªãƒ†ã‚¹ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ãƒ˜ãƒ«ãƒ‘ãƒ¼
   * afterEach ã§ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æƒ³å®š
   * @param {Object} testEnvironment - setupTestã§ä½œæˆã•ã‚ŒãŸç’°å¢ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  static async cleanupTest(testEnvironment) {
    if (!testEnvironment) {
      return; // ä½•ã‚‚ã—ãªã„
    }

    const { browserManager, page } = testEnvironment;

    try {
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      if (page && !page.isClosed()) {
        await TestUtils.resetGlobalState(page);
      }
    } catch (error) {
      console.warn('Global state cleanup failed:', error.message);
    }

    try {
      // ãƒ–ãƒ©ã‚¦ã‚¶ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      if (browserManager && browserManager.isInitialized()) {
        await browserManager.cleanup();
      }
    } catch (error) {
      console.warn('Browser cleanup failed:', error.message);
    }

    // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ã‚¯ãƒªã‚¢
    if (testEnvironment.page) {
      testEnvironment.page = null;
    }
    if (testEnvironment.browser) {
      testEnvironment.browser = null;
    }
    if (testEnvironment.browserManager) {
      testEnvironment.browserManager = null;
    }
  }

  /**
   * ã‚¨ãƒ©ãƒ¼è€æ€§ã®ã‚ã‚‹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†
   * è¤‡æ•°ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’é †ç•ªã«å®Ÿè¡Œã—ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ç¶šè¡Œ
   * @param {Array<Function>} cleanupFunctions - ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°ã®é…åˆ—
   */
  static async safeCleanup(...cleanupFunctions) {
    const errors = [];

    for (const cleanupFn of cleanupFunctions) {
      try {
        if (typeof cleanupFn === 'function') {
          await cleanupFn();
        }
      } catch (error) {
        errors.push(error);
        console.warn('Cleanup function failed:', error.message);
      }
    }

    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸãŒã€ã™ã¹ã¦ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’è©¦è¡Œã—ãŸ
    if (errors.length > 0) {
      console.warn(`${errors.length} cleanup errors occurred, but all cleanup attempts were made`);
    }
  }

  /**
   * ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ©ãƒ³ãƒ€ãƒ ãƒãƒ¼ãƒˆç”Ÿæˆ
   * è¤‡æ•°ã®ãƒ†ã‚¹ãƒˆãŒåŒæ™‚å®Ÿè¡Œã•ã‚Œã‚‹éš›ã®ãƒãƒ¼ãƒˆç«¶åˆã‚’å›é¿
   * @param {number} min - æœ€å°ãƒãƒ¼ãƒˆç•ªå·
   * @param {number} max - æœ€å¤§ãƒãƒ¼ãƒˆç•ªå·
   * @returns {number} ãƒ©ãƒ³ãƒ€ãƒ ãªãƒãƒ¼ãƒˆç•ªå·
   */
  static generateRandomPort(min = 8000, max = 9999) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  /**
   * Three.jså›ºæœ‰ã®ãƒ†ã‚¹ãƒˆå‰æº–å‚™
   * Three.jsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ­£å¸¸æ€§ã‚’ç¢ºèª
   * @param {Object} page - Puppeteerãƒšãƒ¼ã‚¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   */
  static async ensureThreeJsReady(page) {
    try {
      await TestUtils.waitForCondition(
        page,
        'typeof THREE !== "undefined" && THREE.Scene && THREE.WebGLRenderer',
        {
          timeout: 15000,
          interval: 200,
          retries: 3,
          errorMessage: 'Three.js failed to load properly'
        }
      );

      // Three.jsã®åŸºæœ¬ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
      const threeJsReady = await page.evaluate(() => {
        return typeof THREE !== 'undefined' &&
               typeof THREE.Scene === 'function' &&
               typeof THREE.WebGLRenderer === 'function' &&
               typeof THREE.PerspectiveCamera === 'function';
      });

      if (!threeJsReady) {
        throw new Error('Three.js core objects are not available');
      }
    } catch (error) {
      throw new Error(`Three.js readiness check failed: ${error.message}`);
    }
  }
}

/**
 * ã‚ˆãä½¿ç”¨ã•ã‚Œã‚‹ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ç¾¤
 */
export class TestPatterns {
  /**
   * æ¨™æº–çš„ãªBrowserManagerãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³
   * @param {Function} testFunction - å®Ÿéš›ã®ãƒ†ã‚¹ãƒˆé–¢æ•°
   * @param {Object} options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³
   */
  static async withBrowserManager(testFunction, options = {}) {
    const testEnv = await TestUtils.setupTest(options);
    
    try {
      await testFunction(testEnv.browserManager, testEnv.page);
    } finally {
      await TestUtils.cleanupTest(testEnv);
    }
  }

  /**
   * Three.jsã‚·ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³
   * @param {Function} sceneBuilder - Three.jsã‚·ãƒ¼ãƒ³ã‚’æ§‹ç¯‰ã™ã‚‹é–¢æ•°
   * @param {Function} testFunction - ãƒ†ã‚¹ãƒˆé–¢æ•°
   * @param {Object} options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³
   */
  static async withThreeJsScene(sceneBuilder, testFunction, options = {}) {
    const testEnv = await TestUtils.setupTest(options);
    
    try {
      // HTMLGeneratorã‚’ä½¿ç”¨ã—ã¦Three.jsç’°å¢ƒã‚’æ§‹ç¯‰
      const { HTMLGenerator } = await import('../HTMLGenerator.js');
      const htmlGenerator = new HTMLGenerator();
      
      const html = htmlGenerator.generateTestHTML(sceneBuilder);
      await testEnv.page.setContent(html);
      
      // Three.jsã®æº–å‚™ã‚’ç¢ºèª
      await TestUtils.ensureThreeJsReady(testEnv.page);
      
      // ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
      await testFunction(testEnv.browserManager, testEnv.page);
    } finally {
      await TestUtils.cleanupTest(testEnv);
    }
  }
}
</file>

<file path="three-test-suite/src/BrowserManager.js">
import puppeteer from 'puppeteer';

/**
 * BrowserManager
 * Puppeteerãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
 */
export class BrowserManager {
  /**
   * @param {Object} options - è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @param {boolean} options.headless - ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: true)
   * @param {number} options.width - ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¹… (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 1024)
   * @param {number} options.height - ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆé«˜ã• (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 768)
   * @param {string[]} options.args - Chromiumèµ·å‹•å¼•æ•°
   */
  constructor(options = {}) {
    this.options = {
      headless: true,
      width: 1024,
      height: 768,
      args: [
        '--enable-webgl',
        '--disable-web-security',
        '--allow-running-insecure-content',
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage'
      ],
      ...options
    };
    
    this.browser = null;
    this.page = null;
  }

  /**
   * Puppeteerãƒ–ãƒ©ã‚¦ã‚¶ã‚’åˆæœŸåŒ–ã™ã‚‹
   * @throws {Error} åˆæœŸåŒ–ã«å¤±æ•—ã—ãŸå ´åˆ
   */
  async initialize() {
    // æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (this.browser) {
      return;
    }

    try {
      this.browser = await puppeteer.launch({
        headless: this.options.headless,
        args: this.options.args
      });

      this.page = await this.browser.newPage();

      // Forward browser console logs to Node console
      this.page.on('console', msg => {
        const type = msg.type();
        const text = msg.text();
        // Jestã®ãƒ†ã‚¹ãƒˆå‡ºåŠ›ã¨åŒºåˆ¥ã—ã‚„ã™ãã™ã‚‹ãŸã‚ã«ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’ä»˜ã‘ã‚‹
        // ã¾ãŸã€ã‚¨ãƒ©ãƒ¼ã‚„è­¦å‘Šã¯é©åˆ‡ã« Node ã® console.error/warn ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹
        if (type === 'error') {
          console.error(`PAGE LOG (Error): ${text}`);
        } else if (type === 'warning') {
          console.warn(`PAGE LOG (Warning): ${text}`);
        } else {
          console.log(`PAGE LOG (${type}): ${text}`);
        }
      });
      
      await this.page.setViewport({
        width: this.options.width,
        height: this.options.height
      });

    } catch (error) {
      throw new Error(`BrowserManager initialization failed: ${error.message}`);
    }
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶ã‚’çµ‚äº†ã—ã€ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹
   */
  async cleanup() {
    if (!this.browser) {
      return;
    }

    try {
      await this.browser.close();
      this.browser = null;
      this.page = null;
    } catch (error) {
      // ãƒ­ã‚°å‡ºåŠ›ã¯ã›ãšã€é™ã‹ã«å¤±æ•—ã•ã›ã‚‹
      console.warn(`Cleanup warning: ${error.message}`);
    }
  }

  /**
   * ãƒ–ãƒ©ã‚¦ã‚¶ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
   * @returns {boolean} åˆæœŸåŒ–çŠ¶æ…‹
   */
  isInitialized() {
    return this.browser !== null && this.page !== null;
  }

  /**
   * åˆæœŸåŒ–çŠ¶æ…‹ã‚’æ¤œè¨¼ã™ã‚‹
   * @private
   * @throws {Error} åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆ
   */
  _validateInitialized() {
    if (!this.isInitialized()) {
      throw new Error('BrowserManager is not initialized');
    }
  }
}
</file>

<file path="jest.config.js">
// jest.config.js (ãƒ«ãƒ¼ãƒˆ)
const commonEsmTransform = {
  '^.+\\.(ts|tsx)$': ['ts-jest', { useESM: true, tsconfig: { jsx: 'react-jsx' } }],
  // .js/.jsx ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã¯ three-test-suite å´ã§ä¸»ã«æ‰±ã†ãŸã‚ã€ãƒ«ãƒ¼ãƒˆã§ã¯TS/TSXã«é›†ä¸­
};

// ãƒ«ãƒ¼ãƒˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ ESM ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ node_modules ã‹ã‚‰åˆ©ç”¨ã™ã‚‹å ´åˆã«è¨­å®š
const rootTransformIgnorePatterns = [
  'node_modules/(?!(some-esm-pkg-for-root)/)' // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
];

export default {
  displayName: 'root-tests',
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'jsdom',
  testMatch: [
    '<rootDir>/__tests__/**/*.(ts|tsx)', // TypeScriptã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã«é™å®š
    '<rootDir>/src/**/*.(test|spec).(ts|tsx)' // TypeScriptã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã«é™å®š
  ],
  transform: commonEsmTransform,
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@/types/(.*)$': '<rootDir>/src/types/$1',
    '^@/components/(.*)$': '<rootDir>/src/components/$1',
    '^@/utils/(.*)$': '<rootDir>/src/utils/$1',
    '^@/three/(.*)$': '<rootDir>/src/three/$1'
  },
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  extensionsToTreatAsEsm: ['.ts', '.tsx'], // ESMã¨ã—ã¦æ‰±ã†ã®ã¯TS/TSXãƒ•ã‚¡ã‚¤ãƒ«
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'], // js, jsxã‚‚è§£æ±ºã®ãŸã‚æ®‹ã™
  transformIgnorePatterns: rootTransformIgnorePatterns,
  collectCoverageFrom: [
    'src/**/*.(ts|tsx)', // ã‚«ãƒãƒ¬ãƒƒã‚¸ã‚‚TS/TSXãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰
    '!src/index.ts',
    '!**/*.d.ts',
    '!**/node_modules/**'
  ],
  testTimeout: 30000,
};
</file>

<file path="package.json">
{
  "name": "web3d-explorer",
  "version": "0.1.0",
  "description": "3D web visualization library with TDD-driven testing framework for Three.js applications",
  "type": "module",
  "main": "src/index.ts",
  "types": "dist/index.d.ts",
  "files": [
    "dist",
    "src"
  ],
  "scripts": {
    "test": "npm run test:root",
    "test:root": "jest --config jest.config.js",
    "test:root:watch": "jest --config jest.config.js --watch",
    "test:root:coverage": "jest --config jest.config.js --coverage",
    "test:watch": "npm run test:root:watch",
    "test:coverage": "npm run test:root:coverage",
    "dev": "vite",
    "build": "tsc && vite build",
    "type-check": "tsc --noEmit",
    "lint": "eslint src three-test-suite --ext .js,.jsx,.ts,.tsx",
    "lint:fix": "eslint src three-test-suite --ext .js,.jsx,.ts,.tsx --fix",
    "prepare": "npm run build"
  },
  "keywords": [
    "three.js",
    "3d",
    "visualization",
    "testing",
    "tdd",
    "puppeteer",
    "gis",
    "cesium",
    "typescript",
    "react"
  ],
  "author": "usaganikki",
  "license": "MIT",
  "devDependencies": {
    "@babel/preset-env": "^7.22.0",
    "@babel/preset-typescript": "^7.22.0",
    "@eslint/js": "^9.0.0",
    "@rollup/plugin-typescript": "^12.1.2",
    "@types/jest": "^29.5.0",
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/three": "^0.163.0",
    "@typescript-eslint/eslint-plugin": "^8.33.0",
    "@typescript-eslint/parser": "^8.33.0",
    "eslint": "^9.28.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "^3.0.0",
    "ts-jest": "^29.1.0",
    "typescript": "^5.0.0",
    "vite": "^5.0.0"
  },
  "dependencies": {
    "@react-three/fiber": "^8.16.0",
    "puppeteer": "^22.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "three": "^0.163.0"
  }
}
</file>

<file path="three-test-suite/__tests__/unit/BrowserManager.test.js">
import { BrowserManager } from '../../src/BrowserManager.js';

describe('BrowserManager - åŸºæœ¬æ©Ÿèƒ½', () => {
  test('æ­£å¸¸ã«åˆæœŸåŒ–ã§ãã‚‹', async () => {
    const manager = new BrowserManager();
    await manager.initialize();
    
    expect(manager.browser).toBeDefined();
    expect(manager.page).toBeDefined();
    
    await manager.cleanup();
  });

  test('cleanupå¾Œã¯ãƒ–ãƒ©ã‚¦ã‚¶ãŒçµ‚äº†ã—ã¦ã„ã‚‹', async () => {
    const manager = new BrowserManager();
    await manager.initialize();
    
    expect(manager.browser).toBeDefined();
    expect(manager.isInitialized()).toBe(true);
    
    await manager.cleanup();
    
    expect(manager.browser).toBeNull();
    expect(manager.page).toBeNull();
    expect(manager.isInitialized()).toBe(false);
  });

  test('ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®šã§ãã‚‹', async () => {
    // CIç’°å¢ƒã§ã¯ headless: true, ãã‚Œä»¥å¤–ã§ã¯ headless: false ã‚’ä½¿ç”¨
    const isCI = process.env.CI === 'true' || process.env.GITHUB_ACTIONS === 'true';
    const manager = new BrowserManager({ headless: isCI ? true : false });
    await manager.initialize();
    
    expect(manager.options.headless).toBe(isCI ? true : false);
    
    await manager.cleanup();
  });

  test('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒæ­£ã—ãè¨­å®šã•ã‚Œã‚‹', () => {
    const manager = new BrowserManager();
    
    expect(manager.options.headless).toBe(true);
    expect(manager.options.width).toBe(1024);
    expect(manager.options.height).toBe(768);
    expect(manager.options.args).toContain('--enable-webgl');
    expect(manager.options.args).toContain('--disable-web-security');
  });

  test('äºŒé‡åˆæœŸåŒ–ã‚’é˜²ã', async () => {
    const manager = new BrowserManager();
    await manager.initialize();
    await manager.initialize(); // äºŒå›ç›®ã®åˆæœŸåŒ–

    expect(manager.browser).toBeDefined();
    await manager.cleanup();
  });

  test('åˆæœŸåŒ–å‰ã®cleanupã¯ä½•ã‚‚ã—ãªã„', async () => {
    const manager = new BrowserManager();
    await expect(manager.cleanup()).resolves.not.toThrow();
  });
});
</file>

<file path="three-test-suite/src/threejs/ThreeTestSuite.js">
/**
 * ThreeTestSuite
 * Three.jsãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ã‚’çµ±æ‹¬ã™ã‚‹ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹
 * PuppeteerManagerã‹ã‚‰åˆ†é›¢ã•ã‚ŒãŸThree.jså°‚ç”¨ã®æ©Ÿèƒ½ã‚’æä¾›
 */
export class ThreeTestSuite {
  constructor(browserManager) {
    if (!browserManager) {
      throw new Error('BrowserManager instance is required');
    }
    this.browserManager = browserManager;
    this.sceneInspector = null;
  }

  /**
   * ThreeTestSuiteã®åˆæœŸåŒ–
   * å„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®åˆæœŸåŒ–ã‚’è¡Œã†
   */
  async initialize() {
    // å¿…è¦ã«å¿œã˜ã¦å°†æ¥çš„ã«SceneInspectorãªã©ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’åˆæœŸåŒ–
    // ç¾åœ¨ã¯ä½•ã‚‚ã—ãªã„ãŒã€æ‹¡å¼µæ™‚ã«ã“ã“ã§åˆæœŸåŒ–å‡¦ç†ã‚’è¿½åŠ 
  }

  /**
   * SceneInspectorã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—
   * é…å»¶åˆæœŸåŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨
   */
  getSceneInspector() {
    if (!this.sceneInspector) {
      // å‹•çš„importã‚’ä½¿ç”¨ã—ã¦SceneInspectorã‚’ãƒ­ãƒ¼ãƒ‰
      // ç¾åœ¨ã¯nullã‚’è¿”ã™ãŒã€å®Ÿè£…æ™‚ã«é©åˆ‡ã«åˆæœŸåŒ–
      this.sceneInspector = null; // TODO: SceneInspectorã®å®Ÿè£…å¾Œã«åˆæœŸåŒ–
    }
    return this.sceneInspector;
  }

  /**
   * Three.jsã‚·ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã€æŒ‡å®šã•ã‚ŒãŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—é–¢æ•°ã‚’å®Ÿè¡Œã™ã‚‹
   * PuppeteerManagerã‹ã‚‰ç§»è¡Œã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰
   * @param {Function} sceneBuilderFunction - Three.jsã®ã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹é–¢æ•°
   * @param {Object} options - ãƒ­ãƒ¼ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ (title, threeJsVersion, timeoutãªã©)
   * @returns {Promise<void>}
   */
  async loadThreeScene(sceneBuilderFunction, options = {}) {
    if (!this.browserManager.isInitialized()) {
      throw new Error('BrowserManager is not initialized');
    }
    if (typeof sceneBuilderFunction !== 'function') {
      throw new Error('sceneBuilderFunction must be a function');
    }

    const defaultTimeout = 30000;
    const loadTimeout = options.timeout || defaultTimeout;

    try {
      // HTMLGeneratorã‚’ä½¿ç”¨ã—ã¦HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”Ÿæˆ
      const htmlContent = this._generateThreeJsHTML(options);

      await this.browserManager.page.setContent(htmlContent, {
        waitUntil: 'networkidle0', 
        timeout: loadTimeout,
      });

      await this._waitForThreeJsLoad(loadTimeout);

      const executionResult = await this._executeSceneBuilder(sceneBuilderFunction);
      
      if (!executionResult.success) {
        const error = new Error(executionResult.error.message);
        if (executionResult.error.stack) {
          error.stack = executionResult.error.stack;
        }
        throw error;
      }

    } catch (error) {
      if (error.message && error.message.includes('timeout')) {
        throw new Error(`Three.js scene loading timed out after ${loadTimeout}ms: ${error.message}`);
      }
      throw error;
    }
  }

  /**
   * Three.jsç”¨ã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”Ÿæˆ
   * @param {Object} options - ç”Ÿæˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @returns {string} HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
   */
  _generateThreeJsHTML(options = {}) {
    const threeJsVersion = options.threeJsVersion || '0.173.0'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’0.173.0ã«
    const title = options.title || 'Three.js Test Scene';
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/${threeJsVersion}/three.module.min.js"
        }
    }
    </script>
    <script type="module">
        window.threeJsLoadError = null;
        window.sceneReady = false;
        window.sceneError = null;
        try {
            const THREE = await import('three');
            window.THREE = THREE; // Make THREE globally available for sceneBuilderFunction
            window.threeJsLoaded = true;
            // Notify that Three.js is loaded, e.g., by a custom event or a flag
            // document.dispatchEvent(new CustomEvent('threejsloaded'));
        } catch (e) {
            window.threeJsLoadError = 'Failed to load Three.js module from CDN: ' + e.message;
            console.error(window.threeJsLoadError);
        }
    </script>
</body>
</html>`;
  }

  /**
   * Three.jsã®èª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…æ©Ÿ
   * @param {number} timeout - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
   */
  async _waitForThreeJsLoad(timeout) {
    try {
      await this.browserManager.page.waitForFunction(
        () => {
          if (window.threeJsLoadError) {
            throw new Error('Three.js CDN load failed: ' + window.threeJsLoadError);
          }
          // Check if THREE is globally available and core components are present
          return typeof window.THREE !== 'undefined' &&
                 typeof window.THREE.Scene === 'function' &&
                 typeof window.THREE.PerspectiveCamera === 'function' && // Or other core components
                 typeof window.THREE.WebGLRenderer === 'function' &&
                 window.threeJsLoaded === true;
        },
        {
          timeout: timeout,
          polling: 'raf'
        }
      );
    } catch (error) {
      const loadError = await this.browserManager.page.evaluate(() => window.threeJsLoadError);
      const threeAvailable = await this.browserManager.page.evaluate(() => typeof THREE !== 'undefined');
      
      if (loadError) {
        throw new Error('Three.js failed to load from CDN');
      } else if (!threeAvailable) {
        throw new Error(`Three.js did not load within ${timeout}ms`);
      } else if (error.message.includes('timeout')) {
        throw new Error(`Three.js loading timed out after ${timeout}ms`);
      }
      throw new Error(`Three.js loading error: ${error.message}`);
    }
  }

  /**
   * ã‚·ãƒ¼ãƒ³ãƒ“ãƒ«ãƒ€ãƒ¼é–¢æ•°ã‚’å®Ÿè¡Œ
   * @param {Function} sceneBuilderFunction - å®Ÿè¡Œã™ã‚‹é–¢æ•°
   * @returns {Promise<Object>} å®Ÿè¡Œçµæœ
   */
  async _executeSceneBuilder(sceneBuilderFunction) {
    try {
      return await this.browserManager.page.evaluate((builderFuncString) => {
        try {
          // Use window.THREE as it's assigned in _generateThreeJsHTML
          if (typeof window.THREE === 'undefined' || typeof window.THREE.Scene !== 'function') {
            const error = {
              message: 'THREE or THREE.Scene not available in execution context',
              code: 'THREE_NOT_AVAILABLE'
            };
            window.sceneError = error;
            return { success: false, error };
          }

          // Pass window.THREE to the user function
          const userFunction = new Function('THREE', `return (${builderFuncString})`)(window.THREE);
          userFunction(); 
          
          window.sceneReady = true; 
          return { success: true }; 
          
        } catch (error) {
          const errorInfo = {
            message: error.message,
            stack: error.stack,
            code: 'SCENE_EXECUTION_ERROR'
          };
          window.sceneError = errorInfo;
          console.error('Error in sceneBuilderFunction:', error);
          return { success: false, error: errorInfo };
        }
      }, sceneBuilderFunction.toString()); 

    } catch (error) {
      return {
        success: false,
        error: {
          message: `Scene execution failed: ${error.message}`,
          stack: error.stack,
          code: 'PAGE_EVALUATE_ERROR'
        }
      };
    }
  }

  /**
   * åŒ…æ‹¬çš„ãªThree.jsãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
   * å°†æ¥çš„ã«SceneInspectorç­‰ã‚’ä½¿ç”¨ã—ãŸç·åˆãƒ†ã‚¹ãƒˆæ©Ÿèƒ½
   * @returns {Promise<Object>} ãƒ†ã‚¹ãƒˆçµæœ
   */
  async runComprehensiveTest() {
    // TODO: Phase2ä»¥é™ã§å®Ÿè£…
    // SceneInspectorã€ObjectAnalyzerç­‰ã‚’ä½¿ç”¨ã—ãŸåŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆ
    return {
      success: true,
      message: 'Comprehensive test not yet implemented - Phase2 feature',
      timestamp: new Date().toISOString()
    };
  }

  /**
   * è¡¨ç¤ºä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—
   * å°†æ¥çš„ã«ObjectAnalyzerã§å®Ÿè£…äºˆå®š
   * @returns {Promise<Array>} è¡¨ç¤ºä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§
   */
  async getVisibleObjects() {
    // TODO: Phase2ä»¥é™ã§ObjectAnalyzerã‚’ä½¿ç”¨ã—ã¦å®Ÿè£…
    return [];
  }

  /**
   * ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ¤œè¨¼ã‚’å®Ÿè¡Œ
   * å°†æ¥çš„ã«RenderingValidatorã§å®Ÿè£…äºˆå®š
   * @returns {Promise<Object>} ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°çµæœ
   */
  async validateRendering() {
    // TODO: Phase3ä»¥é™ã§RenderingValidatorã‚’ä½¿ç”¨ã—ã¦å®Ÿè£…
    return {
      success: true,
      message: 'Rendering validation not yet implemented - Phase3 feature'
    };
  }
}
</file>

<file path="three-test-suite/jest.setup.js">
// Jest setup for three-test-suite
process.on('unhandledRejection', (reason, promise) => {
  console.warn('Unhandled Rejection at:', promise, 'reason:', reason);
});

if (process.env.NODE_ENV === 'test') {
  const originalConsoleLog = console.log;
  const originalConsoleWarn = console.warn;
  
  console.log = (...args) => {
    if (args.some(arg => String(arg).includes('DEBUG'))) {
      originalConsoleLog(...args);
    }
  };
  
  console.warn = (...args) => {
    if (args.some(arg => String(arg).includes('WARNING') || String(arg).includes('Unhandled'))) {
      originalConsoleWarn(...args);
    }
  };
}
</file>

<file path="README.md">
# Web3DExplorer

[![TypeScript](https://img.shields.io/badge/TypeScript-5.0+-blue.svg)](https://www.typescriptlang.org/)
[![Three.js](https://img.shields.io/badge/Three.js-0.163+-green.svg)](https://threejs.org/)
[![React](https://img.shields.io/badge/React-18.2+-blue.svg)](https://reactjs.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

**3D web visualization library with TDD-driven testing framework for Three.js applications. Features Tokyo Station exploration with GIS integration.**

## âš¡ é‡è¦ãªã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ

ğŸ‰ **TypeScriptåŒ–å®Œäº†ï¼** (v0.1.0)  
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯å®Œå…¨ã«TypeScriptåŒ–ã•ã‚Œã€å‹å®‰å…¨ã§ä¿å®ˆæ€§ã®é«˜ã„ç¾ä»£çš„ãª3D Webãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«é€²åŒ–ã—ã¾ã—ãŸã€‚

## âœ¨ ä¸»è¦æ©Ÿèƒ½

- **ğŸ¯ TypeScript First**: å®Œå…¨ãªå‹å®‰å…¨æ€§ã¨åŒ…æ‹¬çš„ãªå‹å®šç¾©
- **âš›ï¸ Reactçµ±åˆ**: React Three Fiberã¨ã®å®Œå…¨çµ±åˆ
- **ğŸ—ºï¸ GISçµ±åˆ**: åœ°ç†æƒ…å ±ã‚·ã‚¹ãƒ†ãƒ ã‚µãƒãƒ¼ãƒˆã¨åº§æ¨™å¤‰æ›
- **ğŸš… Tokyo Station Explorer**: æ±äº¬é§…ã‚¨ãƒªã‚¢ã®å°‚ç”¨3Då¯è¦–åŒ–
- **ğŸ§ª TDDãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: Three.jsç”¨åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
- **ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–**: å†…è”µãƒ¡ãƒˆãƒªã‚¯ã‚¹ã¨æœ€é©åŒ–ãƒ„ãƒ¼ãƒ«
- **ğŸ¨ ã‚¤ãƒ™ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ **: å¼·åŠ›ãªã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
- **âš¡ ç¾ä»£çš„ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«**: Viteã€ESLintã€Jestã€TypeScriptè¨­å®š

## ğŸ¯ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç›®æ¨™ã¨é€²æ—

### âœ… **å®Œäº†æ¸ˆã¿ (Phase 1-4 çµ±åˆå®Ÿè£…)**

**ğŸ¯ Primary Goal**: æ±äº¬é§…å‘¨è¾ºã®3Då¯è¦–åŒ–ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é–‹ç™º â†’ **âœ… å®Œäº†**  
**ğŸ¯ Secondary Goal**: Three.jsç”¨ã®å†åˆ©ç”¨å¯èƒ½ãªTDDãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®æ§‹ç¯‰ â†’ **âœ… å®Œäº†**

**ã™ã¹ã¦ã®ãƒ•ã‚§ãƒ¼ã‚ºãŒTypeScriptå®Ÿè£…ã§çµ±åˆçš„ã«å®Œäº†:**
- âœ… **Testing Framework**: ThreeTestUtilsã€ã‚«ã‚¹ã‚¿ãƒ Jestãƒãƒƒãƒãƒ£ãƒ¼
- âœ… **Main Application**: React + Three.js + TypeScriptåŸºç›¤
- âœ… **Tokyo Station**: æ±äº¬é§…3Då¯è¦–åŒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- âœ… **GIS Integration**: åº§æ¨™å¤‰æ›ã€åœ°ç†ãƒ‡ãƒ¼ã‚¿çµ±åˆ

## ğŸš€ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ

### ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
npm install web3d-explorer
# ã¾ãŸã¯
yarn add web3d-explorer
```

### åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•

```typescript
import { createExplorer } from 'web3d-explorer';
import * as THREE from 'three';

// åŸºæœ¬çš„ãª3Dã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’ä½œæˆ
const explorer = createExplorer({
  scene: {
    background: new THREE.Color(0x87ceeb)
  },
  camera: {
    fov: 60,
    aspect: window.innerWidth / window.innerHeight,
    near: 0.1,
    far: 1000,
    position: { x: 0, y: 5, z: 10 }
  },
  renderer: {
    antialias: true
  },
  lights: [
    {
      type: 'directional',
      color: new THREE.Color(0xffffff),
      intensity: 1.0,
      position: { x: 5, y: 10, z: 5 }
    }
  ]
});

// ã‚·ãƒ³ãƒ—ãƒ«ãªã‚­ãƒ¥ãƒ¼ãƒ–ã‚’è¿½åŠ 
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);

explorer.addObject(cube, {
  position: { x: 0, y: 0, z: 0 },
  name: 'my-cube'
});

// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
explorer.animate();
```

### Reactä½¿ç”¨ä¾‹

```tsx
import React from 'react';
import { Web3DExplorerComponent } from 'web3d-explorer';
import * as THREE from 'three';

const MyApp: React.FC = () => {
  const config = {
    scene: {
      background: new THREE.Color(0x87ceeb)
    },
    camera: {
      fov: 60,
      aspect: window.innerWidth / window.innerHeight,
      near: 0.1,
      far: 1000
    },
    renderer: {
      antialias: true
    },
    lights: [
      {
        type: 'directional' as const,
        color: new THREE.Color(0xffffff),
        intensity: 1.0,
        position: { x: 5, y: 10, z: 5 }
      }
    ]
  };

  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <Web3DExplorerComponent
        config={config}
        onExplorerReady={(explorer) => {
          console.log('Explorer ready!', explorer);
        }}
      />
    </div>
  );
};

export default MyApp;
```

### æ±äº¬é§…ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼

```tsx
import React from 'react';
import { TokyoStationExplorer } from 'web3d-explorer';

const TokyoStationApp: React.FC = () => {
  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <TokyoStationExplorer
        showDebugInfo={true}
        onLoadComplete={() => {
          console.log('Tokyo Station loaded!');
        }}
      />
    </div>
  );
};

export default TokyoStationApp;
```

## ğŸ“ ç¾åœ¨ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

```
Web3DExplorer/
â”œâ”€â”€ src/                       # TypeScriptå®Ÿè£…
â”‚   â”œâ”€â”€ core/                  # ã‚³ã‚¢Explorerã‚¯ãƒ©ã‚¹
â”‚   â”‚   â””â”€â”€ Explorer.ts        âœ… å®Œäº†
â”‚   â”œâ”€â”€ components/            # Reactã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”‚   â”œâ”€â”€ Web3DExplorerComponent.tsx âœ… å®Œäº†
â”‚   â”‚   â””â”€â”€ TokyoStationExplorer.tsx   âœ… å®Œäº†
â”‚   â”œâ”€â”€ gis/                   # GISæ©Ÿèƒ½
â”‚   â”‚   â””â”€â”€ GISManager.ts      âœ… å®Œäº†
â”‚   â”œâ”€â”€ test/                  # ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚   â”‚   â””â”€â”€ ThreeTestUtils.ts  âœ… å®Œäº†
â”‚   â”œâ”€â”€ types/                 # TypeScriptå‹å®šç¾©
â”‚   â”‚   â”œâ”€â”€ index.ts           âœ… å®Œäº†
â”‚   â”‚   â”œâ”€â”€ gis.ts            âœ… å®Œäº†
â”‚   â”‚   â””â”€â”€ testing.ts        âœ… å®Œäº†
â”‚   â”œâ”€â”€ utils/                 # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚   â”‚   â””â”€â”€ EventEmitter.ts    âœ… å®Œäº†
â”‚   â””â”€â”€ index.ts              âœ… å®Œäº†
â”œâ”€â”€ __tests__/                 # ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«
â”‚   â”œâ”€â”€ Explorer.test.ts       âœ… å®Œäº†
â”‚   â””â”€â”€ GISManager.test.ts     âœ… å®Œäº†
â”œâ”€â”€ examples/                  # ä½¿ç”¨ä¾‹
â”‚   â”œâ”€â”€ basic-example.html     âœ… å®Œäº†
â”‚   â””â”€â”€ react-example.tsx      âœ… å®Œäº†
â”œâ”€â”€ three-test-suite/          # å¾“æ¥ã®ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆï¼ˆçµ±åˆæ¸ˆã¿ï¼‰
â””â”€â”€ docs/                      # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
```

## ğŸ§ª TDDé–‹ç™ºã¨ãƒ†ã‚¹ãƒˆ

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```bash
# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm test

# ã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰ã§ãƒ†ã‚¹ãƒˆ
npm run test:watch

# ã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ããƒ†ã‚¹ãƒˆ
npm run test:coverage

# Three.jsãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ
npm run test:suite
```

### ThreeTestUtilsã‚’ä½¿ç”¨ã—ãŸãƒ†ã‚¹ãƒˆä½œæˆ

```typescript
import { threeTestUtils, createMockScene } from 'web3d-explorer/test';
import * as THREE from 'three';

describe('My 3D Component', () => {
  let scene: THREE.Scene;
  let cube: THREE.Mesh;

  beforeEach(() => {
    const mockScene = createMockScene();
    scene = mockScene.scene;
    
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    cube = new THREE.Mesh(geometry, material);
  });

  it('should position cube correctly', () => {
    cube.position.set(5, 10, 15);
    
    threeTestUtils.expectObject3D(cube).toHavePosition(
      new THREE.Vector3(5, 10, 15)
    );
  });

  it('should be visible', () => {
    threeTestUtils.expectObject3D(cube).toBeVisible();
  });

  it('should be in camera frustum', () => {
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    camera.position.z = 5;
    
    threeTestUtils.expectObject3D(cube).toBeInFrustum(camera);
  });
});
```

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### **TypeScriptå‹ã‚·ã‚¹ãƒ†ãƒ **
```
å‹å®šç¾©ã‚·ã‚¹ãƒ†ãƒ 
â”œâ”€â”€ Core Types (Explorer, PerformanceMetrics, Object3DConfig)
â”œâ”€â”€ GIS Types (GeoCoordinates, BuildingData, TerrainData)
â”œâ”€â”€ Testing Types (TestScenario, VisualTest, ThreeTestUtils)
â””â”€â”€ React Types (Component Props, Event Handlers)
```

### **ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³**
```
Explorer (TypeScript Core)
â”œâ”€â”€ Scene3D (Three.jsç®¡ç†)
â”‚   â”œâ”€â”€ TokyoStationModel (3D Asset) âœ…
â”‚   â”œâ”€â”€ CameraController (åˆ¶å¾¡) âœ…
â”‚   â””â”€â”€ LightingSystem (ç…§æ˜) âœ…
â”œâ”€â”€ GISManager (Cesiumçµ±åˆ) âœ…
â”œâ”€â”€ React Components (UI) âœ…
â””â”€â”€ ThreeTestUtils (ãƒ†ã‚¹ãƒˆã‚µãƒãƒ¼ãƒˆ) âœ…
```

## ğŸ”§ æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

### **ã‚³ã‚¢å®Ÿè£…**
- **TypeScript 5.0+**: å‹å®‰å…¨æ€§ã¨ãƒ¢ãƒ€ãƒ³JSæ©Ÿèƒ½
- **Three.js 0.163.0+**: 3Dãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ»ã‚·ãƒ¼ãƒ³ç®¡ç†
- **React 18.2+**: UIãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
- **@react-three/fiber 8.16.0+**: React Three.jsçµ±åˆ

### **é–‹ç™ºãƒ»ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«**
- **Vite**: é«˜é€Ÿãƒ“ãƒ«ãƒ‰ã‚·ã‚¹ãƒ†ãƒ 
- **Jest + ts-jest**: TypeScriptå¯¾å¿œãƒ†ã‚¹ãƒˆç’°å¢ƒ
- **ESLint + @typescript-eslint**: TypeScriptå¯¾å¿œãƒªãƒ³ã‚¿ãƒ¼
- **Prettier**: ã‚³ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼

### **ãƒ†ã‚¹ãƒ†ã‚£ãƒ³ã‚°ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**
- **Jest Custom Matchers**: 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”¨ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒãƒ£ãƒ¼ âœ…
- **Puppeteer**: ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹ãƒ–ãƒ©ã‚¦ã‚¶ãƒ†ã‚¹ãƒˆ âœ…
- **Performance Testing**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ âœ…

## ğŸš¦ é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

```bash
# ãƒªãƒã‚¸ãƒˆãƒªã‚¯ãƒ­ãƒ¼ãƒ³
git clone https://github.com/usaganikki/Web3DExplorer.git
cd Web3DExplorer

# ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install

# é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•
npm run dev

# å‹ãƒã‚§ãƒƒã‚¯
npm run type-check

# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm test

# ãƒ“ãƒ«ãƒ‰
npm run build
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

```typescript
// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®å–å¾—
explorer.on('frame', ({ stats }) => {
  console.log('FPS:', stats.fps);
  console.log('Frame Time:', stats.frameTime, 'ms');
  console.log('Triangles:', stats.triangleCount);
  console.log('Draw Calls:', stats.drawCalls);
});

// ç¾åœ¨ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹å–å¾—
const metrics = explorer.getMetrics();
```

## ğŸ—ºï¸ GISçµ±åˆ

```typescript
import { GISManager, TOKYO_PROJECTION } from 'web3d-explorer';

const gisManager = new GISManager(TOKYO_PROJECTION);

// ç·¯åº¦çµŒåº¦ã‚’3Dåº§æ¨™ã«å¤‰æ›
const worldPos = gisManager.geoToWorld({
  latitude: 35.6812,  // æ±äº¬é§…
  longitude: 139.7671,
  altitude: 0
});

// åœ°ç†åº§æ¨™ã«æˆ»ã™
const geoPos = gisManager.worldToGeo(worldPos);
```

## ğŸ“š API ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

### Explorer ã‚¯ãƒ©ã‚¹

```typescript
class Explorer {
  constructor(config: Web3DExplorerConfig, container?: HTMLElement)
  
  // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
  addObject(object: THREE.Object3D, config?: Object3DConfig): void
  removeObject(object: THREE.Object3D): void
  
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  animate(callback?: () => void): void
  render(): void
  
  // ã‚¤ãƒ™ãƒ³ãƒˆ
  on<T>(event: string, handler: EventHandler<T>): void
  off<T>(event: string, handler: EventHandler<T>): void
  emit<T>(event: string, data?: T): void
  
  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
  getMetrics(): PerformanceMetrics
  
  // ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«
  resize(width: number, height: number): void
  dispose(): void
}
```

### GISManager ã‚¯ãƒ©ã‚¹

```typescript
class GISManager {
  constructor(projection?: ProjectionSystem, center?: GeoCoordinates)
  
  // åº§æ¨™å¤‰æ›
  geoToWorld(coords: GeoCoordinates): Position3D
  worldToGeo(position: Position3D): GeoCoordinates
  
  // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
  loadTerrain(url: string): Promise<TerrainData>
  loadBuildings(url: string): Promise<BuildingData[]>
  loadRoads(url: string): Promise<RoadData[]>
  loadPOIs(url: string): Promise<POIData[]>
  
  // 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
  createTerrain(data: TerrainData): THREE.Mesh
  createBuilding(data: BuildingData): THREE.Group
  createRoad(data: RoadData): THREE.Line
  createPOI(data: POIData): THREE.Sprite
}
```

## ğŸ¯ ç¾åœ¨ã®ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³

âœ… **v0.1.0 - TypeScript Migration Complete**
- å®Œå…¨ãªTypeScriptåŒ–
- React Three Fiberçµ±åˆ
- GISæ©Ÿèƒ½å®Ÿè£…
- æ±äº¬é§…ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼
- åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯

ğŸ”„ **v0.2.0 - Enhanced Features (è¨ˆç”»ä¸­)**
- WebXRå¯¾å¿œï¼ˆVR/ARï¼‰
- WebGL 2.0æ´»ç”¨
- é«˜åº¦ãªGISçµ±åˆ
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

## ğŸ¤ ã‚³ãƒ³ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³

1. ãƒªãƒã‚¸ãƒˆãƒªã‚’ãƒ•ã‚©ãƒ¼ã‚¯
2. æ©Ÿèƒ½ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆ: `git checkout -b feature/amazing-feature`
3. å¤‰æ›´ã«å¯¾ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚’ä½œæˆ
4. å…¨ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèª: `npm test`
5. å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ: `git commit -m 'Add amazing feature'`
6. ãƒ–ãƒ©ãƒ³ãƒã«ãƒ—ãƒƒã‚·ãƒ¥: `git push origin feature/amazing-feature`
7. ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆ

### **TDDé–‹ç™ºæ–¹é‡**

ğŸ”´ **RED**: ãƒ†ã‚¹ãƒˆã‚’æ›¸ãï¼ˆå¤±æ•—ï¼‰  
ğŸŸ¢ **GREEN**: æœ€å°é™ã®å®Ÿè£…ï¼ˆãƒ†ã‚¹ãƒˆé€šéï¼‰  
ğŸ”§ **REFACTOR**: ã‚³ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—

### **ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼åŸºæº–**
- ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸90%ä»¥ä¸Š
- ESLint/Prettieræº–æ‹ 
- TypeDocå½¢å¼ã®ã‚³ãƒ¡ãƒ³ãƒˆ
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶ï¼ˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ™‚é–“10ç§’ä»¥å†…ï¼‰

## ğŸ“‹ èª²é¡Œã¨ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

### Known Issues
- WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ­ã‚¹: è‡ªå‹•å¾©æ—§æœªå®Ÿè£…
- ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè§£æ”¾ã®ä¸€éƒ¨ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹
- ãƒ¢ãƒã‚¤ãƒ«æ€§èƒ½: ã‚¿ãƒƒãƒåˆ¶å¾¡ã®æœ€é©åŒ–ãŒå¿…è¦
- Safariäº’æ›æ€§: ä¸€éƒ¨WebGLæ‹¡å¼µãŒåˆ©ç”¨ã§ããªã„å ´åˆã‚ã‚Š

### Future Roadmap
- **WebXRçµ±åˆ**: VR/ARå¯¾å¿œ
- **é«˜åº¦ãªGIS**: äººæ°—GISãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹çµ±åˆ
- **ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£**: 3Dã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: å¤§è¦æ¨¡ã‚·ãƒ¼ãƒ³ã®æœ€é©åŒ–

## ğŸ“š å‚è€ƒè³‡æ–™

### **TypeScript & Three.jsé–¢é€£**
- [TypeScriptå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://www.typescriptlang.org/)
- [Three.js Documentation](https://threejs.org/docs/)
- [React Three Fiber](https://docs.pmnd.rs/react-three-fiber)

### **TDD Methodology**
- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Test-Driven Development: By Example](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530)

### **GIS Integration**
- [Cesium.js Documentation](https://cesium.com/learn/)
- [åœ°ç†åº§æ¨™ç³»ã«ã¤ã„ã¦](https://www.gsi.go.jp/sokuchikijun/datum-main.html)

## ğŸ“„ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯MITãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ä¸‹ã§å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ - è©³ç´°ã¯[LICENSE](LICENSE)ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## ğŸ“ å¤‰æ›´å±¥æ­´

### v0.1.0 (2025-06-01)

- âœ¨ **å®Œå…¨ãªTypeScriptå®Ÿè£…**
  - å‹å®‰å…¨æ€§ã®å¤§å¹…å‘ä¸Š
  - IntelliSenseã‚µãƒãƒ¼ãƒˆ
  - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã‚¨ãƒ©ãƒ¼æ¤œå‡º

- âœ¨ **React Three Fiberçµ±åˆ**
  - Reactã¨Three.jsã®å®Œå…¨çµ±åˆ
  - TypeScriptå¯¾å¿œã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
  - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–æ©Ÿèƒ½

- âœ¨ **GISçµ±åˆã¨æ±äº¬æŠ•å½±ã‚·ã‚¹ãƒ†ãƒ **
  - åœ°ç†åº§æ¨™ç³»å¯¾å¿œ
  - æ±äº¬é§…ä¸­å¿ƒã®æŠ•å½±ã‚·ã‚¹ãƒ†ãƒ 
  - 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªå‹•ç”Ÿæˆ

- âœ¨ **åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**
  - ThreeTestUtilsã‚¯ãƒ©ã‚¹
  - ã‚«ã‚¹ã‚¿ãƒ Jestãƒãƒƒãƒãƒ£ãƒ¼
  - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½
  - ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«å›å¸°ãƒ†ã‚¹ãƒˆ

- âœ¨ **æ±äº¬é§…ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
  - å°‚ç”¨3Då¯è¦–åŒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
  - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åœ°ç†ãƒ‡ãƒ¼ã‚¿çµ±åˆ
  - ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–3Dãƒ¢ãƒ‡ãƒ«

- âœ¨ **ãƒ¢ãƒ€ãƒ³é–‹ç™ºç’°å¢ƒ**
  - Viteãƒ“ãƒ«ãƒ‰ã‚·ã‚¹ãƒ†ãƒ 
  - ESLint + TypeScriptè¨­å®š
  - Prettierçµ±åˆ
  - GitHub Actionså¯¾å¿œ

---

**3D Webãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®ãŸã‚ã« â¤ï¸ ã§ä½œæˆ**

**Last Updated**: 2025-06-01  
**Version**: 0.1.0  
**Status**: âœ… TypeScript Migration Complete
</file>

<file path="three-test-suite/jest.config.js">
// three-test-suite/jest.config.js
const jsEsmTransform = {
  // ts-jest ã‚’ä½¿ã£ã¦ .js/.jsx ã‚‚ ESM ã¨ã—ã¦ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«
  '^.+\\.(js|jsx)$': ['ts-jest', { useESM: true }],
  // three-test-suite ã« .ts/.tsx ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Œã°ã€ä»¥ä¸‹ã‚‚è¿½åŠ 
  // '^.+\\.(ts|tsx)$': ['ts-jest', { useESM: true, tsconfig: { jsx: 'react-jsx' } }],
};

// three-test-suite ã§ puppeteer ç­‰ã® ESM ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ node_modules ã‹ã‚‰åˆ©ç”¨ã™ã‚‹å ´åˆã«è¨­å®š
const suiteTransformIgnorePatterns = [
  'node_modules/(?!(puppeteer)/)' // puppeteer ã¯ ESM ãªã®ã§ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«å¯¾è±¡ã‹ã‚‰é™¤å¤–ã—ãªã„
];

export default {
  projects: [
    {
      displayName: "puppeteer-tests",
      preset: 'ts-jest/presets/default-esm', // ESMã‚µãƒãƒ¼ãƒˆã®ãŸã‚
      transform: jsEsmTransform,
      extensionsToTreatAsEsm: ['.jsx'], // .jsx ã‚’ ESM ã¨ã—ã¦æ‰±ã† ( .js ã¯ package.json ã® type: module ã§è‡ªå‹•åˆ¤åˆ¥)
      moduleFileExtensions: ['js', 'jsx', 'json', 'node'], // ä¸»ã«JSãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†
      testMatch: [
        "**/__tests__/unit/*PuppeteerManager*.test.js",
        "**/__tests__/unit/*BrowserManager*.test.js",
        "**/__tests__/unit/*TestUtils*.test.js",
        "**/__tests__/unit/*EnvironmentInspector*.test.js",
        "**/__tests__/performance/*PerformanceTester*.test.js",
        "**/__tests__/unit/*ThreeTestSuite*.test.js",
        "**/__tests__/unit/*SceneInspector*.test.js"
      ],
      testEnvironment: "node",
      transformIgnorePatterns: suiteTransformIgnorePatterns,
    },
    {
      displayName: "dom-tests",
      preset: 'ts-jest/presets/default-esm', // ESMã‚µãƒãƒ¼ãƒˆã®ãŸã‚
      transform: jsEsmTransform,
      extensionsToTreatAsEsm: ['.jsx'], // .jsx ã‚’ ESM ã¨ã—ã¦æ‰±ã† ( .js ã¯ package.json ã® type: module ã§è‡ªå‹•åˆ¤åˆ¥)
      moduleFileExtensions: ['js', 'jsx', 'json', 'node'], // ä¸»ã«JSãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†
      testMatch: [
        "**/__tests__/unit/*HTMLGenerator*.test.js",
      ],
      testEnvironment: "jsdom",
      transformIgnorePatterns: suiteTransformIgnorePatterns, // DOMãƒ†ã‚¹ãƒˆã§puppeteerã¯é€šå¸¸ä¸è¦ã ãŒã€å…±é€šè¨­å®šã¨ã—ã¦ãŠã
    },
    {
      displayName: "integration-tests",
      preset: 'ts-jest/presets/default-esm', // ESMã‚µãƒãƒ¼ãƒˆã®ãŸã‚
      transform: jsEsmTransform,
      extensionsToTreatAsEsm: ['.jsx'], // .jsx ã‚’ ESM ã¨ã—ã¦æ‰±ã† ( .js ã¯ package.json ã® type: module ã§è‡ªå‹•åˆ¤åˆ¥)
      moduleFileExtensions: ['js', 'jsx', 'json', 'node'], // ä¸»ã«JSãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†
      testMatch: [
        "**/__tests__/integration/*.test.js",
      ],
      testEnvironment: "node",
      transformIgnorePatterns: suiteTransformIgnorePatterns,
      // çµ±åˆãƒ†ã‚¹ãƒˆã¯ç¾åœ¨ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ä¸­ã«ã¤ãé™¤å¤–
      // testPathIgnorePatterns: [  // â† ã“ã®è¡Œã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
      //   "**/__tests__/integration/.*\\.test\\.js$" // â† ã“ã®è¡Œã‚‚ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
      // ],
    }
  ],
  collectCoverageFrom: [
    'src/**/*.(js|jsx)', // ã‚«ãƒãƒ¬ãƒƒã‚¸ã¯JS/JSXãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰
    '!**/node_modules/**'
  ],
  testTimeout: 60000, // TestUtilsã‚’å«ã‚€å…¨ãƒ†ã‚¹ãƒˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
  detectOpenHandles: true,
  verbose: true, // è©³ç´°ãªãƒ†ã‚¹ãƒˆçµæœã‚’è¡¨ç¤º
  bail: false, // ä¸€ã¤ã®ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ã¦ã‚‚å…¨ãƒ†ã‚¹ãƒˆã‚’ç¶™ç¶šå®Ÿè¡Œ
};
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x] # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã‚µãƒãƒ¼ãƒˆã™ã‚‹Node.jsã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install Puppeteer dependencies
      run: |
        # Update package lists
        sudo apt-get update
        # Install libgbm-dev, a necessary dependency for running Chrome/Chromium (used by Puppeteer)
        # in a headless environment. libgbm (Generic Buffer Management) is part of Mesa 3D Graphics Library
        # and allows buffer management without a display server.
        sudo apt-get install -y libgbm-dev

    - name: Install dependencies
      run: npm ci

    # - name: Run tests
    #   run: npm test

    - name: Install three-test-suite dependencies
      run: cd three-test-suite && npm ci

    #  ä»Šã¯Unitãƒ†ã‚¹ãƒˆã ã‘ã‚’å¯¾è±¡ã¨ã™ã‚‹
    - name: Run test unit
      run: cd three-test-suite && npm run test:unit

    - name: Run repomix
      if: success() # å‰ã®ã‚¹ãƒ†ãƒƒãƒ—ãŒã™ã¹ã¦æˆåŠŸã—ãŸå ´åˆã®ã¿å®Ÿè¡Œ
      run: npx repomix
</file>

<file path="three-test-suite/src/HTMLGenerator.js">
/**
 * HTMLGenerator
 * ãƒ†ã‚¹ãƒˆç”¨ã®HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã‚¯ãƒ©ã‚¹
 */
export class HTMLGenerator {
  /**
   * Three.jsç”¨ã®HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç”Ÿæˆã™ã‚‹
   * @param {Function} userScript - ãƒšãƒ¼ã‚¸ã«æ³¨å…¥ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
   * @param {Object} options - ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @param {string} options.title - ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ« (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 'Three.js Test Environment')
   * @param {string} options.threeJsVersion - Three.jsã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 'r128')
   * @param {boolean} options.autoExecute - ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®è‡ªå‹•å®Ÿè¡Œ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: true)
   * @returns {string} ç”Ÿæˆã•ã‚ŒãŸHTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
   * @throws {Error} ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒç„¡åŠ¹ãªå ´åˆ
   */
  generateTestHTML(userScript, options = {}) {
    if (typeof userScript !== 'function') {
      throw new Error('userScript must be a function');
    }

    const config = {
      title: 'Three.js Test Environment',
      threeJsVersion: '0.173.0', // 0.xxx.xxx å½¢å¼ã«ä¿®æ­£
      autoExecute: true,
      ...options
    };

    const userScriptString = userScript.toString();
    const versionToUse = options.threeJsVersion || config.threeJsVersion;
    const threeJsUrl = this._getThreeJsUrl(versionToUse);

    const scriptExecution = config.autoExecute
      ? `
        window.addEventListener('load', function() {
            try {
                if (typeof THREE === 'undefined') {
                    console.error('Three.js failed to load');
                    window.threeJsLoadError = true;
                    return;
                }
                (${userScriptString})();
            } catch (error) {
                console.error('Error executing user script:', error);
                window.userScriptError = error;
            }
        });`
      : `
        window.userScript = ${userScriptString};`;

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${config.title}</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #three-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="three-canvas"></canvas>
    <div class="debug-info" id="debug-info">
        Debug info will appear here
    </div>
    
    <script>
        window.threeJsLoadError = false;
        window.threeJsLoaded = false; // åˆæœŸçŠ¶æ…‹ã‚’ false ã«è¨­å®š

        (async function() {
            try {
                const THREE_MODULE = await import('${threeJsUrl}');
                window.THREE = THREE_MODULE;
                console.log('Three.js loaded successfully');
                window.threeJsLoaded = true;
            } catch (e) {
                console.error('Failed to load Three.js from:', '${threeJsUrl}', e);
                window.threeJsLoadError = true;
            }
        })();
    </script>
    
    <script>${scriptExecution}
    </script>
</body>
</html>`;
  }

  /**
   * Three.jsã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å¿œã˜ãŸé©åˆ‡ãªCDN URLã‚’ç”Ÿæˆã™ã‚‹
   * @param {string} version - Three.jsã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³
   * @returns {string} CDN URL
   * @private
   */
  _getThreeJsUrl(version) {
    const defaultVersion = '0.173.0'; // ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡ç¤ºã®åŸºæœ¬ãƒãƒ¼ã‚¸ãƒ§ãƒ³
    const cdnjsBaseUrl = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/';

    let targetVersion = version || defaultVersion;
    let fileName = 'three.module.min.js'; // å¸¸ã« three.module.min.js ã‚’ä½¿ç”¨

    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³å½¢å¼ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³: '0.xxx.xxx' å½¢å¼ã§ã‚ã‚‹ã“ã¨
    const versionRegex = /^\d+\.\d+\.\d+$/;
    if (!versionRegex.test(targetVersion)) {
      throw new Error(`Invalid Three.js version format: "${targetVersion}". Expected format "0.xxx.xxx".`);
    }

    return `${cdnjsBaseUrl}${targetVersion}/${fileName}`;
  }
}
</file>

<file path="three-test-suite/src/PuppeteerManager.js">
import { BrowserManager } from './BrowserManager.js';
import { EnvironmentInspector } from './EnvironmentInspector.js';
import { PerformanceTester } from './PerformanceTester.js';
import { HTMLGenerator } from './HTMLGenerator.js';
import { ThreeTestSuite } from './threejs/ThreeTestSuite.js';

/**
 * PuppeteerManager
 * Three.js ãƒ†ã‚¹ãƒˆç”¨ã®Puppeteeré–¢é€£æ©Ÿèƒ½ã‚’çµ±æ‹¬ã™ã‚‹ã‚¯ãƒ©ã‚¹
 * Three.jsæ©Ÿèƒ½ã¯ThreeTestSuiteã«ç§»è¡Œæ¸ˆã¿ï¼ˆIssue #18 Phase1å¯¾å¿œï¼‰
 */
export class PuppeteerManager {
  constructor(options = {}) {
    this.browserManager = new BrowserManager(options);
    this.environmentInspector = new EnvironmentInspector(this.browserManager);
    this.performanceTester = new PerformanceTester(this.browserManager);
    this.htmlGenerator = new HTMLGenerator();
    
    // Three.jså°‚ç”¨ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’è¿½åŠ 
    this.threeTestSuite = new ThreeTestSuite(this.browserManager);
  }

  async initialize() {
    await this.browserManager.initialize();
    await this.threeTestSuite.initialize();
  }

  async cleanup() {
    await this.browserManager.cleanup();
  }

  isInitialized() {
    return this.browserManager.isInitialized();
  }

  get page() {
    return this.browserManager.page;
  }
  
  get browser() {
    return this.browserManager.browser;
  }

  get options() {
    return this.browserManager.options;
  }

  // === æ—¢å­˜ã®ç’°å¢ƒãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰ ===
  async getWebGLInfo() {
    return this.environmentInspector.getWebGLInfo();
  }

  async getWebAssemblyInfo() {
    return this.environmentInspector.getWebAssemblyInfo();
  }

  async benchmarkWebAssembly() {
    return this.performanceTester.benchmarkWebAssembly();
  }

  async getHybridCapabilities() {
    return this.environmentInspector.getHybridCapabilities();
  }

  async benchmarkHybridPerformance(options = {}) {
    return this.performanceTester.benchmarkHybridPerformance(options);
  }

  generateTestHTML(userScript, options = {}) {
    return this.htmlGenerator.generateTestHTML(userScript, options);
  }

  // === Three.jsé–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆThreeTestSuiteã¸ã®å§”ä»»ï¼‰ ===
  
  /**
   * Three.jsã‚·ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã€æŒ‡å®šã•ã‚ŒãŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—é–¢æ•°ã‚’å®Ÿè¡Œã™ã‚‹
   * @deprecated ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ThreeTestSuite.loadThreeSceneã«ç§»è¡Œã•ã‚Œã¾ã—ãŸ
   * äº’æ›æ€§ã®ãŸã‚æ®‹ã•ã‚Œã¦ã„ã¾ã™ãŒã€ç›´æ¥threeTestSuite.loadThreeScene()ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨
   * @param {Function} sceneBuilderFunction - Three.jsã®ã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹é–¢æ•°
   * @param {Object} options - ãƒ­ãƒ¼ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ (title, threeJsVersion, timeoutãªã©)
   * @returns {Promise<void>}
   */
  async loadThreeScene(sceneBuilderFunction, options = {}) {
    return this.threeTestSuite.loadThreeScene(sceneBuilderFunction, options);
  }

  /**
   * åŒ…æ‹¬çš„ãªThree.jsãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
   * ThreeTestSuiteã«å§”ä»»
   * @returns {Promise<Object>} ãƒ†ã‚¹ãƒˆçµæœ
   */
  async runComprehensiveTest() {
    return this.threeTestSuite.runComprehensiveTest();
  }

  /**
   * è¡¨ç¤ºä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—
   * ThreeTestSuiteã«å§”ä»»ï¼ˆå°†æ¥çš„ã«ObjectAnalyzerã§å®Ÿè£…äºˆå®šï¼‰
   * @returns {Promise<Array>} è¡¨ç¤ºä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§
   */
  async getVisibleObjects() {
    return this.threeTestSuite.getVisibleObjects();
  }

  /**
   * ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ¤œè¨¼ã‚’å®Ÿè¡Œ
   * ThreeTestSuiteã«å§”ä»»ï¼ˆå°†æ¥çš„ã«RenderingValidatorã§å®Ÿè£…äºˆå®šï¼‰
   * @returns {Promise<Object>} ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°çµæœ
   */
  async validateRendering() {
    return this.threeTestSuite.validateRendering();
  }

  /**
   * ThreeTestSuiteã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—
   * ç›´æ¥Three.jsæ©Ÿèƒ½ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã„å ´åˆã«ä½¿ç”¨
   * @returns {ThreeTestSuite} ThreeTestSuiteã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
   */
  getThreeTestSuite() {
    return this.threeTestSuite;
  }
}
</file>

<file path="three-test-suite/package.json">
{
  "name": "three-test-suite",
  "version": "0.1.0",
  "description": "TDD testing framework for Three.js applications",
  "type": "module",
  "main": "src/index.js",
  "scripts": {
    "test": "node --experimental-vm-modules node_modules/.bin/jest --config jest.config.js --forceExit",
    "test:watch": "node --experimental-vm-modules node_modules/.bin/jest --config jest.config.js --watch",
    "test:puppeteer": "node --experimental-vm-modules node_modules/.bin/jest --config jest.config.js --selectProjects=puppeteer-tests --forceExit",
    "test:dom": "node --experimental-vm-modules node_modules/.bin/jest --config jest.config.js --selectProjects=dom-tests --forceExit",
    "test:integration": "node --experimental-vm-modules node_modules/.bin/jest --config jest.config.js --selectProjects=integration-tests --forceExit",
    "test:unit": "node --experimental-vm-modules node_modules/.bin/jest --config jest.config.js __tests__/unit --forceExit",
    "test:performance": "node --experimental-vm-modules node_modules/.bin/jest --config jest.config.js __tests__/performance --forceExit",
    "test:coverage": "node --experimental-vm-modules node_modules/.bin/jest --config jest.config.js --coverage --forceExit"
  },
  "dependencies": {
    "puppeteer": "^22.0.0",
    "three": "^0.163.0"
  },
  "devDependencies": {
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0"
  }
}
</file>

</files>
